---
title: "09_validation_prediction"
author: "Lasse Meyer"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Software requirements

```{r lib, message=FALSE,warning=FALSE}
#Data containers
library(SpatialExperiment)
library(SingleCellExperiment)

#Data processing
library(scuttle)
library(scater)
library(scran)
library(imcRtools)

#Data visualization
library(cytomapper)
library(dittoSeq)
library(pheatmap)
library(cowplot)
library(ComplexHeatmap)
library(circlize)

#Utilities
library(tidyverse)
library(openxlsx)
library(stringr)
library(patchwork)
library(parallel)
library(BiocParallel)
library(BiocNeighbors)
library(BiocSingular)
library(tiff)
library(ggrepel)
library(EBImage)
library(viridis)
library(mclust)
library(Rphenograph)
library(igraph)
library(RColorBrewer)
library(foreach)
library(clValid)
library(bluster)
library(psych)
library(corrplot)
library(psych)

#Batch correction
library(batchelor)

#Machine learning
library(caret)
library(caretEnsemble)
```

# Classifier for metacluster prediction

Here, we will train a classifier to predict tumor metacluster in an independent validation dataset (Janas data). For this, we will use the `caret` package.

## 1. Read in data (train)

```{r}
##Load sce
sce <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")
```

### Filter for tumor cells

```{r}
sce <- sce[,sce$analysis_cat == "tumor"]
sce$metacluster_combined <- factor(unfactor(sce$metacluster_combined))
sce

## Add more rowData 
# All tumor cluster channels
rowData(sce)$tumor_cluster_channel 
# Sub-select relevant markers
rowData(sce)$tumor_cluster_sub <- rowData(sce)$clean_target %in% c("CK5","CK7","KRT14","CK8_18","CD15","HLADR","Vimentin","pH3","Ki67","EGFR")
#rowData(sce)$tumor_cluster_sub_1 <- rowData(sce)$clean_target %in% c("CK5","CK7","KRT14","CK8_18","CD15","HLADR","Vimentin","Ki67","EGFR")
```

## 2. Train the model

```{r}
library(caret)
library(doParallel)

set.seed(22)

# Register parallel backend 
cl <- makePSOCKcluster(5, setup_strategy = "sequential")
registerDoParallel(cl)

#Set seeds for each iteration for parallel processing
seeds <- vector(mode = "list", length = 6)
for (i in 1:5) {
  seeds[[i]] <- sample(5000, 5)
}
seeds[[6]] <- sample(5000, 1) # for the final model


# Randomly split into train and test data
set.seed(22)
trainIndex <- createDataPartition(sce$metacluster_combined, p = 0.75)
train_sce <- sce[,trainIndex$Resample1]
test_sce <- sce[,-trainIndex$Resample1]

colData(train_sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% count()
colData(test_sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% count()

# Train data
train_data <- t(assay(train_sce, "exprs")[rowData(train_sce)$tumor_cluster_channel,])

# Set folds for CV steps based on PID
folds <- groupKFold(train_sce$PID, k=5) 
#lapply(folds, function(x, y) table(y[x]), y = groups)

# Specify train parameters for 5-fold cross validation
fitControl <- trainControl(method = "cv",
                           number = 5,
                           seeds = seeds, 
                           index = folds)

# Train a random forest model for predicting cell labels
# This call also performs parameter tuning
rffit <- train(x = train_data, 
               y = train_sce$metacluster_combined,
               method = "rf", 
               metric = 'Accuracy',
               tuneLength = 5,
               trControl = fitControl)

rffit
stopCluster(cl)

saveRDS(rffit, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/randomforest_metacluster_pred_folds_allmarkers.rds")

#rffit_all <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/randomforest_metacluster_pred.rds")
#rffit_sub <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/randomforest_metacluster_pred_submarker.rds")
#rffit <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/randomforest_metacluster_pred_submarker.rds")
```

```{r}
library(caret)
library(doParallel)

set.seed(22)

# Register parallel backend 
cl <- makePSOCKcluster(5, setup_strategy = "sequential")
registerDoParallel(cl)

#Set seeds for each iteration for parallel processing
seeds <- vector(mode = "list", length = 6)
for (i in 1:5) {
  seeds[[i]] <- sample(5000, 5)
}
seeds[[6]] <- sample(5000, 1) # for the final model


# Randomly split into train and test data
set.seed(22)
trainIndex <- createDataPartition(sce$metacluster_combined, p = 0.75)
train_sce <- sce[,trainIndex$Resample1]
test_sce <- sce[,-trainIndex$Resample1]

colData(train_sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% count()
colData(test_sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% count()

# Train data
train_data <- t(assay(train_sce, "exprs")[rowData(train_sce)$tumor_cluster_sub,])

# Set folds for CV steps based on PID
folds <- groupKFold(train_sce$PID, k=5) 
#lapply(folds, function(x, y) table(y[x]), y = groups)

# Specify train parameters for 5-fold cross validation
fitControl <- trainControl(method = "cv",
                           number = 5,
                           seeds = seeds, 
                           index = folds)

# Train a random forest model for predicting cell labels
# This call also performs parameter tuning
rffit <- train(x = train_data, 
               y = train_sce$metacluster_combined,
               method = "rf", 
               metric = 'Accuracy',
               tuneLength = 5,
               trControl = fitControl)

rffit

saveRDS(rffit, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/randomforest_metacluster_pred_folds_sub.rds")

stopCluster(cl)
```







```{r}
library(caret)
library(doParallel)

set.seed(22)

# Register parallel backend 
cl <- makePSOCKcluster(5)
registerDoParallel(cl)

#Set seeds for each iteration for parallel processing
seeds <- vector(mode = "list", length = 6)
for (i in 1:5) {
  seeds[[i]] <- sample(5000, 5)
}
seeds[[6]] <- sample(5000, 1) # for the final model


# Randomly split into train and test data
set.seed(22)
trainIndex <- createDataPartition(sce$metacluster_combined, p = 0.75)
train_sce <- sce[,trainIndex$Resample1]
test_sce <- sce[,-trainIndex$Resample1]

colData(train_sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% count()
colData(test_sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% count()

# Train data
train_data <- t(assay(train_sce, "exprs")[rowData(train_sce)$tumor_cluster_sub_1,])

# Set folds for CV steps based on PID
folds <- groupKFold(train_sce$PID, k=5) 
#lapply(folds, function(x, y) table(y[x]), y = groups)

# Specify train parameters for 5-fold cross validation
fitControl <- trainControl(method = "cv",
                           number = 5,
                           seeds = seeds, 
                           index = folds)

# Train a random forest model for predicting cell labels
# This call also performs parameter tuning
rffit <- train(x = train_data, 
               y = train_sce$metacluster_combined,
               method = "rf", 
               metric = 'Accuracy',
               tuneLength = 5,
               trControl = fitControl)

rffit
stopCluster(cl)

saveRDS(rffit, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/randomforest_metacluster_pred_folds_sub_1.rds")
```


```{r}
rffit <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/randomforest_metacluster_pred_folds_allmarkers.rds")

rffit_sub <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/randomforest_metacluster_pred_folds_sub.rds")
```

## Assess feature importance

```{r}
# Classification accuracy during parameter tuning
ggplot(rffit) + 
  geom_errorbar(data = rffit$results,
                aes(ymin = Accuracy - AccuracySD,
                    ymax = Accuracy + AccuracySD),
                width = 0.4) +
    theme_classic(base_size = 15)

# Scaled feature importance (Decrease in Gini index)
plot(varImp(rffit))
```


```{r}
out_var <- varImp(rffit, scale = TRUE)
out_var_1 <- varImp(rffit_sub, scale = TRUE)

out_comb <- rbind(
  out_var$importance %>% rownames_to_column("marker") %>% mutate(category = "all_markers"),
  out_var_1$importance %>% rownames_to_column("marker") %>% mutate(category = "sub_markers")
)


ggplot(out_comb, aes(x = reorder(marker, desc(Overall)), y = Overall, fill = category))+
  facet_wrap(~category, scales = "free_x")+
  geom_col()+
  theme_classic()+
  scale_fill_brewer(palette = "Paired")+
  coord_flip()+
  ylab("Scaled feature importance")+
  xlab("Markers")
```



## 3. Predict on test data

```{r}
# Select test data
mat_test <- t(assay(test_sce, "exprs")[rowData(test_sce)$tumor_cluster_channel,])

# Predict cell phenotypes in test data
cur_pred <- predict(rffit, 
                    newdata = mat_test)
```

```{r}
# Select test data
mat_test <- t(assay(test_sce, "exprs")[rowData(test_sce)$tumor_cluster_channel,])

# Predict cell phenotypes in test data
cur_pred <- predict(rffit, 
                    newdata = mat_test)

# Select test data
mat_test_sub <- t(assay(test_sce, "exprs")[rowData(test_sce)$tumor_cluster_sub,])

# Predict cell phenotypes in test data
cur_pred_sub <- predict(rffit_sub, 
                        newdata = mat_test_sub)
```

### Assess classifier performance

```{r}
cm <- confusionMatrix(data = cur_pred, 
                      reference = test_sce$metacluster_combined, 
                      mode = "everything")

cm
```

```{r}
cm_sub <- confusionMatrix(data = cur_pred_sub, 
                      reference = test_sce$metacluster_combined, 
                      mode = "everything")

cm_sub
```


```{r}
df_out <- 
  rbind(
    data.frame(cm$byClass) %>%
      mutate(class = sub("Class: ", "", rownames(cm$byClass))) %>% mutate(category = "all_markers"),
    data.frame(cm_sub$byClass) %>%
      mutate(class = sub("Class: ", "", rownames(cm_sub$byClass))) %>% mutate(category = "sub_markers")
    )

ggplot(df_out) + 
  facet_wrap(~category) +
  geom_point(aes(1-Specificity, Sensitivity, 
                 size = Detection.Rate,
                 fill = class),
             shape = 21) + 
  scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
  theme_classic(base_size = 15) + 
  ylab("Sensitivity (TPR)") +
  xlab("1 - Specificity (FPR)")+
  ggtitle(paste0("Accuracy (all): ",round(cm$overall[1],3)," [",round(cm$overall[3],3)," - ",round(cm$overall[4],3),"]", " Accuracy (sub): ",round(cm_sub$overall[1],3)," [",round(cm_sub$overall[3],3)," - ",round(cm_sub$overall[4],3),"]"))

```

```{r}
library(tidyverse)

data.frame(cm$byClass) %>%
  mutate(class = sub("Class: ", "", rownames(cm$byClass))) %>%
  ggplot() + 
  geom_point(aes(1-Specificity, Sensitivity, 
                 size = Detection.Rate,
                 fill = class),
             shape = 21) + 
  scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
  theme_classic(base_size = 15) + 
  ylab("Sensitivity (TPR)") +
  xlab("1 - Specificity (FPR)")+
  ggtitle(paste0("Accuracy: ",round(cm$overall[1],3)," [",round(cm$overall[3],3)," - ",round(cm$overall[4],3),"]"))
```

```{r}
cur_pred <- predict(rffit, 
                    newdata = mat_test, 
                    type = "prob")
cur_pred$truth <- factor(test_sce$metacluster_combined)

cur_plot <- cur_pred %>%
  pivot_longer(cols = 1:11)

ggplot(cur_plot, aes(x = name, y = value, fill = name)) +
  geom_boxplot(outlier.size = 0.5) +
  facet_wrap(. ~ truth, ncol = 1) + 
  scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)+
  theme(panel.background = element_blank(), 
        axis.text.x = element_text(angle = 45, hjust = 1))
```


#### Subsampling techniques

```{r}
library(caret)
library(doParallel)

set.seed(22)

# Register parallel backend 
cl <- makePSOCKcluster(5)
registerDoParallel(cl)

#Set seeds for each iteration for parallel processing
seeds <- vector(mode = "list", length = 6)
for (i in 1:5) {
  seeds[[i]] <- sample(5000, 5)
}
seeds[[6]] <- sample(5000, 1) # for the final model


# Randomly split into train and test data
set.seed(22)
trainIndex <- createDataPartition(sce$metacluster_combined, p = 0.75)
train_sce <- sce[,trainIndex$Resample1]
test_sce <- sce[,-trainIndex$Resample1]

colData(train_sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% count()
colData(test_sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% count()

# Train data
train_data <- t(assay(train_sce, "exprs")[rowData(train_sce)$tumor_cluster_sub,])

# Set folds for CV steps based on PID
folds <- groupKFold(train_sce$PID, k=5) 

# Try subsampling techniques inside resampling for class imbalances
for(sub_tech in c("up","down", "smote", "rose")){

  # Specify train parameters for 5-fold cross validation
  fitControl <- trainControl(method = "cv",
                            number = 5,
                            seeds = seeds, 
                            index = folds, 
                            sampling = sub_tech)

# Train a random forest model for predicting cell labels
# This call also performs parameter tuning
  rffit <- train(x = train_data, 
                y = train_sce$metacluster_combined,
                method = "rf", 
                metric = 'Accuracy',
                tuneLength = 5,
                trControl = fitControl)
  
  saveRDS(rffit, paste0("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/randomforest_metacluster_pred_folds_sub_",sub_tech, ".rds"))
}

stopCluster(cl)
```





## 4. Read in validation dataset
First, we will read in the `SingleCellExperiment` object containing the cleaned, spillover-corrected single-cell data. 
**Note:** We pre-processed the main cohort together with the validation cohort (including segmentation) to avoid strong batch effects. 

```{r read-data-batch-correction, message=FALSE}
sce_val <- readRDS("/mnt/central_nas/tnbc_volume/TNBC_validation/TNBC_all/data_analysis/04_sce_TNBC_Clus_com_tumor_predicted.rds")
```

Filter sce for validation cohort and tumor cells

```{r filter sce, message=FALSE}
sce_val <- sce_val[,sce_val$analysis_cat == "tumor" & sce_val$TMANr %in% c("TMA21", "TMA26")]
sce_val

# Add rowData 
rowData(sce_val)$tumor_cluster_channel <- rowData(sce)$tumor_cluster_channel
```

Correct survival information 

```{r}
sce_val$status_OS <- ifelse(is.na(sce_val$status_OS) & !is.na(sce_val$OS_months), 0,sce_val$status_OS)
```

## 5. Predict on validation dataset 

### Full marker set 

```{r}
# Select validation expression matrix
mat_valid <- t(assay(sce_val, "exprs")[rowData(sce_val)$tumor_cluster_channel,])

# Predict metacluster
cell_class <- as.character(predict.train(rffit, 
                                         newdata = mat_valid, 
                                         type = "raw"))

names(cell_class) <- rownames(mat_valid)

table(cell_class)
```

```{r}
cell_prob <- predict.train(rffit, 
                           newdata = mat_valid, 
                           type = "prob")
```


```{r}
library(ggridges)

# Distribution of maximum probabilities
tibble(max_prob = rowMax(as.matrix(cell_prob)),
       type = cell_class) %>%
    ggplot() +
        geom_density_ridges(aes(x = max_prob, y = cell_class, fill = cell_class)) +
        scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
        theme_classic(base_size = 15) +
        xlab("Maximum probability") +
        ylab("Metacluster") + 
        xlim(c(0,1.2))

# Distribution of probability margins (max - 2.max)

margin <- cell_prob %>% rownames_to_column(var = "cell_id") %>% pivot_longer(cols = 2:12, values_to = "prob", names_to = "MC") %>% group_by(cell_id) %>% arrange(desc(prob)) %>% summarise(max = max(prob), second = nth(prob,2), MC = MC) %>% mutate(margin = max - second)

margin$MC <- cell_class[match(margin$cell_id, names(cell_class))]

margin <- margin %>% unique()

ggplot(margin, aes(x=margin, y = MC, fill = MC)) +
        geom_density_ridges() +
        scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
        theme_classic(base_size = 15) +
        xlab("Probability margin") +
        ylab("Metacluster") + 
        xlim(c(0,1.2))
```

Add predicted metacluster to sce and save 

```{r}
# Store labels in SpatialExperiment object
sce_val$metacluster_predict <- factor(cell_class[match(sce_val$cell_id, names(cell_class))])

cur_table <- table(sce_val$metacluster_predict, sce_val$PID)
cur_table
```

### Sub marker set 

```{r}
# Select validation expression matrix
mat_valid <- t(assay(sce_val, "exprs")[rowData(sce_val)$tumor_cluster_sub,])

# Predict metacluster
cell_class <- as.character(predict.train(rffit_sub, 
                                         newdata = mat_valid, 
                                         type = "raw"))

names(cell_class) <- rownames(mat_valid)

table(cell_class)
```

```{r}
cell_prob <- predict.train(rffit_sub, 
                           newdata = mat_valid, 
                           type = "prob")
```


```{r}
library(ggridges)

# Distribution of maximum probabilities
tibble(max_prob = rowMax(as.matrix(cell_prob)),
       type = cell_class) %>%
    ggplot() +
        geom_density_ridges(aes(x = max_prob, y = cell_class, fill = cell_class)) +
        scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
        theme_classic(base_size = 15) +
        xlab("Maximum probability") +
        ylab("Metacluster") + 
        xlim(c(0,1.2))

# Distribution of probability margins (max - 2.max)

margin <- cell_prob %>% rownames_to_column(var = "cell_id") %>% pivot_longer(cols = 2:12, values_to = "prob", names_to = "MC") %>% group_by(cell_id) %>% arrange(desc(prob)) %>% summarise(max = max(prob), second = nth(prob,2), MC = MC) %>% mutate(margin = max - second)

margin$MC <- cell_class[match(margin$cell_id, names(cell_class))]

margin <- margin %>% unique()

ggplot(margin, aes(x=margin, y = MC, fill = MC)) +
        geom_density_ridges() +
        scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
        theme_classic(base_size = 15) +
        xlab("Probability margin") +
        ylab("Metacluster") + 
        xlim(c(0,1.2))
```

Add predicted metacluster to sce and save 

```{r}
# Store labels in SpatialExperiment object
sce_val$metacluster_predict_sub <- factor(cell_class[match(sce_val$cell_id, names(cell_class))])

cur_table <- table(sce_val$metacluster_predict_sub, sce_val$PID)
cur_table
```

### Save object 

```{r}
# Save sce object (tumor cells from Janas data with predicted metacluster)
saveRDS(sce_val,"/mnt/central_nas/tnbc_volume/TNBC_validation/TNBC_all/data_analysis/04_sce_TNBC_Clus_com_tumor_predicted.rds")

#sce_val <- readRDS("/mnt/central_nas/tnbc_volume/TNBC_validation/TNBC_all/data_analysis/04_sce_TNBC_Clus_com_tumor_predicted.rds")
```

## 6. Result analysis 

```{r}
# Focus on Patients with high MC8 
colData(sce_val) %>% as.data.frame %>% filter(PID %in% c("2123","924","458","21","863")) %>% select(PID, pN_simple, pM_simple, status_OS, OS_months) %>% unique()

plotSpatial(sce_val[,sce_val$PID == "96"], 
            node_color_by = "metacluster_predict", 
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")

plotSpatial(sce_val[,sce_val$PID == "924"], 
            node_color_by = "CK5", 
            assay_type = "exprs",
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")

plotSpatial(sce_val[,sce_val$PID == "924"], 
            node_color_by = "CK7", 
            assay_type = "exprs",
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")

plotSpatial(sce_val[,sce_val$PID == "2123"], 
            node_color_by = "CK8_18", 
            assay_type = "exprs",
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")
```

```{r}
# Focus on basoluminal cells
cur_scat <- t(assay(sce_val,"exprs")) %>% as.data.frame %>% select("CK5","CK7","CK8_18")

cur_scat$metacluster_predict <- sce_val$metacluster_predict[match(rownames(cur_scat),sce_val$cell_id)]
  
cur_scat <- cur_scat %>% filter(metacluster_predict == "tumor_8")

ggplot(cur_scat, aes(x=CK7, y=CK5, color = metacluster_predict)) +
  geom_point(alpha = 0.5)+
  #stat_density_2d(aes(fill = ..level..), geom="polygon", contour_var = "count")+
  theme_classic()

ggplot(cur_scat, aes(x=CK8_18, y=CK5, color = metacluster_predict)) +
  geom_point(alpha = 0.5)+
  #stat_density_2d(aes(fill = ..level..), geom="polygon", contour_var = "count")+
  theme_classic()
```

### Comparison discovery and validation 

Compare metacluster fractions between discovery and validation cohort 

```{r}
discovery <- colData(sce) %>% as.data.frame %>% select(metacluster_combined) %>% count(metacluster_combined) %>% mutate(fra = n/sum(n))

validation <- colData(sce_val) %>% as.data.frame %>% select(metacluster_predict) %>% count(metacluster_predict) %>% mutate(fra = n/sum(n)) 

discovery$fra_valid <- validation$fra[match(discovery$metacluster_combined, validation$metacluster_predict)]

cor(discovery$fra, discovery$fra_valid, method = "spearman")

spearman_test <- cor.test(discovery$fra, discovery$fra_valid, method = "spearman")

ggplot(discovery, aes(x = fra, y = fra_valid))+
  geom_smooth(method='lm', formula= y~x, se = TRUE, color = "darkgrey")+
  geom_point(aes(color = metacluster_combined), size = 3)+
  scale_color_manual(values=metadata(sce)$colors$metacluster_combined)+
  ylab("Predicted MC fraction (Fischer et al., 2023)")+
  xlab("MC fraction (Discovery)")+
  theme_classic()+
  ggtitle(paste("Spearman rho = ",round(spearman_test$estimate, digits = 2)))
```

Compare mean expression profiles between discovery and validation cohort

```{r}
discovery_exprs <- aggregateAcrossCells(sce, ids = sce$metacluster_combined,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce)$tumor_cluster_channel)

validation_exprs <- aggregateAcrossCells(sce_val, ids = sce_val$metacluster_predict,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce_val)$tumor_cluster_channel)

cor(assay(discovery_exprs, "exprs"),assay(validation_exprs, "exprs"), method = "spearman")

corrplot(cor(assay(discovery_exprs, "exprs"),assay(validation_exprs, "exprs")), method="color", col=brewer.pal(n=8, name="RdBu"),  
         type="upper", order="hclust",hclust.method = "ward.D2", 
         addCoef.col = "black", addCoefasPercent = F,
         tl.col="black", tl.srt=40,
         diag=TRUE)
```


```{r}
# 2. Metacluster
library(tidyverse)
for_plot_MC <- colData(sce_val) %>% as_tibble() %>%
    group_by(PID, metacluster_predict) %>%
    summarize(count = n()) %>%
    mutate(log_count = log(count)) %>%
    pivot_wider(id_cols = PID, names_from = metacluster_predict, 
                values_from = log_count, values_fill = 0) %>%
    ungroup() %>%
    select(-PID)

Heatmap(for_plot_MC, 
        name = "log(cell_count)",
        col = viridis(100)
        )
```


### Heatmap visualization 

```{r}
#Aggregrate across cells with the mean (median is also possible)
cluster_mean_sce <- aggregateAcrossCells(sce_val, ids = sce_val$metacluster_predict,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce)$tumor_cluster_channel)

col_exprs <- colorRamp2(c(0,1,2,3), c("#440154FF", "#31688EFF", "#35B779FF", "#FDE725FF"))

anno <- colData(cluster_mean_sce) %>% as.data.frame %>% select(metacluster_predict,ncells)

# Proportion of grade per cluster
grade <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,grade) %>% group_by(metacluster_predict) %>% table() %>% as.data.frame
grade <- grade %>% group_by(metacluster_predict) %>% mutate(fra = Freq/sum(Freq)) 
grade <- grade %>% select(-Freq) %>% pivot_wider(id_cols = metacluster_predict,names_from = grade,values_from = fra) %>% column_to_rownames("metacluster_predict")

# Proportion of pT stage per cluster
pT <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,pT_simple) %>% group_by(metacluster_predict) %>% table() %>% as.data.frame
pT <- pT %>% group_by(metacluster_predict) %>% mutate(fra = Freq/sum(Freq)) 
pT <- pT %>% select(-Freq) %>% pivot_wider(id_cols = metacluster_predict,names_from = pT_simple,values_from = fra) %>% column_to_rownames("metacluster_predict")

# Proportion of pN stage per cluster
pN <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,pN_simple) %>% group_by(metacluster_predict) %>% table() %>% as.data.frame
pN <- pN %>% group_by(metacluster_predict) %>% mutate(fra = Freq/sum(Freq)) 
pN <- pN %>% select(-Freq) %>% pivot_wider(id_cols = metacluster_predict,names_from = pN_simple,values_from = fra) %>% column_to_rownames("metacluster_predict")

# Number of contributing patients
cluster_PID <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,PID) %>% group_by(metacluster_predict) %>% table() %>% as.data.frame
n_PID <- cluster_PID %>% filter(Freq>0) %>% group_by(metacluster_predict) %>% count(name = "n_PID") %>% column_to_rownames("metacluster_predict")

# Metadata annotation
ha_meta <- HeatmapAnnotation(metacluster_predict = anno_simple(unfactor(anno$metacluster_predict), pch = str_split(unfactor(anno$metacluster_predict),"_",simplify = TRUE)[,2],border=TRUE,col=metadata(sce)$colors$metacluster_combined),
                            n_cells = anno_barplot(anno$ncells, width = unit(10, "mm"),gp = gpar(fill = "#440154FF")),
                            n_PID = anno_barplot(n_PID, width = unit(10, "mm"),gp = gpar(fill = "#440154FF")),
                            #grade = anno_barplot(grade, width = unit(10, "mm"),gp = gpar(fill = metadata(sce_val)$colors$grade)),
                            #pT = anno_barplot(pT, width = unit(10, "mm"),gp = gpar(fill = metadata(sce_val)$colors$pT_simple)),
                            #pN = anno_barplot(pN, width = unit(10, "mm"),gp = gpar(fill = metadata(sce_val)$colors$pN_simple)),
                            #cluster_cat = anno_barplot(cluster_CC, width = unit(10, "mm"),gp = gpar(fill = metadata(sce_val)$colors$cluster_category)),
                            border = TRUE, 
                            annotation_name_rot = 90,
                            gap = unit(1,"mm"),
                            which = "row")

Heatmap(t(assay(cluster_mean_sce, "exprs")),
        column_title = "pred_channels",
        col = col_exprs,
        name = "mean exprs",
        row_title = NULL, 
        show_column_names =  TRUE, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        row_split = anno$metacluster_predict,
        cluster_row_slices = FALSE)+
  ha_meta

mat_scaled <- as.data.frame(scale(t(assay(cluster_mean_sce, "exprs"))))

Heatmap(mat_scaled,
        column_title = "pred_channels",
        #col = col_exprs,
        name = "mean exprs",
        row_title = NULL, 
        show_column_names =  TRUE, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        #row_split = anno$metacluster_predict,
        cluster_row_slices = FALSE)+
  ha_meta
```

```{r}
test <- Cox_df %>% filter(is.na(status_OS) & !is.na(OS_months)) %>% select(12:18)
```

```{r}
library(survival)
library(survminer)

PID_metacluster_predict <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_metacluster_predict <- PID_metacluster_predict %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_metacluster_predict %>% pivot_wider(id_cols = "PID",names_from = "metacluster_predict",values_from = "fra") %>% column_to_rownames("PID")

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_OS <- sce_val$status_OS[match(rownames(Cox_df),sce_val$PID)]
Cox_df$OS_months <- sce_val$OS_months[match(rownames(Cox_df),sce_val$PID)]

Cox_df$age <- sce_val$age[match(rownames(Cox_df),sce_val$PID)]
Cox_df$grade <- factor(sce_val$grade[match(rownames(Cox_df),sce_val$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce_val$pT_simple[match(rownames(Cox_df),sce_val$PID)])
Cox_df$pN_simple <- as.factor(sce_val$pN_simple[match(rownames(Cox_df),sce_val$PID)])
Cox_df$pM_simple <- as.factor(sce_val$pM_simple[match(rownames(Cox_df),sce_val$PID)])

is.na(Cox_df$status_OS)

#Based on proportions
covariates <- Cox_df %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -tumor_10) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+ tumor_10"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratios
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metacluster_predicts")+
ylab("HR for con_prop")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop

## 2. Based on categories (mean division of cluster proportions)
Cox_df_mean <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
Cox_df %>% select(i) %>% mutate(mean = ifelse(Cox_df[,i] > mean(Cox_df[,i]),"B","A")) %>% pull(mean)
}

colnames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_mean <- as.data.frame(Cox_df_mean)

identical(rownames(Cox_df), rownames(Cox_df_mean))

Cox_df_mean <- cbind(Cox_df_mean, Cox_df %>% select(status_OS,OS_months, status_OS, OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_mean %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_mean)

summary(multi_model)

multi_res <- summary(multi_model)

plot_df_mean <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_mean <- ggplot(plot_df_mean, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metacluster_predicts")+
ylab("HR for mean")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_mean

## 3. Based on categories (GMM division of cluster proportions)
Cox_df_GMM <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
GMM_Cox <- Mclust(Cox_df[,i], G = 2)
as.character(GMM_Cox$classification)
}

colnames(Cox_df_GMM) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_GMM) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_GMM <- as.data.frame(Cox_df_GMM,stringsAsFactors=TRUE)

identical(rownames(Cox_df), rownames(Cox_df_GMM))

Cox_df_GMM <- cbind(Cox_df_GMM, Cox_df %>% select(status_OS,OS_months, status_OS, OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_GMM %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_GMM)

summary(multi_model)

summary(Cox_df_GMM)

multi_res <- summary(multi_model)

plot_df_GMM <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_GMM <- ggplot(plot_df_GMM, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metacluster_predicts")+
ylab("HR for GMM")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop/
hr_mean/
hr_GMM
```

```{r}
#Plot survival curves
fit <- survfit(Surv(OS_months, status_OS) ~ tumor_8, data = Cox_df_mean)
print(fit)

p1 <- ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = "Set1",
          log.rank.weights = "n")+
  ggtitle("Mean proportion")

fit <- survfit(Surv(OS_months, status_OS) ~ tumor_6, data = Cox_df_mean)
print(fit)

p2 <- ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = "Set1",
          log.rank.weights = "n")+
  ggtitle("Mean proportion")

arrange_ggsurvplots(list(p1,p2))
```


## 7. Image visualization 

```{r}
sce <- readRDS("/mnt/central_nas/tnbc_volume/TNBC_validation/TNBC_all/data_analysis/04_sce_TNBC_Clus_com.rds")
```

Filter sce for validation cohort

```{r filter sce, message=FALSE}
sce <- sce[,sce$TMANr %in% c("TMA21", "TMA26")]
sce
```

Load images as CytoImageList 

```{r}
images_jana <- loadImages("/mnt/central_nas/tnbc_volume/TNBC_validation/TNBC_Jana/h5_img/")
images_jana

# Set channel names 
channelNames(images_jana) <- rownames(sce)
```

Visualize using cytoviewer 

```{r}
cytoviewer(image = images_jana)
```


## 8. Independent clustering 

```{r}
#sce_val <- readRDS("/mnt/central_nas/tnbc_volume/TNBC_validation/TNBC_all/data_analysis/04_sce_TNBC_Clus_com_tumor_predicted.rds")
```

```{r}
rowData(sce_val)$tumor_cluster_sub <- rowData(sce_val)$clean_target %in% c("CK5","CK7","KRT14","CK8_18","CD15","HLADR","Vimentin","pH3","Ki67","EGFR")

rowData(sce_val)$tumor_cluster_sub_1 <- rowData(sce_val)$clean_target %in% c("CK5","CK7","KRT14","CK8_18","CD15","HLADR","Vimentin","Ki67","EGFR")
```

```{r}
## Run clustering
library(Rphenoannoy)
set.seed(22)

mat <- t(assay(sce_val, "exprs")[rowData(sce_val)$tumor_cluster_channel,])

#k=30
out <- Rphenoannoy(mat, k = 30)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_30 <- clusters

unique(sce_val$cluster_30)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=50
out <- Rphenoannoy(mat, k = 50)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_50 <- clusters

unique(sce_val$cluster_50)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=70
out <- Rphenoannoy(mat, k = 70)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_70 <- clusters

unique(sce_val$cluster_70)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=90
out <- Rphenoannoy(mat, k = 90)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_90 <- clusters

unique(sce_val$cluster_90)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=110
out <- Rphenoannoy(mat, k = 110)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_110 <- clusters

unique(sce_val$cluster_110)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=130
out <- Rphenoannoy(mat, k = 130)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_130 <- clusters

unique(sce_val$cluster_130)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()
```

```{r}
## Run clustering
library(Rphenoannoy)
set.seed(22)

mat <- t(assay(sce_val, "exprs")[rowData(sce_val)$tumor_cluster_sub,])

#k=30
out <- Rphenoannoy(mat, k = 30)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_1_30 <- clusters

unique(sce_val$cluster_1_30)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=50
out <- Rphenoannoy(mat, k = 50)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_1_50 <- clusters

unique(sce_val$cluster_1_50)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=70
out <- Rphenoannoy(mat, k = 70)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_1_70 <- clusters

unique(sce_val$cluster_1_70)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=90
out <- Rphenoannoy(mat, k = 90)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_1_90 <- clusters

unique(sce_val$cluster_1_90)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=110
out <- Rphenoannoy(mat, k = 110)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_1_110 <- clusters

unique(sce_val$cluster_1_110)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=130
out <- Rphenoannoy(mat, k = 130)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_1_130 <- clusters

unique(sce_val$cluster_1_130)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()
```

```{r}
## Run clustering
library(Rphenoannoy)
set.seed(22)

mat <- t(assay(sce_val, "exprs")[rowData(sce_val)$tumor_cluster_sub_1,])

#k=30
out <- Rphenoannoy(mat, k = 30)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_2_30 <- clusters

unique(sce_val$cluster_2_30)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=50
out <- Rphenoannoy(mat, k = 50)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_2_50 <- clusters

unique(sce_val$cluster_2_50)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=70
out <- Rphenoannoy(mat, k = 70)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_2_70 <- clusters

unique(sce_val$cluster_2_70)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=90
out <- Rphenoannoy(mat, k = 90)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_2_90 <- clusters

unique(sce_val$cluster_2_90)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=110
out <- Rphenoannoy(mat, k = 110)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_2_110 <- clusters

unique(sce_val$cluster_2_110)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=130
out <- Rphenoannoy(mat, k = 130)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_2_130 <- clusters

unique(sce_val$cluster_2_130)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()
```

### Cluster stability testing and comparison

```{r}
#Pairwise rand index 
#Agreement between two clustering approaches - ARI > 0.5 = "good" similarity
pairwiseRand(sce_val$cluster_30,sce_val$cluster_50, mode = "index")
pairwiseRand(sce_val$cluster_50,sce_val$cluster_70, mode = "index")
pairwiseRand(sce_val$cluster_70,sce_val$cluster_90, mode = "index")
pairwiseRand(sce_val$cluster_90,sce_val$cluster_110, mode = "index")
pairwiseRand(sce_val$cluster_110,sce_val$cluster_130, mode = "index")
```

```{r clustree, message = FALSE, warning=FALSE}
sce_val <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

#Over different resolution parameters - Silhouette width [-1,1,max], Purity[0,1,max], Root-mean-squared difference [min]
my_clusters <- colnames(colData(sce_val))[str_detect(colnames(colData(sce_val)),"cluster_[:digit:]")]
my_clusters <- my_clusters[!str_detect(my_clusters, "_1_")]
my_clusters <- my_clusters[!str_detect(my_clusters, "_2_")]

df <- foreach(i = seq_along(my_clusters),.combine = rbind) %do% {
num_clus <- length(unique(colData(sce_val)[,my_clusters[i]]))
sil <- approxSilhouette(t(assay(sce_val, "exprs")), clusters=colData(sce_val)[,my_clusters[i]])
rmsd <- clusterRMSD(t(assay(sce_val, "exprs")), clusters=colData(sce_val)[,my_clusters[i]])
data.frame(num_clus = num_clus,
           k = as.numeric(str_split(my_clusters[i],"_",simplify = TRUE)[,2]), 
           sil = mean(sil$width), 
           rmsd = sum(rmsd),
           type = "cluster_full")
}

my_clusters <- colnames(colData(sce_val))[str_detect(colnames(colData(sce_val)),"cluster_1_[:digit:]")]

df_1 <- foreach(i = seq_along(my_clusters),.combine = rbind) %do% {
num_clus <- length(unique(colData(sce_val)[,my_clusters[i]]))
sil <- approxSilhouette(t(assay(sce_val, "exprs")), clusters=colData(sce_val)[,my_clusters[i]])
rmsd <- clusterRMSD(t(assay(sce_val, "exprs")), clusters=colData(sce_val)[,my_clusters[i]])
data.frame(num_clus = num_clus,
           k = as.numeric(str_split(my_clusters[i],"_",simplify = TRUE)[,3]), 
           sil = mean(sil$width), 
           rmsd = sum(rmsd),
           type = "cluster_sub")
}

my_clusters <- colnames(colData(sce_val))[str_detect(colnames(colData(sce_val)),"cluster_2_[:digit:]")]

df_2 <- foreach(i = seq_along(my_clusters),.combine = rbind) %do% {
num_clus <- length(unique(colData(sce_val)[,my_clusters[i]]))
sil <- approxSilhouette(t(assay(sce_val, "exprs")), clusters=colData(sce_val)[,my_clusters[i]])
rmsd <- clusterRMSD(t(assay(sce_val, "exprs")), clusters=colData(sce_val)[,my_clusters[i]])
data.frame(num_clus = num_clus,
           k = as.numeric(str_split(my_clusters[i],"_",simplify = TRUE)[,3]), 
           sil = mean(sil$width), 
           rmsd = sum(rmsd),
           type = "cluster_sub_1")
}

df_out <- rbind(df, df_1, df_2)

p1 <- ggplot(df_out, aes(x=k, y=num_clus, color = type))+
  geom_point(aes(k, num_clus), size = 3)+
  geom_line(aes(k, num_clus))+
  theme_classic()+
  scale_color_brewer(palette = "Set1")+
  guides(color = "none")

p2 <- ggplot(df_out, aes(x=k, y=rmsd, color = type))+
  geom_point(aes(k, rmsd), size = 3)+
  geom_line(aes(k, rmsd))+
  theme_classic()+
  scale_color_brewer(palette = "Set1")+
  guides(color = "none")


p3 <- ggplot(df_out, aes(x=k, y=sil, color = type))+
  geom_point(aes(k, sil), size = 3)+
  geom_line(aes(k, sil))+
  theme_classic()+
  scale_color_brewer(palette = "Set1")
  
p1+p2+p3 
```


```{r}
df_out <- rbind(df_1)

p1 <- ggplot(df_out, aes(x=k, y=num_clus))+
  geom_point(aes(k, num_clus, col = num_clus), size = 3)+
  geom_line(aes(k, num_clus, col = num_clus))+
  theme_classic()+
  guides(color = "none")+
  scale_color_continuous(type = "viridis")


p2 <- ggplot(df_out, aes(x=k, y=rmsd))+
  geom_point(aes(k, rmsd, col = rmsd), size = 3)+
  geom_line(aes(k, rmsd, col = rmsd))+
  theme_classic()+
  guides(color = "none")+
  scale_color_continuous(type = "viridis")


p3 <- ggplot(df_out, aes(x=k, y=sil))+
  geom_point(aes(k, sil, col = sil), size = 3)+
  geom_line(aes(k, sil, col = sil))+
  theme_classic()+
  guides(color = "none")+
  scale_color_continuous(type = "viridis")

  
p1+p2+p3 
```


```{r}
#Heatmap body colors
col_exprs <- colorRamp2(c(0,1,2,3), c("#440154FF", "#31688EFF", "#35B779FF", "#FDE725FF"))

### 1. Mean exprs counts
#Aggregrate across cells with the mean

cluster_mean_sce_val <- aggregateAcrossCells(sce_val, ids = sce_val$cluster_1_90,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce_val)$tumor_cluster_channel)

cluster_mean_sce_val_1 <- aggregateAcrossCells(sce_val, ids = sce_val$cluster_130,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce_val)$tumor_cluster_channel)

h_110 <- Heatmap(t(assay(cluster_mean_sce_val, "exprs")),
        column_title = "1. mean exprs",
        col = col_exprs,
        name= "mean exprs",
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")
  
h_130 <- Heatmap(t(assay(cluster_mean_sce_val_1, "exprs")),
        column_title = "1. mean exprs",
        col = col_exprs,
        name= "mean exprs",
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")

h_110
h_130

h_110+
h_130

scale(table(sce_val$cluster_110,sce_val$metacluster_predict))

Heatmap(scale(table(sce_val$cluster_110,sce_val$metacluster_predict)), clustering_method_rows = "ward.D2", clustering_method_columns = "ward.D2")

Heatmap(log2(table(sce_val$cluster_110,sce_val$metacluster_predict)+1), 
        col = viridis(100))
```

### Define tumor metaclusters 

Based on manual assignment and accuracy testing 

```{r}
library(SingleCellExperiment)
library(caret)

# Extract cluster and metacluster data
clusters <- sce_val$cluster_1_90
metacluster_old <- sce_val$metacluster_predict

# Unique clusters and metaclusters
unique_clusters <- unique(clusters)
unique_metaclusters <- unique(metacluster_old)

# Initialize a dataframe to store accuracies
accuracy_matrix <- as.data.frame(matrix(0, nrow = length(unique_clusters), ncol = length(unique_metaclusters)))
rownames(accuracy_matrix) <- unique_clusters
colnames(accuracy_matrix) <- unique_metaclusters

# Calculate accuracy for each cluster-to-metacluster assignment
for (i in unfactor(unique_clusters)) {
  for (j in unfactor(unique_metaclusters)) {
    
    cluster_indices <- which(clusters == i)
    assigned_metaclusters <- metacluster_old[cluster_indices]
    
    confusion_stats <- confusionMatrix(
      assigned_metaclusters, 
      factor(rep(j, length(assigned_metaclusters)),levels = levels(assigned_metaclusters)))
    
    accuracy_matrix[i, j] <- confusion_stats$overall['Accuracy']
  }
}

# Assign clusters to metaclusters based on highest accuracy

best_assignments <- apply(accuracy_matrix, 1, function(row) names(row)[which.max(row)])

best_assignments_df <- data.frame(new = unname(best_assignments), old = names(best_assignments))

# Manual annoation (optional)
best_assignments_df$new[23] <- "tumor_8"
#best_assignments_df$new[32] <- "tumor_4"
```

```{r}
# Update the SingleCellExperiment object with new metacluster assignments
sce_val$metacluster_new <- best_assignments_df$new[match(sce_val$cluster_1_90, best_assignments_df$old)]
sce_val$metacluster_new <- factor(sce_val$metacluster_new, levels = levels(sce_val$metacluster_predict))
```

### Comparison

#### Confusion matrix

```{r}
library(tidyverse)

cm <- confusionMatrix(sce_val$metacluster_predict, sce_val$metacluster_new)

data.frame(cm$byClass) %>%
  mutate(class = sub("Class: ", "", rownames(cm$byClass))) %>%
  ggplot() + 
  geom_point(aes(1-Specificity, Sensitivity, 
                 size = Detection.Rate,
                 fill = class),
             shape = 21) + 
  scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
  theme_classic(base_size = 15) + 
  ylab("Sensitivity (TPR)") +
  xlab("1 - Specificity (FPR)")+
  ggtitle(paste0("Accuracy: ",round(cm$overall[1],3)," [",round(cm$overall[3],3)," - ",round(cm$overall[4],3),"]"))
```

#### Mean expression profile

Compare mean expression profiles between discovery and validation cohort

```{r}
discovery_exprs <- aggregateAcrossCells(sce_val, ids = sce_val$metacluster_predict,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce_val)$tumor_cluster_sub)

validation_exprs <- aggregateAcrossCells(sce_val, ids = sce_val$metacluster_new,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce_val)$tumor_cluster_sub)

val_exprs <- assay(validation_exprs, "exprs")

dis_exprs <- assay(discovery_exprs, "exprs")[,colnames(assay(discovery_exprs, "exprs")) %in% 
colnames(assay(validation_exprs, "exprs"))]

corrplot(cor(dis_exprs,val_exprs), 
         method="color", 
         col=brewer.pal(n=8, name="RdBu"),  
         type="upper", 
         order="hclust",
         hclust.method = "ward.D2", 
         addCoef.col = "black", 
         addCoefasPercent = F,
         tl.col="black", 
         tl.srt=40,
         diag=TRUE)
```

#### Adjusted Rand index

```{r}
pairwiseRand(sce_val$metacluster_new, sce_val$metacluster_predict, mode = "index")
```

#### Fraction correlation 

```{r}
#sce <- sce[,sce$analysis_cat == "tumor"]

validation <- colData(sce_val) %>% as.data.frame %>% select(metacluster_new) %>% count(metacluster_new) %>% mutate(fra = n/sum(n)) 

discovery <- colData(sce) %>% as.data.frame %>% select(metacluster_combined) %>% count(metacluster_combined) %>% mutate(fra = n/sum(n)) %>% filter(metacluster_combined %in% validation$metacluster_new)

discovery$fra_valid <- validation$fra[match(discovery$metacluster_combined, validation$metacluster_new)]

cor(discovery$fra, discovery$fra_valid, method = "spearman")

spearman_test <- cor.test(discovery$fra, discovery$fra_valid, method = "spearman")

ggplot(discovery, aes(x = fra, y = fra_valid))+
  geom_smooth(method='lm', formula= y~x, se = TRUE, color = "darkgrey")+
  geom_point(aes(color = metacluster_combined), size = 3)+
  scale_color_manual(values=metadata(sce)$colors$metacluster_combined)+
  ylab("Independent clustered MC fraction (Fischer et al., 2023)")+
  xlab("MC fraction (Discovery)")+
  theme_classic()+
  ggtitle(paste("Spearman rho = ",round(spearman_test$estimate, digits = 2)))
```

#### Rich heatmap

```{r}
### 1. Heatmap body ###

#Aggregrate across cells with the mean (median is also possible)
cluster_mean_sce_val <- aggregateAcrossCells(sce_val, ids = sce_val$cluster_1_90,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce_val)$tumor_cluster_sub)

# Heatmap body colors 
col_exprs <- colorRamp2(c(0,1.25,2.5,3.75), c("#440154FF", "#31688EFF", "#35B779FF", "#FDE725FF"))


### 2. Heatmap annotation ###
###2.1 Metacluster 
cluster_mean_sce_val$metacluster_new

###2.2 Metadata features

#Number of cells per cluster 
n_cells <- colData(cluster_mean_sce_val) %>% as.data.frame %>% select(cluster_1_90, ncells)

# Proportion of grade per cluster
grade <- colData(sce_val) %>% as.data.frame() %>% select(cluster_1_90,grade) %>% group_by(cluster_1_90) %>% table() %>% as.data.frame
grade <- grade %>% group_by(cluster_1_90) %>% mutate(fra = Freq/sum(Freq)) 
grade <- grade %>% select(-Freq) %>% pivot_wider(id_cols = cluster_1_90,names_from = grade,values_from = fra) %>% column_to_rownames("cluster_1_90")

# Proportion of pT stage per cluster
pT <- colData(sce_val) %>% as.data.frame() %>% select(cluster_1_90,pT_simple) %>% group_by(cluster_1_90) %>% table() %>% as.data.frame
pT <- pT %>% group_by(cluster_1_90) %>% mutate(fra = Freq/sum(Freq)) 
pT <- pT %>% select(-Freq) %>% pivot_wider(id_cols = cluster_1_90,names_from = pT_simple,values_from = fra) %>% column_to_rownames("cluster_1_90")

# Proportion of pN stage per cluster
pN <- colData(sce_val) %>% as.data.frame() %>% select(cluster_1_90,pN_simple) %>% group_by(cluster_1_90) %>% table() %>% as.data.frame
pN <- pN %>% group_by(cluster_1_90) %>% mutate(fra = Freq/sum(Freq)) 
pN <- pN %>% select(-Freq) %>% pivot_wider(id_cols = cluster_1_90,names_from = pN_simple,values_from = fra) %>% column_to_rownames("cluster_1_90")

# Number of contributing patients
cluster_PID <- colData(sce_val) %>% as.data.frame() %>% select(cluster_1_90,PID) %>% group_by(cluster_1_90) %>% table() %>% as.data.frame
n_PID <- cluster_PID %>% filter(Freq>0) %>% group_by(cluster_1_90) %>% count(name = "n_PID") %>% column_to_rownames("cluster_1_90")

# Cluster categories contributing to clusters
cluster_CC <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,cluster_category) %>% group_by(metacluster_predict) %>% table() %>% as.data.frame
cluster_CC <- cluster_CC %>% group_by(metacluster_predict) %>% mutate(fra = Freq/sum(Freq)) 
cluster_CC <- cluster_CC %>% select(-Freq) %>% pivot_wider(id_cols = metacluster_predict,names_from = cluster_category,values_from = fra) %>% column_to_rownames("metacluster_predict")

# Metadata annotation
metadata(sce_val)$colors$metacluster_combined <- metadata(sce)$colors$metacluster_combined
col_mc <- metadata(sce_val)$colors$metacluster_combined

ha_meta <- HeatmapAnnotation(#cluster_1_90 = anno_simple(unfactor(cluster_mean_sce_val$cluster_1_90), pch = unfactor(cluster_mean_sce_val$cluster_1_90),width = unit(8, "mm"), border=TRUE),
                            metacluster = anno_simple(unfactor(cluster_mean_sce_val$metacluster_new),width = unit(8, "mm"), pch = str_split(unfactor(cluster_mean_sce_val$metacluster_new),"_",simplify = TRUE)[,2], col =  col_mc, border=TRUE),
                            n_cells = anno_barplot(n_cells$ncells, width = unit(12, "mm"),gp = gpar(fill = "#440154FF")),
                            n_PID = anno_barplot(n_PID, width = unit(12, "mm"),gp = gpar(fill = "#440154FF")),
                            #grade = anno_barplot(grade, width = unit(15, "mm"),gp = gpar(fill = metadata(sce_val)$colors$grade)),
                            #pT = anno_barplot(pT, width = unit(15, "mm"),gp = gpar(fill = metadata(sce_val)$colors$pT_simple)),
                            #pN = anno_barplot(pN, width = unit(15, "mm"),gp = gpar(fill = metadata(sce_val)$colors$pN_simple)),
                            border = TRUE, 
                            annotation_name_rot = 90,
                            gap = unit(2,"mm"),
                            which = "row")
                            
### 3. Plot heatmap ###

h_meta <- Heatmap(t(assay(cluster_mean_sce_val, "exprs")),
        column_title = "cluster_channels",
        col = col_exprs,
        name = "mean exprs",
        row_title = NULL, 
        show_column_names =  TRUE, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        row_split = cluster_mean_sce_val$metacluster_new,
        cluster_row_slices = FALSE)+
  ha_meta

draw(h_meta)
```


## 9. Focus on MC8 frequency / patches / dominant PID 

```{r, message=FALSE}
sce <- readRDS("/mnt/central_nas/tnbc_volume/TNBC_validation/TNBC_all/data_analysis/04_sce_TNBC_Clus_com.rds")
```

Filter sce for validation cohort

```{r filter sce, message=FALSE}
sce <- sce[,sce$TMANr %in% c("TMA21", "TMA26")]
sce
```

Add predicted metacluster labels 

```{r}
# Read sce object (tumor cells from Janas data with predicted metacluster)
sce_val_tumor <- readRDS("/mnt/central_nas/tnbc_volume/TNBC_validation/TNBC_all/data_analysis/04_sce_TNBC_Clus_com_tumor_predicted.rds")

sce$metacluster_predict <- sce_val_tumor$metacluster_predict[match(sce$cell_id, sce_val_tumor$cell_id)]

sce$metacluster_predict <- unname(unfactor(sce$metacluster_predict))
sce$metacluster_predict[is.na(sce$metacluster_predict)] <- "Unknown"
```

Build knn interaction graph 

```{r}
library(imcRtools)

# Build spatial knn graph
sce <- buildSpatialGraph(sce, img_id = "sample_id", type = "knn", k = 20, 
                         coords = c("Pos_X",  "Pos_Y"),
                         #max_dist = 30,
                         BPPARAM = MulticoreParam())

colPairNames(sce) #now includes knn_interaction_graph
```

Patch detection

```{r}
## Patch detection
sce <- patchDetection(sce,
               patch_cells = sce$metacluster_predict == "tumor_8",
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = "patch_MC8",
               expand_by = 0, 
               img_id = "sample_id", 
               BPPARAM = MulticoreParam(workers = 10))
```

Frequency analysis 

```{r}
# Colors 
colors_sce <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")
```

```{r}
patch_MC8_PID <- colData(sce) %>% as.data.frame() %>% filter(!is.na(patch_MC8)) %>% pull(PID) %>% unique()

cells_MC8_PID <- colData(sce) %>% as.data.frame() %>% select(metacluster_predict,PID) %>% group_by(PID) %>% table() %>% as.data.frame

sce$patch_MC8_classification <- ifelse(sce$PID %in% patch_MC8_PID,"patch_MC8","no_patch_MC8")

PID_patch <- colData(sce) %>% as.data.frame() %>% select(metacluster_predict,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_patch <- PID_patch %>% group_by(PID) %>% filter(PID %in% patch_MC8_PID) %>% filter(str_detect(metacluster_predict,"tumor")) %>% mutate(fra = Freq/sum(Freq)) 
```

```{r}
# most abundant phenotype in patients with MC8 patches 
PID_patch_abundant <- PID_patch %>% #filter(metacluster_predict != "tumor_8") %>% 
  mutate(max = max(fra)) %>% filter(fra == max) %>% ungroup() %>% count(metacluster_predict) %>% mutate(fra = n/sum(n), category = "cat") %>% arrange(fra)

PID_patch_abundant$metacluster_predict <- factor(PID_patch_abundant$metacluster_predict, levels = unfactor(PID_patch_abundant$metacluster_predict))

ggplot(PID_patch_abundant) +
  geom_tile(color = "black",aes(category, n, fill = metacluster_predict), position = "stack")+
  scale_fill_manual(values=metadata(colors_sce)$colors$metacluster_combined) + 
  theme_classic(base_size = 15)+
  ylab("Density")+
  xlab("PID")+
  theme(axis.text.x = element_blank())
```

```{r}
PID_dom_MC8 <- PID_patch %>% mutate(max = max(fra)) %>% filter(fra == max) %>% ungroup() %>% filter(metacluster_predict == "tumor_8") %>% pull(PID)

PID_overall <- colData(sce) %>% as.data.frame() %>% select(metacluster_predict,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_MC8_overall <- PID_overall %>% group_by(PID) %>% filter(metacluster_predict == "tumor_8" & Freq > 5) %>% mutate(patch = ifelse(PID %in% patch_MC8_PID, TRUE, FALSE)) %>% mutate(dominated = ifelse(PID %in% PID_dom_MC8, TRUE, FALSE)) %>% mutate(PID_category = ifelse(patch && dominated, "dominated", ifelse(patch, "patch", "cells")))                                                                                    
PID_MC8_overall_plot <- PID_MC8_overall %>% group_by(PID_category) %>% count() %>% ungroup() %>% mutate(fra = n/sum(n)) %>% mutate(category = "MC8")


PID_MC8_overall_plot$PID_category <- factor(PID_MC8_overall_plot$PID_category, levels = c("cells","patch","dominated"))

ggplot(PID_MC8_overall_plot) +
  geom_tile(color = "black",aes(category, n, fill = PID_category), position = "stack")+
  scale_fill_brewer(palette = "Blues")+
  theme_classic(base_size = 15)+
  ylab("Number of patients")+
  theme(axis.title.x = element_blank())
```

Interaction testing 

```{r}
sce_tumor <- sce[,sce$metacluster_predict != "Unknown"]

sce_tumor$metacluster_predict <- unfactor(sce_tumor$metacluster_predict)

# For PID with at least 5 MC8 cells 
PID_overall <- colData(sce_tumor) %>% as.data.frame() %>% select(metacluster_predict,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_MC8_overall <- PID_overall %>% group_by(PID) %>% filter(metacluster_predict == "tumor_8" & Freq > 5)

sce_tumor_MC8 <- sce_tumor[,sce_tumor$PID %in% PID_MC8_overall$PID]

interaction_tumor <- testInteractions(sce_tumor_MC8, 
                  group_by = "sample_id", 
                  label = "metacluster_predict", 
                  colPairName = "neighborhood", 
                  BPPARAM = MulticoreParam())
```

```{r}
interaction_tumor_plot <- interaction_tumor %>% as_tibble() %>% filter(from_label %in% c("tumor_8")) %>% filter(to_label != "tumor_8") %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE))

ggplot(interaction_tumor_plot) +
        geom_tile(aes(reorder(to_label,sum_sigval), from_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  theme_classic()
```



## Save plots as pdf

```{r save_plots, include=FALSE}
pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_varimp.pdf",height = 5, width = 6)
plot(varImp(rffit))
dev.off()


pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_Accuracy_CV.pdf",height = 5, width = 6)
ggplot(rffit) + 
  geom_errorbar(data = rffit$results,
                aes(ymin = Accuracy - AccuracySD,
                    ymax = Accuracy + AccuracySD),
                width = 0.4) +
    theme_classic(base_size = 15)
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_test_TPR_FPR.pdf",height = 6, width = 7)
data.frame(cm$byClass) %>%
  mutate(class = sub("Class: ", "", rownames(cm$byClass))) %>%
  ggplot() + 
  geom_point(aes(1-Specificity, Sensitivity, 
                 size = Detection.Rate,
                 fill = class),
             shape = 21) + 
  scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
  theme_classic(base_size = 15) + 
  ylab("Sensitivity (TPR)") +
  xlab("1 - Specificity (FPR)")+
  ggtitle(paste0("Accuracy: ",round(cm$overall[1],3)," [",round(cm$overall[3],3)," - ",round(cm$overall[4],3),"]"))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_validation_maxprob.pdf",height = 6, width = 7)
tibble(max_prob = rowMax(as.matrix(cell_prob)),
       type = cell_class) %>%
    ggplot() +
        geom_density_ridges(aes(x = max_prob, y = cell_class, fill = cell_class)) +
        scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
        theme_classic(base_size = 15) +
        xlab("Maximum probability") +
        ylab("Metacluster") + 
        xlim(c(0,1.2))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_validation_heatmap.pdf",height = 6, width = 8)
Heatmap(t(assay(cluster_mean_sce, "exprs")),
        column_title = "pred_channels",
        col = col_exprs,
        name = "mean exprs",
        row_title = NULL, 
        show_column_names =  TRUE, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        row_split = anno$metacluster_predict,
        cluster_row_slices = FALSE)+
  ha_meta
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_comparison_Jana_metacluster_fra.pdf",height = 4, width = 7)
ggplot(discovery, aes(x = fra, y = fra_valid))+
  geom_smooth(method='lm', formula= y~x, se = TRUE, color = "darkgrey")+
  geom_point(aes(color = metacluster_combined), size = 3)+
  scale_color_manual(values=metadata(sce)$colors$metacluster_combined)+
  ylab("Predicted MC fraction (Fischer et al., 2023)")+
  xlab("MC fraction (Discovery)")+
  theme_classic()+
  ggtitle(paste("Spearman rho = ",round(spearman_test$estimate, digits = 2)))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_comparison_Jana_meanexpressionprofile.pdf",height = 5, width = 9)
corrplot(cor(assay(discovery_exprs, "exprs"),assay(validation_exprs, "exprs")), method="color", col=brewer.pal(n=8, name="RdBu"),  
         type="upper", order="hclust",hclust.method = "ward.D2", 
         addCoef.col = "black", addCoefasPercent = F,
         tl.col="black", tl.srt=40,
         diag=TRUE)
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_MC8patch_abundantMC.pdf",width = 8,height = 2.5,onefile = FALSE)
ggplot(PID_patch_abundant) +
  geom_tile(color = "black",aes(n,category, fill = metacluster_predict), position = "stack")+
  scale_fill_manual(values=metadata(colors_sce)$colors$metacluster_combined) + 
  theme_classic(base_size = 15)+
  ylab("Density")+
  xlab("PID")+
  theme(axis.text.x = element_blank())
dev.off()


pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_MC8_frequency.pdf",width = 8,height = 2.5,onefile = FALSE)
ggplot(PID_MC8_overall_plot) +
  geom_tile(color = "black",aes(n,category, fill = PID_category), position = "stack")+
  scale_fill_brewer(palette = "Blues")+
  theme_classic(base_size = 15)+
  ylab("Number of patients")+
  theme(axis.title.x = element_blank())
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_MC8_interaction.pdf",width = 8,height = 2.5,onefile = FALSE)
ggplot(interaction_tumor_plot) +
        geom_tile(aes(reorder(to_label,sum_sigval), from_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  theme_classic()
dev.off()


### NEW 
pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_varimp_all_sub.pdf",height = 4, width = 7)
ggplot(out_comb, aes(x = reorder(marker, desc(Overall)), y = Overall, fill = category))+
  facet_wrap(~category, scales = "free_x")+
  geom_col()+
  theme_classic()+
  scale_fill_brewer(palette = "Paired")+
  coord_flip()+
  ylab("Scaled feature importance")+
  xlab("Markers")
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_ROC_plot.pdf",height = 4, width = 7)
ggplot(df_out) + 
  facet_wrap(~category) +
  geom_point(aes(1-Specificity, Sensitivity, 
                 size = Detection.Rate,
                 fill = class),
             shape = 21) + 
  scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
  theme_classic(base_size = 15) + 
  ylab("Sensitivity (TPR)") +
  xlab("1 - Specificity (FPR)")+
  ggtitle(paste0("Accuracy (all): ",round(cm$overall[1],3)," [",round(cm$overall[3],3)," - ",round(cm$overall[4],3),"]", " Accuracy (sub): ",round(cm_sub$overall[1],3)," [",round(cm_sub$overall[3],3)," - ",round(cm_sub$overall[4],3),"]"))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_validation_heatmap.pdf",height = 4, width = 5)
Heatmap(t(assay(cluster_mean_sce, "exprs")),
        column_title = "pred_channels",
        col = col_exprs,
        name = "mean exprs",
        row_title = NULL, 
        show_column_names =  TRUE, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        row_split = anno$metacluster_predict,
        cluster_row_slices = FALSE)+
  ha_meta
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_independentclus_stability.pdf",height = 3, width = 7)
p1+p2+p3 
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_independentclus_ROC_plot.pdf",height = 4, width = 5)
data.frame(cm$byClass) %>%
  mutate(class = sub("Class: ", "", rownames(cm$byClass))) %>%
  ggplot() + 
  geom_point(aes(1-Specificity, Sensitivity, 
                 size = Detection.Rate,
                 fill = class),
             shape = 21) + 
  scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
  theme_classic(base_size = 15) + 
  ylab("Sensitivity (TPR)") +
  xlab("1 - Specificity (FPR)")+
  ggtitle(paste0("Accuracy: ",round(cm$overall[1],3)," [",round(cm$overall[3],3)," - ",round(cm$overall[4],3),"]"))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_comparison_Jana_independentclus_meanexpressionprofile.pdf",height = 5, width = 8)
corrplot(cor(dis_exprs,val_exprs), 
         method="color", 
         col=brewer.pal(n=8, name="RdBu"),  
         type="upper", 
         order="hclust",
         hclust.method = "ward.D2", 
         addCoef.col = "black", 
         addCoefasPercent = F,
         tl.col="black", 
         tl.srt=40,
         diag=TRUE)
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_comparison_Jana_independentclus_metacluster_fra.pdf",height = 3, width = 7)
ggplot(discovery, aes(x = fra, y = fra_valid))+
  geom_smooth(method='lm', formula= y~x, se = TRUE, color = "darkgrey")+
  geom_point(aes(color = metacluster_combined), size = 3)+
  scale_color_manual(values=metadata(sce)$colors$metacluster_combined)+
  ylab("Independent clustered MC fraction (Fischer et al., 2023)")+
  xlab("MC fraction (Discovery)")+
  theme_classic()+
  ggtitle(paste("Spearman rho = ",round(spearman_test$estimate, digits = 2)))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/09_prediction/TNBC_Jana_randomforest_independentclus_validation_heatmap.pdf",height = 5, width = 5)
draw(h_meta)
dev.off()
````




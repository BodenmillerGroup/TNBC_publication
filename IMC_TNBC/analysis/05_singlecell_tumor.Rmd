---
title: "06_singlecell_tumor"
author: "Lasse Meyer"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Software requirements

```{r lib, message=FALSE,warning=FALSE}
#Data containers
library(SpatialExperiment)
library(SingleCellExperiment)

#Data processing
library(scuttle)
library(scater)
library(scran)
library(imcRtools)

#Data visualization
library(cytomapper)
library(dittoSeq)
library(pheatmap)
library(cowplot)
library(ComplexHeatmap)
library(circlize)

#Utilities
library(tidyverse)
library(openxlsx)
library(stringr)
library(patchwork)
library(parallel)
library(BiocParallel)
library(BiocNeighbors)
library(BiocSingular)
library(tiff)
library(ggrepel)
library(EBImage)
library(viridis)
library(mclust)
library(Rphenograph)
library(igraph)
library(RColorBrewer)
library(foreach)
library(clValid)
library(bluster)
library(psych)
library(corrplot)
library(psych)

#Batch correction
library(batchelor)
```

# Single-cell analysis - Pipeline 2 - TNBC tumor phenotypes

Here, we will perform the second single cell analysis steps, including phenotyping tumor cells.

## Read in data
First, we will read in the `SingleCellExperiment` object containing the cleaned, spillover- and (batch-corrected) single-cell data. 

```{r read-data-batch-correction, message=FALSE}
sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/04_sce_TNBC_Clus.rds")
```

## Filter sce for tumor cells
Here, we will filter for tumor cells based on the cluster category and GMM approach.

```{r filter sce, message=FALSE}
#based on cluster categories (n=492712)
sce <- sce[,colData(sce)$analysis_cat == "tumor"]
sce
```

# 1. Clustering

## Define markers for clustering

```{r tumor_markers, message = FALSE, warning = FALSE}
cluster_channel = c("CK5","CK8_18","CD15","KRT14","cMYC","HER2","ER","PR","p53","AR","GATA3","EGFR","p_mTOR","CK7","Vimentin","Ki67","HLADR")

#cell_state_channel = c()

other_immune_channel = c("Bcl2","CD44","panCK","Ecad","SMA","Fibronectin","CD68","CD3","CD20","CD11c","CD45","CD20","CD8a","CD4","CD31_vWF", "CAIX", "S6","c_Cas3_PARP", "pH3", "H3K27me3")

#Add to sce
rowData(sce)$cluster_channel <- (rowData(sce)$clean_target %in% cluster_channel)
#rowData(sce)$cell_state_channel <- (rowData(sce)$clean_target %in% cell_state_channel)
rowData(sce)$other_immune_channel <- (rowData(sce)$clean_target %in% other_immune_channel)
```

## Run clustering
Next, we will run Rphenoannoy (Jaccard-based weights, Louvain clustering as community detection algorithm) clustering with different resolution parameters. 

```{r overcluster, message=FALSE}
library(Rphenoannoy)
set.seed(22)

mat <- t(assay(sce, "exprs")[rowData(sce)$cluster_channel,])

#k=30
out <- Rphenoannoy(mat, k = 30)

clusters <- factor(membership(out[[2]]))

sce$cluster_30 <- clusters

unique(sce$cluster_30)

#Save SCEs after clustering
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor.rds")

gc()

#k=50
out <- Rphenoannoy(mat, k = 50)

clusters <- factor(membership(out[[2]]))

sce$cluster_50 <- clusters

unique(sce$cluster_50)

#Save SCEs after clustering
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor.rds")

gc()

#k=70
out <- Rphenoannoy(mat, k = 70)

clusters <- factor(membership(out[[2]]))

sce$cluster_70 <- clusters

unique(sce$cluster_70)

#Save SCEs after clustering
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor.rds")

gc()

#k=90
out <- Rphenoannoy(mat, k = 90)

clusters <- factor(membership(out[[2]]))

sce$cluster_90 <- clusters

unique(sce$cluster_90)

#Save SCEs after clustering
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor.rds")

gc()

#k=110
out <- Rphenoannoy(mat, k = 110)

clusters <- factor(membership(out[[2]]))

sce$cluster_110 <- clusters

unique(sce$cluster_110)

#Save SCEs after clustering
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor.rds")

gc()

#k=130
out <- Rphenoannoy(mat, k = 130)

clusters <- factor(membership(out[[2]]))

sce$cluster_130 <- clusters

unique(sce$cluster_130)

#Save SCEs after clustering
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor.rds")

gc()
```

## Cluster stability testing and comparison

```{r clustree, message = FALSE, warning=FALSE}
#Read sce after clustering and GMM
#sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor.rds")

#Pairwise rand index 
#Agreement between two clustering approaches - ARI > 0.5 = "good" similarity
pairwiseRand(sce$cluster_30,sce$cluster_50, mode = "index")
pairwiseRand(sce$cluster_50,sce$cluster_70, mode = "index")
pairwiseRand(sce$cluster_70,sce$cluster_90, mode = "index")
pairwiseRand(sce$cluster_90,sce$cluster_110, mode = "index")
pairwiseRand(sce$cluster_110,sce$cluster_130, mode = "index")

#Over different resolution parameters - Silhouette width [-1,1,max], Purity[0,1,max], Root-mean-squared difference [min]
clusters <- colnames(colData(sce))[str_detect(colnames(colData(sce)),"cluster_[:digit:]")]
df <- foreach(i = seq_along(clusters),.combine = rbind) %do% {
num_clus <- length(unique(colData(sce)[,clusters[i]]))
sil <- approxSilhouette(t(assay(sce, "min_max")), clusters=colData(sce)[,clusters[i]])
#purity <- neighborPurity(t(assay(sce, "exprs")), clusters=colData(sce)[,clusters[i]]) #takes very long to compute - do once and then save figure
rmsd <- clusterRMSD(t(assay(sce, "min_max")), clusters=colData(sce)[,clusters[i]])
data.frame(num_clus = num_clus,
           k = as.numeric(str_split(clusters[i],"_",simplify = TRUE)[,2]), 
           sil = mean(sil$width), 
#           purity = mean(purity$purity),
           rmsd = sum(rmsd))
}


p1 <- ggplot(df, aes(x=k, y=num_clus))+ 
  geom_line(lwd = 2,color = "#377EB8")+
  theme_classic()
p2 <- ggplot(df, aes(x=k, y=sil))+ 
  geom_line(lwd = 2,color = "#377EB8")+
  theme_classic()
p3 <- ggplot(df, aes(x=k, y=rmsd))+ 
  geom_line(lwd = 2,color = "#377EB8")+
  theme_classic()

p1+p3+p2 

#Chosen method => k=110

#Cluster colors 
col_clus <- colorRampPalette(brewer.pal(9,"Paired"))(length(unique(sce$cluster_110)))

#By clusters for one method (here k=110)
#1. Silhouette width [-1,1]
#Clusters with large positive silhouette widths are well-separated from other clusters
sil.approx <- approxSilhouette(t(assay(sce, "exprs")), clusters=sce$cluster_110)
sil.data <- as.data.frame(sil.approx)
sil.data$closest <- factor(ifelse(sil.data$width > 0, sce$cluster_110, sil.data$other))
sil.data$cluster <- sce$cluster_110

p4 <- ggplot(sil.data, aes(x=cluster, y=width, colour=closest)) +
    ggbeeswarm::geom_quasirandom(method="smiley")+
  theme_classic()+
  scale_color_manual(values = col_clus)
p4

```
## Add missing metadata 

```{r}
# Missing metadata for 10 ZTMA174 patients
sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor.rds")

meta <- read.csv("/mnt/rcc_volume/TNBC/data_analysis/03_data/Metadata_Combined_TNBC_LM.csv",row.names = 1)

colData <- colData(sce) %>% as.data.frame() %>% select("PID","age","grade","pT", "pT_simple", "pN", "pN_simple", "status_OS","status_DFS", "OS_months","DFS_months") %>% distinct()

## Add relevant metadata based on PID
for (entry in colnames(meta)[colnames(meta) %in% c("age","grade","pT", "pT_simple", "pN", "pN_simple", "status_OS","status_DFS", "OS_months","DFS_months")]) {
  colData(sce)[,entry] <- meta[,entry][match(colData(sce)[,"PID"],meta[,"PID"])]
}
```

# 2. Heatmap visualization

## Heatmap with different scales 

```{r heatmap scales, message=FALSE,warning=FALSE}
#Read sce after clustering
sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor_new.rds")

#Heatmap body colors
col_exprs <- colorRamp2(c(0,1,2,3), c("#440154FF", "#31688EFF", "#35B779FF", "#FDE725FF"))
col_min_max <- colorRamp2(c(0,0.2,0.4,0.6,0.8), c("#440154FF", "#33628DFF", "#28AE80FF", "#DBE318FF", "#FDE725FF"))

### 1. Mean exprs counts
#Aggregrate across cells with the mean

cluster_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_110,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce)$cluster_channel)

cellstate_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_110,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce)$cell_state_channel)

other_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_110,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce)$other_immune_channel)

h_exprs <- Heatmap(t(assay(cluster_mean_sce, "exprs")),
        column_title = "1. mean exprs",
        col = col_exprs,
        name= "mean exprs",
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
Heatmap(t(assay(cellstate_mean_sce, "exprs")),
        col = col_exprs,
        name= "mean exprs",
        show_row_names = T,
        show_column_names =  T,
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  Heatmap(t(assay(other_mean_sce, "exprs")),
        col = col_exprs,
        name= "mean exprs",
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")


h_exprs 

### 2. Mean min_max counts
#Aggregrate across cells with the mean
cluster_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_110,
                                 statistics = "mean",
                                 use.assay.type = "min_max",
                                 subset.row = rowData(sce)$cluster_channel)

cellstate_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_110,
                                 statistics = "mean",
                                 use.assay.type = "min_max",
                                 subset.row = rowData(sce)$cell_state_channel)

other_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_110,
                                 statistics = "mean",
                                 use.assay.type = "min_max",
                                 subset.row = rowData(sce)$other_immune_channel)

h_min_max <- Heatmap(t(assay(cluster_mean_sce, "min_max")),
        column_title = "2. mean min_max",
        col = col_min_max,
        name= "min_max",
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
Heatmap(t(assay(cellstate_mean_sce, "min_max")),
        col = col_min_max,
        name= "min_max",
        show_row_names = T,
        show_column_names =  T,
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
Heatmap(t(assay(other_mean_sce, "min_max")),
        col = col_min_max,
        name= "min_max",
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")

h_exprs+
h_min_max
```

### Optional: Cluster merging of similar clusters - NOT PERFORMED HERE

```{r cluster merg}
sce$cluster_110_merg <- sce$cluster_110
sce$cluster_110_merg <- ifelse(sce$cluster_110_merg %in% c("10","11", "24"), "10_11_24", sce$cluster_110_merg)
sce$cluster_110_merg <- as.factor(sce$cluster_110_merg)

#define new and sorted cluster names
cluster_110_merg_df <- data.frame(cluster_110_merg = unique(sce$cluster_110_merg), cluster_110_merg_names = seq_along(unique(sce$cluster_110_merg))) 
sce$cluster_110_merg <- cluster_110_merg_df$cluster_110_merg_names[match(sce$cluster_110_merg,cluster_110_merg_df$cluster_110_merg)]
sce$cluster_110_merg <- as.factor(sce$cluster_110_merg)
```

## Rich heatmap of clusters with additional information (other channels, spatial, grade, subtype)

```{r heatmap sce_1, message=FALSE, warning=FALSE}
### 1. Heatmap body ###

#Aggregrate across cells with the mean (median is also possible)
cluster_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_110,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce)$cluster_channel)

other_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_110,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce)$other_immune_channel)

# Heatmap body colors 
col_exprs <- colorRamp2(c(0,1,2,3), c("#440154FF", "#31688EFF", "#35B779FF", "#FDE725FF"))


### 2. Heatmap annotation ###
###2.1 Metacluster 

library(clValid)

#Internal measures
set.seed(22)
testCL<- clValid(t(assay(cluster_mean_sce, "exprs")),nClust = 4:20,clMethods = c("hierarchical","agnes","kmeans","pam"),validation="internal",metric="euclidean", method = "ward")
summary(testCL)
plot(testCL, legend = TRUE)

#Stability measures 
testCL_1<- clValid(t(assay(cluster_mean_sce, "exprs")),nClust = 4:20,clMethods = c("hierarchical","agnes","kmeans","pam"),validation="stability",metric="euclidean", method = "ward")
summary(testCL_1)
plot(testCL_1, legend = TRUE)

#chosen method: hierarchical, k=8

library(dendextend)
avg_dend_obj_MCP <- as.dendrogram(agnes(t(assay(cluster_mean_sce, "exprs")),metric = "euclidean",method = "ward"))
avg_col_dend_MCP <- color_branches(avg_dend_obj_MCP, k = 8)
plot(avg_col_dend_MCP)

#retrieve row_order
set.seed(22)
ht_kmeans <- Heatmap(t(assay(cluster_mean_sce, "exprs")),
        column_title = "cluster_channels",
        col = col_exprs,
        name= "mean exprs",
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        #cluster_rows = avg_col_dend_MCP, 
        row_split = 9,
        #row_km = 8, row_km_repeats = 10000,
        cluster_row_slices = FALSE)
  
ht_kmeans <- draw(ht_kmeans)
row_order_ht <- row_order(ht_kmeans)

anno <- colData(cluster_mean_sce) %>% as.data.frame %>% select(cluster_110,ncells)
anno$pre_metacluster <- NA
foreach(i = seq_along(row_order_ht))%do%{
anno$pre_metacluster <- as.factor((ifelse(anno$cluster_110 %in% row_order_ht[[i]], i,anno$pre_metacluster)))
}

## pre_metacluster_1 - splitting 
library(dendextend)
dend_1 <- row_dend(ht_kmeans)[[1]]
dend_1 <- color_branches(dend_1, k=3)
plot(dend_1)

anno <- anno %>% mutate(metacluster = ifelse(pre_metacluster == "1" & cluster_110 %in% c("39","43","40","42"), "10", 
                                       ifelse(pre_metacluster == "1" & cluster_110 %in% c("8","28","15","11","5","38"), "11", 
                                              ifelse(pre_metacluster == "1" & cluster_110 %in% c("13","22","24","12","53","54"), "1", pre_metacluster))))
anno$metacluster <- factor(anno$metacluster)

#add (pre) metacluster to sce
sce$pre_metacluster <- anno$pre_metacluster[match(sce$cluster_110,anno$cluster_110)]
sce$metacluster <- anno$metacluster[match(sce$cluster_110,anno$cluster_110)]

### 2.2 Spatial features

#Add number of neighbors to sce object (saved in ColPair)
n_neighbors <- colPair(sce) %>% as.data.frame %>% group_by(from) %>% dplyr::count() %>% arrange(desc(n))

sce$n_neighbors <- n_neighbors$n[match(seq_along(colnames(sce)),n_neighbors$from)]
sce$n_neighbors <- sce$n_neighbors %>% replace_na(0)

#Select spatial features and average over clusters 
spatial <- colData(sce) %>% as.data.frame %>% select(cluster_110, area, eccentricity, n_neighbors)
spatial <- spatial %>% select(-cluster_110) %>% aggregate(by = list(cluster_110 = spatial$cluster_110), FUN = mean) %>% column_to_rownames("cluster_110")

#Create Spatial Heatmap Annotation
ha_spatial <- HeatmapAnnotation(
    area = spatial$area,
    eccentricity = spatial$eccentricity,
    n_neighbors = spatial$n_neighbors, 
    col = list(area = metadata(sce)$colors$area,
               eccentricity = metadata(sce)$colors$eccentricity,
               n_neighbors = metadata(sce)$colors$n_neighbors),
    border = TRUE,
    which = "row")


###2.3 Metadata features

#Number of cells per cluster 
n_cells <- colData(cluster_mean_sce) %>% as.data.frame %>% select(cluster_110, ncells)

# Proportion of grade per cluster
grade <- colData(sce) %>% as.data.frame() %>% select(cluster_110,grade) %>% group_by(cluster_110) %>% table() %>% as.data.frame
grade <- grade %>% group_by(cluster_110) %>% mutate(fra = Freq/sum(Freq)) 
grade <- grade %>% select(-Freq) %>% pivot_wider(id_cols = cluster_110,names_from = grade,values_from = fra) %>% column_to_rownames("cluster_110")

# Proportion of pT stage per cluster
pT <- colData(sce) %>% as.data.frame() %>% select(cluster_110,pT_simple) %>% group_by(cluster_110) %>% table() %>% as.data.frame
pT <- pT %>% group_by(cluster_110) %>% mutate(fra = Freq/sum(Freq)) 
pT <- pT %>% select(-Freq) %>% pivot_wider(id_cols = cluster_110,names_from = pT_simple,values_from = fra) %>% column_to_rownames("cluster_110")

# Proportion of pN stage per cluster
pN <- colData(sce) %>% as.data.frame() %>% select(cluster_110,pN_simple) %>% group_by(cluster_110) %>% table() %>% as.data.frame
pN <- pN %>% group_by(cluster_110) %>% mutate(fra = Freq/sum(Freq)) 
pN <- pN %>% select(-Freq) %>% pivot_wider(id_cols = cluster_110,names_from = pN_simple,values_from = fra) %>% column_to_rownames("cluster_110")

# Number of contributing patients
cluster_PID <- colData(sce) %>% as.data.frame() %>% select(cluster_110,PID) %>% group_by(cluster_110) %>% table() %>% as.data.frame
n_PID <- cluster_PID %>% filter(Freq>0) %>% group_by(cluster_110) %>% count(name = "n_PID") %>% column_to_rownames("cluster_110")

# Cluster categories contributing to clusters
cluster_CC <- colData(sce) %>% as.data.frame() %>% select(cluster_110,cluster_category) %>% group_by(cluster_110) %>% table() %>% as.data.frame
cluster_CC <- cluster_CC %>% group_by(cluster_110) %>% mutate(fra = Freq/sum(Freq)) 
cluster_CC <- cluster_CC %>% select(-Freq) %>% pivot_wider(id_cols = cluster_110,names_from = cluster_category,values_from = fra) %>% column_to_rownames("cluster_110")

# Define color scheme for clusters and metaclusters
row_order_clusters <- row_order(Heatmap(t(assay(cluster_mean_sce, "exprs")),
        column_title = "cluster_channels",
        col = col_exprs,
        name= "mean exprs",
        km = 1,
        show_row_names = T, 
        show_column_names =  T, 
        cluster_row_slices = FALSE,
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2"))

cluster_col <- setNames(colorRampPalette(brewer.pal(9, "Paired"))(length(unique(anno$cluster_110))),row_order_clusters)
metacluster_col <- setNames(colorRampPalette(brewer.pal(9, "Paired"))(length(unique(anno$metacluster))),order(unique(anno$metacluster)))                                             
metadata(sce)$colors$cluster_110 <- cluster_col
metadata(sce)$colors$metacluster <- metacluster_col

# Metadata annotation
ha_meta <- HeatmapAnnotation(cluster_110 = anno_simple(unfactor(anno$cluster_110), pch = unfactor(anno$cluster_110),border=TRUE,col=metadata(sce)$colors$cluster_110),
                            metacluster = anno_simple(unfactor(anno$metacluster), pch = unfactor(anno$metacluster),border=TRUE,col=metadata(sce)$colors$metacluster),
                            n_cells = anno_barplot(n_cells$ncells, width = unit(10, "mm"),gp = gpar(fill = "#440154FF")),
                            n_PID = anno_barplot(n_PID, width = unit(10, "mm"),gp = gpar(fill = "#440154FF")),
                            grade = anno_barplot(grade, width = unit(10, "mm"),gp = gpar(fill = metadata(sce)$colors$grade)),
                            pT = anno_barplot(pT, width = unit(10, "mm"),gp = gpar(fill = metadata(sce)$colors$pT_simple)),
                            pN = anno_barplot(pN, width = unit(10, "mm"),gp = gpar(fill = metadata(sce)$colors$pN_simple)),
                            #cluster_cat = anno_barplot(cluster_CC, width = unit(10, "mm"),gp = gpar(fill = metadata(sce)$colors$cluster_category)),
                            border = TRUE, 
                            annotation_name_rot = 90,
                            gap = unit(1,"mm"),
                            which = "row")
                            
### 3. Plot heatmap ###

h <- Heatmap(t(assay(cluster_mean_sce, "exprs")),
        column_title = "cluster_channels",
        col = col_exprs,
        name = "mean exprs",
        row_title = NULL, 
        show_column_names =  TRUE, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        row_split = anno$metacluster,
        cluster_row_slices = FALSE)+
  Heatmap(t(assay(other_mean_sce, "exprs")),
        column_title = "other_channels",
        col = col_exprs,
        name= "mean exprs",
        show_row_names = FALSE, 
        show_column_names =  TRUE, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  ha_meta+
  ha_spatial

draw(h)

#6.3 Cluster annotation heatmap
h_cluster_anno <- HeatmapAnnotation(cluster_110 = anno_simple(row_order_clusters, pch = as.character(row_order_clusters),border=TRUE,col=metadata(sce)$colors$cluster_110),
                            metacluster = anno_simple(unfactor(anno$metacluster[row_order_clusters]), 
                                                      pch= unfactor(anno$metacluster[row_order_clusters]),border=TRUE,col=metadata(sce)$colors$metacluster),
                            border = TRUE, 
                            annotation_name_rot = 90,
                            gap = unit(1,"mm"),
                            which = "row")+NULL

draw(h_cluster_anno)
```

```{r save object}
#Save sce after metacluster assignment
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor_new.rds")
```

# 3. Single-cell visualization

## Dimensionality reduction 

```{r dimred, message=FALSE,warning=FALSE}
## Subsample 10% of cells from each core 
#to save time and not get super crowded dimensionality reduction plots
set.seed(22)
sub <- colData(sce) %>% as.data.frame() %>% group_by("sample_id") %>% slice_sample(prop = 0.1) %>% arrange("sample_id") %>% mutate(sub_id = paste(sample_id,ObjectNumber,sep="_")) %>% pull(sub_id)
sce_sub <- sce[,sub]

#Run UMAP/TSNE on cluster channels
sce_sub <- runUMAP(sce_sub[rowData(sce_sub)$cluster_channel,], n_neighbors = 100, pca = 50, exprs_values = "exprs",external_neighbors=TRUE, BPPARAM = MulticoreParam())

sce_sub <- runTSNE(sce_sub[rowData(sce_sub)$cluster_channel,], exprs_values = "exprs", external_neighbors=TRUE, BPPARAM = MulticoreParam())


## 1. Visualize UMAP and TSNE
UMAP_clus <- plotReducedDim(sce_sub, dimred = "UMAP", colour_by = "cluster_110")+
  scale_color_manual(values = metadata(sce)$colors$cluster_10)
UMAP_metaclus <- plotReducedDim(sce_sub, dimred = "UMAP", colour_by = "metacluster")+
  scale_color_manual(values = metadata(sce)$colors$metacluster)

UMAP_clus+UMAP_metaclus
  
TSNE_clus <- plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "cluster_110")+
  scale_color_manual(values = metadata(sce)$colors$cluster_110)
TSNE_metaclus <- plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "metacluster")+
  scale_color_manual(values = metadata(sce)$colors$metacluster)

TSNE_clus+TSNE_metaclus

#Visualize all marker expression
all_plots_UMAP <- lapply(c(rownames(sce_sub)[rowData(sce_sub)$cluster_channel]),
                    function(x){
                      p <- plotReducedDim(sce_sub, dimred = "UMAP", 
                                          colour_by = x, 
                                          by_exprs_values = "exprs",
                                          point_size = 0.5)
                      return(p)                    
                    })

library(cowplot)
exp_plots_UMAP <- plot_grid(plotlist = all_plots_UMAP)

all_plots_TSNE <- lapply(c(rownames(sce_sub)[rowData(sce_sub)$cluster_channel]),
                    function(x){
                      p <- plotReducedDim(sce_sub, dimred = "TSNE", 
                                          colour_by = x, 
                                          by_exprs_values = "exprs",
                                          point_size = 0.5)
                      return(p)                    
                    })

library(cowplot)
exp_plots_TSNE <- plot_grid(plotlist = all_plots_TSNE)
```

## Heatmap for subset of cells

```{r heatmap sub}
#Heatmap visualization
dittoHeatmap(sce_sub, 
             genes = rownames(sce_sub)[rowData(sce_sub)$cluster_channel],
             assay = "exprs", 
             scale = "none", 
             order.by = c("metacluster", "cluster_110"), 
             heatmap.colors = viridis(100), 
             annot.by = c("metacluster", "cluster_110"),
             annotation_colors = list(metacluster = metadata(sce_sub)$colors$metacluster, 
                                      cluster_110 = metadata(sce_sub)$colors$cluster_110)
)
             
```
## Heatmap for cell count per cluster/metacluster

```{r PID/cluster cells viz}
# 1. Cluster
library(tidyverse)
for_plot <- colData(sce) %>% as_tibble() %>%
    group_by(PID, cluster_110) %>%
    summarize(count = n()) %>%
    mutate(log_count = log(count)) %>%
    pivot_wider(id_cols = PID, names_from = cluster_110, 
                values_from = log_count, values_fill = 0) %>%
    ungroup() %>%
    select(-PID)

pheatmap(for_plot, #color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "none", show_rownames = TRUE)

# 2. Metacluster
library(tidyverse)
for_plot_MC <- colData(sce) %>% as_tibble() %>%
    group_by(PID, metacluster) %>%
    summarize(count = n()) %>%
    mutate(log_count = log(count)) %>%
    pivot_wider(id_cols = PID, names_from = metacluster, 
                values_from = log_count, values_fill = 0) %>%
    ungroup() %>%
    select(-PID)

pheatmap(for_plot_MC, 
         #color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "none", 
         show_rownames = FALSE
          )
```

## Violin plot visualization

```{r celltype violin, message=FALSE, fig.width=6, fig.height=10}
#Violin Plot - plotExpression
plotExpression(sce_sub, 
               features = rownames(sce_sub)[rowData(sce_sub)$cluster_channel],
               x = "metacluster", exprs_values = "exprs", 
               colour_by = "metacluster") +
    theme(axis.text.x =  element_text(angle = 90))+
    scale_color_manual(values = metadata(sce_sub)$colors$metacluster)
```

## Barplot visualization 

### Fractions - Visualization and correlation of cluster fractions

```{r cluster-pro, message = FALSE, warning = FALSE}
## 1. Fraction of metacluster/cluster per sample/PID
d_SID <- dittoBarPlot(sce, var = "metacluster", group.by = "sample_id")+
  scale_fill_manual(values = metadata(sce)$colors$metacluster)+
  theme(axis.text.x = element_blank())

d_PID <- dittoBarPlot(sce, var = "metacluster", group.by = "PID")+
  scale_fill_manual(values = metadata(sce)$colors$metacluster)+
  theme(axis.text.x = element_blank())

dittoBarPlot(sce, var = "cluster_110", group.by = "sample_id")+
  scale_fill_manual(values = metadata(sce)$colors$cluster_110)+
  theme(axis.text.x = element_blank())

dittoBarPlot(sce, var = "cluster_110", group.by = "PID")+
  scale_fill_manual(values = metadata(sce)$colors$cluster_110)+
  theme(axis.text.x = element_blank())

## 2. Fraction of sample/PID per metacluster/cluster
dittoBarPlot(sce, var = "PID", group.by = "metacluster")+
  scale_fill_manual(values = metadata(sce)$colors$PID)+
  guides(fill = "none")

dittoBarPlot(sce, var = "PID", group.by = "cluster_110")+
  scale_fill_manual(values = metadata(sce)$colors$PID)+
  guides(fill = "none")

dittoBarPlot(sce, var = "sample_id", group.by = "metacluster")+
  guides(fill = "none")

dittoBarPlot(sce, var = "sample_id", group.by = "cluster_110")+
  guides(fill = "none")


## 3. Correlation of metacluster/cluster fractions for each PID (2-4 samples per PID)
SID_cluster <- colData(sce) %>% as.data.frame() %>% select(cluster_110,sample_id) %>% group_by(sample_id) %>% table() %>% as.data.frame
SID_cluster <- SID_cluster %>% group_by(sample_id) %>% mutate(fra = Freq/sum(Freq))

SID_metacluster <- colData(sce) %>% as.data.frame() %>% select(metacluster,sample_id) %>% group_by(sample_id) %>% table() %>% as.data.frame
SID_metacluster <- SID_metacluster %>% group_by(sample_id) %>% mutate(fra = Freq/sum(Freq))

# Cluster fraction correlation for each PID (2 samples per PID)
## by cluster
SID_cluster_cor <- SID_cluster
SID_cluster_cor$PID <- sce$PID[match(SID_cluster$sample_id,sce$sample_id)]

SID_cluster_cor <- foreach(i = unique(colData(sce)$PID),.combine = "rbind")%do%{
SID <- SID_cluster_cor %>% filter(PID %in% i) %>% select(-Freq,-PID) %>% pivot_wider(id_cols = cluster_110,names_from = sample_id,values_from = fra) %>% column_to_rownames("cluster_110")
cor <- cor(SID,method = "spearman")
cor[2]
}

SID_cluster_cor <- as.data.frame(SID_cluster_cor) 
SID_cluster_cor$PID <- unique(colData(sce)$PID) 
SID_cluster_cor$category <- "PID"

SID_cluster_cor_plot <- ggplot(SID_cluster_cor, aes(x = category, y = V1))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = PID), size = 3, position=position_jitter(w=0.1,h=0.1))+
  guides(color = "none")+
  scale_color_manual(values = metadata(sce)$colors$PID)+
  theme_classic(base_size = 12)+
  theme(axis.title.x = element_blank())+
  ylab("Correlation of cluster fractions per PID (n=2-4)")+
  ggtitle(paste("Spearman rho = ",round(median(SID_cluster_cor$V1, na.rm = TRUE), digits = 2)))

SID_cluster_cor_plot

## by metacluster
SID_metacluster_cor <- SID_metacluster
SID_metacluster_cor$PID <- sce$PID[match(SID_metacluster$sample_id,sce$sample_id)]

SID_metacluster_cor <- foreach(i = unique(colData(sce)$PID),.combine = "rbind")%do%{
SID <- SID_metacluster_cor %>% filter(PID %in% i) %>% select(-Freq,-PID) %>% pivot_wider(id_cols = metacluster,names_from = sample_id,values_from = fra) %>% column_to_rownames("metacluster")
cor <- cor(SID,method = "spearman")
cor[2]
}

SID_metacluster_cor <- as.data.frame(SID_metacluster_cor) 
SID_metacluster_cor$PID <- unique(colData(sce)$PID) 
SID_metacluster_cor$category <- "PID"

SID_metacluster_cor_plot <- ggplot(SID_metacluster_cor, aes(x = category, y = V1))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = PID), size = 3, position=position_jitter(w=0.1,h=0.1))+
  guides(color = "none")+
  scale_color_manual(values = metadata(sce)$colors$PID)+
  theme_classic(base_size = 12)+
  theme(axis.title.x = element_blank())+
  ylab("Correlation of metacluster fractions per PID (n=2-4)")+
  ggtitle(paste("Spearman rho = ",round(median(SID_metacluster_cor$V1, na.rm = TRUE), digits = 2)))

SID_metacluster_cor_plot

d_PID+SID_metacluster_cor_plot

```

### Densities - Visualization and correlation of cluster densities

```{r density cor}
# 1. By metaclusters

## Density barplot

### For each sample
SID_metacluster <- colData(sce) %>% as.data.frame() %>% select(metacluster,sample_id) %>% group_by(sample_id) %>% table() %>% as.data.frame

SID_metacluster$tissue_area <- sce$tissue_area[match(SID_metacluster$sample_id,sce$sample_id)]

SID_metacluster <- SID_metacluster %>% mutate(density = Freq/(tissue_area/1000000))

ggplot(SID_metacluster) +
  geom_tile(color = "black",aes(sample_id, density, fill = metacluster), position = "stack")+
  scale_fill_manual(values=metadata(sce)$colors$metacluster) + 
  theme_classic(base_size = 15)+
  ylab("Density")+
  xlab("PID")+
  theme(axis.text.x = element_blank())

### For each PID
PID_metacluster <- colData(sce) %>% as.data.frame() %>% select(metacluster,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_metacluster$tissue_area <- sce$tissue_area[match(PID_metacluster$PID,sce$PID)]

PID_metacluster <- PID_metacluster %>% mutate(density = Freq/(tissue_area/1000000))

d_dens_PID <- ggplot(PID_metacluster) +
  geom_tile(color = "black",aes(PID, density, fill = metacluster), position = "stack")+
  scale_fill_manual(values=metadata(sce)$colors$metacluster) + 
  theme_classic(base_size = 15)+
  ylab("Density")+
  xlab("PID")+
  theme(axis.text.x = element_blank())


## Correlation of metacluster/cluster densities for each PID (2-4 samples per PID) - SAME AS FOR FRACTION CORRELATION?

### By metacluster density
SID_metacluster_cor <- SID_metacluster

SID_metacluster_cor$PID <- sce$PID[match(SID_metacluster_cor$sample_id,sce$sample_id)]

SID_metacluster_cor <- foreach(i = unique(colData(sce)$PID),.combine = "rbind")%do%{
SID <- SID_metacluster_cor %>% filter(PID %in% i) %>% select(-Freq,-PID) %>% pivot_wider(id_cols = metacluster,names_from = sample_id,values_from = density) %>% column_to_rownames("metacluster")
cor <- cor(SID,method = "pearson")
cor[2]
}

SID_metacluster_cor <- as.data.frame(SID_metacluster_cor) 
SID_metacluster_cor$PID <- unique(colData(sce)$PID) 
SID_metacluster_cor$category <- "PID"

SID_metacluster_dens_cor_plot <- ggplot(SID_metacluster_cor, aes(x = category, y = V1))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = PID), size = 3, position=position_jitter(w=0.1,h=0.1))+
  guides(color = "none")+
  scale_color_manual(values = metadata(sce)$colors$PID)+
  theme_classic(base_size = 12)+
  theme(axis.title.x = element_blank())+
  ylab("Correlation of metacluster densities per PID (n=2-4)")+
  ggtitle(paste("Spearman rho = ",round(median(SID_metacluster_cor$V1, na.rm = TRUE), digits = 2)))

SID_metacluster_dens_cor_plot


### By cluster density
SID_immune_cluster <- colData(sce) %>% as.data.frame() %>% select(cluster_130,sample_id) %>% group_by(sample_id) %>% table() %>% as.data.frame

SID_immune_cluster$tissue_area <- sce$tissue_area[match(SID_immune_cluster$sample_id,sce$sample_id)]

SID_immune_cluster <- SID_immune_cluster %>% mutate(density = Freq/(tissue_area/1000000))

SID_cluster_dens_cor <- SID_immune_cluster

SID_cluster_dens_cor$PID <- sce$PID[match(SID_cluster_dens_cor$sample_id,sce$sample_id)]

SID_cluster_dens_cor <- foreach(i = unique(colData(sce)$PID),.combine = "rbind")%do%{
SID <- SID_cluster_dens_cor %>% filter(PID %in% i) %>% select(-Freq,-PID,-tissue_area) %>% pivot_wider(id_cols = cluster_130,names_from = sample_id,values_from = density) %>% column_to_rownames("cluster_130")
cor <- cor(SID,method = "spearman")
cor[2]
}

SID_cluster_dens_cor <- as.data.frame(SID_cluster_dens_cor) 
SID_cluster_dens_cor$PID <- unique(colData(sce)$PID) 
SID_cluster_dens_cor$category <- "PID"

SID_cluster_dens_cor_plot <- ggplot(SID_cluster_dens_cor, aes(x = category, y = V1))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = PID), size = 3, position=position_jitter(w=0.1,h=0.1))+
  guides(color = "none")+
  scale_color_manual(values = metadata(sce)$colors$PID)+
  theme_classic(base_size = 12)+
  theme(axis.title.x = element_blank())+
  ylab("Correlation of cluster densities per PID (n=2-4)")+
  ggtitle(paste("Spearman rho = ",round(median(SID_cluster_dens_cor$V1, na.rm = TRUE), digits = 2)))

SID_cluster_dens_cor_plot

(d_PID+SID_metacluster_cor_plot)/
(d_dens_PID+SID_metacluster_dens_cor_plot)

```

## CATALYST-based visualization

We will first convert the sce into a CATALYST-compatible format.

```{r CATALYST}
library(CATALYST)
# save spe in CATALYST-compatible object with renamed colData entries and 
# new metadata information
sce_cat <- sce 
sce_cat$sample_id <- factor(sce$PID)
sce_cat$cluster_id <- factor(sce$metacluster)

#add celltype information to metadata
metadata(sce_cat)$cluster_codes <- data.frame(metacluster = factor(sce_cat$metacluster))
```

```{r CATALYST pbmds and clrDR, message=FALSE}
# MDS pseudobulk by metacluster
pbMDS(sce_cat, by = "cluster_id", 
      features = rownames(sce_cat)[rowData(sce_cat)$cluster_channel], 
      label_by = "cluster_id", k = "metacluster") +
  scale_color_manual(values = metadata(sce_cat)$colors$metacluster)+
  theme_classic()

# MDS pseudobulk by metacluster
pbMDS(sce_cat, by = "both", 
      features = rownames(sce_cat)[rowData(sce_cat)$cluster_channel], 
      k = "metacluster",
      size_by = TRUE) +
  scale_color_manual(values = metadata(sce_cat)$colors$metacluster)+
  theme_classic()

# CLR on metacluster proportions across samples
clrDR(sce_cat, dr = "PCA", 
      by = "cluster_id", k = "metacluster", 
      label_by = "cluster_id", arrow_col = "PID", 
      point_pal = metadata(sce_cat)$colors$metacluster, 
      arrows = FALSE) +
  scale_color_manual(values = metadata(sce_cat)$colors$PID)+
  guides(color = "none")+
  theme_classic()

# CLR on sample proportions across metaclusters
clrDR(sce_cat, dr = "PCA", 
      by = "sample_id", point_col = "sample_id",
      k = "metacluster", point_pal = metadata(sce_cat)$colors$PID)+
  scale_color_manual(values = metadata(sce_cat)$colors$metacluster)+
  guides(fill = "none")+
  theme_classic()
```

## Check correlation of markers

```{r marker correlations}
# Cluster channel marker correlation (all markers - does not show distribution which is usually recommended)
cor_sce <- as.data.frame(t(assay(sce,"exprs")[rowData(sce)$cluster_channel,]))

corrplot(cor(cor_sce,method = "spearman"), method="color", col=brewer.pal(n=8, name="RdBu"),  
         type="upper", order="hclust",hclust.method = "ward.D2", 
         addCoef.col = "black", addCoefasPercent = F,# Add coefficient of correlation
         tl.col="black", tl.srt=40, #Text label color and rotation
         # Combine with significance
         #p.mat = p.mat, sig.level = 0.01, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag=F
)

# For specific markers of interest (also shows the value distribution which is recommended)
pairs.panels(cor_sce[,c("CK5","KRT14")],
             method = "spearman",
             hist.col = "royalblue1",
             digits = 2)
```
# 4. Survival analysis 

## Cox-proportonal hazards model for metaclusters

### For OS on metaclusters

```{r cox}
library(survival)
library(survminer)

PID_metacluster <- colData(sce) %>% as.data.frame() %>% select(metacluster,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_metacluster <- PID_metacluster %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_metacluster %>% pivot_wider(id_cols = "PID",names_from = "metacluster",values_from = "fra") %>% column_to_rownames("PID")
colnames(PID_metagroups) <- paste0("MC",colnames(PID_metagroups))

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_OS <- sce$status_OS[match(rownames(Cox_df),sce$PID)]
Cox_df$OS_months <- sce$OS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#Based on proportions
covariates <- Cox_df %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -MC1) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+ MC1"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratios
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for con_prop")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop

## 2. Based on categories (mean division of cluster proportions)
Cox_df_mean <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
Cox_df %>% select(i) %>% mutate(mean = ifelse(Cox_df[,i] > mean(Cox_df[,i]),"B","A")) %>% pull(mean)
}

colnames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_mean <- as.data.frame(Cox_df_mean)

identical(rownames(Cox_df), rownames(Cox_df_mean))

Cox_df_mean <- cbind(Cox_df_mean, Cox_df %>% select(status_OS,OS_months, status_OS, OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_mean %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_mean)

summary(multi_model)

multi_res <- summary(multi_model)

plot_df_mean <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_mean <- ggplot(plot_df_mean, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for mean")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_mean

## 3. Based on categories (GMM division of cluster proportions)
Cox_df_GMM <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
GMM_Cox <- Mclust(Cox_df[,i], G = 2)
as.character(GMM_Cox$classification)
}

colnames(Cox_df_GMM) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_GMM) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_GMM <- as.data.frame(Cox_df_GMM,stringsAsFactors=TRUE)

identical(rownames(Cox_df), rownames(Cox_df_GMM))

Cox_df_GMM <- cbind(Cox_df_GMM, Cox_df %>% select(status_OS,OS_months, status_OS, OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_GMM %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_GMM)

summary(multi_model)

summary(Cox_df_GMM)

multi_res <- summary(multi_model)

plot_df_GMM <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_GMM <- ggplot(plot_df_GMM, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for GMM")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop/
hr_mean/
hr_GMM
```


```{r OS survival_curves}
#Plot survival curves
fit <- survfit(Surv(OS_months, status_OS) ~ MC6, data = Cox_df_mean)
print(fit)

p1 <- ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = "Set1",
          log.rank.weights = "n")+
  ggtitle("Mean proportion")

fit <- survfit(Surv(OS_months, status_OS) ~ MC2, data = Cox_df_mean)
print(fit)

p2 <- ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = "Set1",
          log.rank.weights = "n")+
  ggtitle("Mean proportion")

arrange_ggsurvplots(list(p1,p2))
```

### For DFS on metaclusters

```{r cox dfs}
library(survival)
library(survminer)

PID_metacluster <- colData(sce) %>% as.data.frame() %>% select(metacluster,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_metacluster <- PID_metacluster %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_metacluster %>% pivot_wider(id_cols = "PID",names_from = "metacluster",values_from = "fra") %>% column_to_rownames("PID")
colnames(PID_metagroups) <- paste0("MC",colnames(PID_metagroups))

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#Based on proportions
covariates <- Cox_df %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -MC1) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+ MC1"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratiDFS
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for con_prop")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop

## 2. Based on categories (mean division of cluster proportions)

Cox_df_mean <- foreach(i = Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
Cox_df %>% select(i) %>% mutate(mean = ifelse(Cox_df[,i] > mean(Cox_df[,i]),"B","A")) %>% pull(mean)
}

colnames(Cox_df_mean) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_mean) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_mean <- as.data.frame(Cox_df_mean)

identical(rownames(Cox_df), rownames(Cox_df_mean))

Cox_df_mean <- cbind(Cox_df_mean, Cox_df %>% select(status_DFS,DFS_months, status_DFS, DFS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_mean %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_mean)

summary(multi_model)

multi_res <- summary(multi_model)

plot_df_mean <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_mean <- ggplot(plot_df_mean, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for mean")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_mean

## 3. Based on categories (GMM division of cluster proportions)
Cox_df_GMM <- foreach(i = Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
GMM_Cox <- Mclust(Cox_df[,i], G = 2)
as.character(GMM_Cox$classification)
}

colnames(Cox_df_GMM) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_GMM) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_GMM <- as.data.frame(Cox_df_GMM,stringsAsFactors=TRUE)

identical(rownames(Cox_df), rownames(Cox_df_GMM))

Cox_df_GMM <- cbind(Cox_df_GMM, Cox_df %>% select(status_DFS,DFS_months, status_DFS, DFS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_GMM %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_GMM)

summary(multi_model)

summary(Cox_df_GMM)

multi_res <- summary(multi_model)

plot_df_GMM <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratio
hr_GMM <- ggplot(plot_df_GMM, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for GMM")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_mean

hr_prop/
hr_mean/
hr_GMM
```

```{r OS survival_curves}
#Plot survival curves
fit <- survfit(Surv(DFS_months, status_DFS) ~ MC8, data = Cox_df_mean)
print(fit)

p1 <- ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = "Set1",
          log.rank.weights = "n")+
  ggtitle("Mean proportion")

fit <- survfit(Surv(DFS_months, status_DFS) ~ MC9, data = Cox_df_mean)
print(fit)

p2 <- ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = "Set1",
          log.rank.weights = "S2")+
  ggtitle("GMM proportion")

arrange_ggsurvplots(list(p1,p2))
```

### For OS on metacluster density 

```{r OS metacluster density}
library(survival)
library(survminer)

PID_metacluster <- colData(sce) %>% as.data.frame() %>% select(metacluster,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_area <- colData(sce) %>% as.data.frame() %>% select(tissue_area,PID) %>% unique() %>% group_by(PID) %>% mutate(mean_tissue_area = mean(tissue_area))

PID_metacluster$mean_tissue_area <- PID_area$mean_tissue_area[match(PID_metacluster$PID, PID_area$PID)]
  
PID_metacluster <- PID_metacluster %>% group_by(PID) %>% mutate(density = Freq/(mean_tissue_area/1000000))  

### Multivariate cox proportional hazard model on multiple covariates (here density of phenotypes)
PID_metagroups <- PID_metacluster %>% pivot_wider(id_cols = "PID",names_from = "metacluster",values_from = "density") %>% column_to_rownames("PID")
colnames(PID_metagroups) <- paste0("MC",colnames(PID_metagroups))

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_OS <- sce$status_OS[match(rownames(Cox_df),sce$PID)]
Cox_df$OS_months <- sce$OS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#mean division 
Cox_df_mean <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
Cox_df %>% select(i) %>% mutate(mean = ifelse(Cox_df[,i] > mean(Cox_df[,i]),"B","A")) %>% pull(mean)
}

colnames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_mean <- as.data.frame(Cox_df_mean)

identical(rownames(Cox_df), rownames(Cox_df_mean))

Cox_df_mean <- cbind(Cox_df_mean, Cox_df %>% select(status_OS,OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#run the model
covariates <- Cox_df_mean %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_mean)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

multi_res$coefficients
#Plot hazard ratios
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for mean_density")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop
```
### For DFS on metacluster density 

```{r DFS metacluster density}
library(survival)
library(survminer)

PID_metacluster <- colData(sce) %>% as.data.frame() %>% select(metacluster,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_area <- colData(sce) %>% as.data.frame() %>% select(tissue_area,PID) %>% unique() %>% group_by(PID) %>% mutate(mean_tissue_area = mean(tissue_area))

PID_metacluster$mean_tissue_area <- PID_area$mean_tissue_area[match(PID_metacluster$PID, PID_area$PID)]
  
PID_metacluster <- PID_metacluster %>% group_by(PID) %>% mutate(density = Freq/(mean_tissue_area/1000000))  

### Multivariate cox proportional hazard model on multiple covariates (here density of phenotypes)
PID_metagroups <- PID_metacluster %>% pivot_wider(id_cols = "PID",names_from = "metacluster",values_from = "density") %>% column_to_rownames("PID")
colnames(PID_metagroups) <- paste0("MC",colnames(PID_metagroups))

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#mean division 
Cox_df_mean <- foreach(i = Cox_df %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
Cox_df %>% select(i) %>% mutate(mean = ifelse(Cox_df[,i] > mean(Cox_df[,i]),"B","A")) %>% pull(mean)
}

colnames(Cox_df_mean) <- Cox_df %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_mean) <- Cox_df %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_mean <- as.data.frame(Cox_df_mean)

identical(rownames(Cox_df), rownames(Cox_df_mean))

Cox_df_mean <- cbind(Cox_df_mean, Cox_df %>% select(status_DFS,DFS_months, age, grade, pT_simple, pN_simple, pM_simple))

#run the model
covariates <- Cox_df_mean %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_mean)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

multi_res$coefficients

#Plot hazard ratios
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Immune metaclusters")+
ylab("HR for mean_density")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop
```

### Plot proportion density curves for all metaclusters

Add lines for mean and GMM division.

```{r}
#mean division
mean_metacluster <- PID_metacluster %>% group_by(metacluster) %>% transmute(metacluster,mean = mean(fra)) %>% unique()

#GMM division
GMM_div <- Cox_df_GMM %>% select(colnames(Cox_df_GMM)[str_detect(colnames(Cox_df_GMM),"MC")]) %>% rownames_to_column("PID") %>% pivot_longer(cols = 2:9,names_to = "metacluster", values_to = "GMM")
PID_metacluster$GMM <- GMM_div$GMM
GMM_1_max_metacluster <- PID_metacluster %>% filter(GMM == "1") %>% group_by(metacluster) %>% summarise(max = max(fra))

# Plot proportion density curves for all metaclusters
ggplot(PID_metacluster, aes(fra))+
  facet_wrap(~metacluster)+
  geom_density(aes(fill = metacluster))+
  geom_rug()+
  coord_cartesian(ylim = c(0,10))+
  scale_fill_manual(values = metadata(sce)$colors$metacluster)+
  theme_classic()+
  geom_vline(data = mean_metacluster, aes(xintercept = mean),color = "#E41A1C", linetype = "dashed") #red
  #geom_vline(data = GMM_1_max_metacluster, aes(xintercept = max),color = "#377EB8", linetype = "dashed") #blue
```

## Lasso-regularized Cox-proportonal hazards model for clusters

### OS

```{r lasso OS clusters}
library(glmnet)
library(broom) 

PID_cluster <- colData(sce) %>% as.data.frame() %>% select(cluster_110,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_cluster <- PID_cluster %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))
PID_groups <- PID_cluster %>% pivot_wider(id_cols = "PID",names_from = "cluster_110",values_from = "fra") %>% column_to_rownames("PID")

### Lasso regularization
### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)

## 1. Based on continuous cluster proportions
Cox_df <- PID_groups

#add covariates for correction
Cox_df$status_OS <- sce$status_OS[match(rownames(Cox_df),sce$PID)]
Cox_df$OS_months <- sce$OS_months[match(rownames(Cox_df),sce$PID)]

#Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
#Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
#Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
#Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
#Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)]) #remove from model otherwise coefficients are shrinked to 0 for all others? 

## Run lasso regularized coxph model
Cox_df <- Cox_df[complete.cases(Cox_df),] #only have complete rows as input

x <- data.matrix(Cox_df %>% select(-status_OS,-OS_months)) #predictor variables

y <- Surv(time = Cox_df$OS_months, event = Cox_df$status_OS) #response variables

## Run lasso 
set.seed(22)
cv.fit <- cv.glmnet(x, y, family="cox", type.measure = "C")
plot(cv.fit)

fit <- glmnet(x, y, family="cox")

coef(fit, s = cv.fit$lambda.min)

## Run lasso 100 times and average error curves to be more robust
MSEs <- NULL
for (i in 1:10){
                 cv <- cv.glmnet(x, y, family="cox", type.measure = "C")
                 MSEs <- cbind(MSEs, cv$cvm)
             }

rownames(MSEs) <- cv$lambda
lambda.min <- as.numeric(names(which.min(rowMeans(MSEs))))

fit <- glmnet(x, y, family="cox")
coef(fit, s = lambda.min)

#Extract output
lasso_df <- tidy(coef(fit, s = cv.fit$lambda.min))
colnames(lasso_df) <- c("predictor","column","coef")

#Visualize hazard ratios
ggplot(lasso_df, aes(x = predictor, y = exp(coef))) +
  geom_point(size = 4, aes(color = predictor)) +
  geom_hline(yintercept = 1,color = "black")+
  scale_y_continuous(trans="log")+
  ylab("Lasso HR")+
  theme_classic()+
  ggtitle("OS")+
  scale_color_manual(values = metadata(sce)$colors$cluster_110, limits = force, na.value = "black")

```

### DFS

```{r lasso DFS clusters}
library(glmnet)
library(broom) 

PID_cluster <- colData(sce) %>% as.data.frame() %>% select(cluster_110,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_cluster <- PID_cluster %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))
PID_groups <- PID_cluster %>% pivot_wider(id_cols = "PID",names_from = "cluster_110",values_from = "fra") %>% column_to_rownames("PID")

### Lasso regularization
### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)

## 1. Based on continuous cluster proportions
Cox_df <- PID_groups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)]) #remove from model otherwise coefficients are shrinked to 0 for all others? 

## Run lasso regularized coxph model
Cox_df <- Cox_df[complete.cases(Cox_df),] #only have complete rows as input

Cox_df <- Cox_df %>% filter(DFS_months != 0)

x <-  data.matrix(Cox_df %>% select(-status_DFS,-DFS_months)) #predictor variables

y <- Surv(time = Cox_df$DFS_months, event = Cox_df$status_DFS) #response variables

## Run lasso 
require(doMC)
registerDoMC(cores = 20)
set.seed(22)
cv.fit <- cv.glmnet(x, y, family="cox", type.measure = "C", nfolds = 50, parallel = TRUE)
plot(cv.fit)

fit <- glmnet(x, y, family="cox")

coef(fit, s = cv.fit$lambda.min)

# ## Run lasso 10 times (with 10 fold validation each run) and average error curves to be more robust
# MSEs <- NULL
# for (i in 1:10){
#                   cv <- cv.glmnet(x, y, family="cox", type.measure = "C")
#                   MSEs <- cbind(MSEs, cv$cvm)
#                   }
#  
# rownames(MSEs) <- cv$lambda
# lambda.min <- as.numeric(names(which.min(rowMeans(MSEs))))
#  
# fit <- glmnet(x, y, family="cox")
# coef(fit, s = lambda.min)

#Extract output
lasso_df <- tidy(coef(fit, s = cv.fit$lambda.min))
 colnames(lasso_df) <- c("predictor","column","coef")

#Visualize hazard ratios
ggplot(lasso_df, aes(x = reorder(predictor, coef), y = exp(coef))) +
  geom_point(size = 4, aes(color = predictor)) +
  geom_hline(yintercept = 1,color = "black")+
  scale_y_continuous(trans="log")+
  ylab("Lasso HR")+
  ggtitle("DFS")+
  theme_classic()+
  scale_color_manual(values = metadata(sce)$colors$cluster_110, limits = force, na.value = "black")
```

# 5. Image visualization

```{r load images, message = FALSE}
#Load images and masks
images <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/images_segtest.rds")
masks <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/masks_segtest_4.rds")
```

## Visualize metaclusters on images 

```{r viz clus, message=FALSE, warning=FALSE}
clus_select <- unique(sce$metacluster)

library(doParallel)
registerDoParallel(cores = 7)

foreach(i = clus_select)%dopar%{

##Visualize clusters on images - select 10 images for each category with highest number of cells
cur_sample <- colData(sce) %>% as.data.frame %>% group_by(metacluster) %>% filter(metacluster == i) %>% count(sample_id) %>% arrange(desc(n)) %>% slice(1:10) %>% pull(sample_id)

#Prepare images
cur_images <- images[cur_sample]
cur_images <- cytomapper::normalize(cur_images, separateImages = TRUE)
cur_images <- cytomapper::normalize(cur_images, inputRange = c(0, 0.2))

#Subset sce
cur_sce <- sce[,sce$metacluster == i]

#Plot 
plotPixels(cur_images,
           mask = masks[cur_sample],
           object = cur_sce,
           img_id = "sample_id",
           cell_id = "ObjectNumber",
           missing_colour = "white",
           outline_by = "metacluster",
           colour_by = c("CK5","Vimentin","CK7","CD15","EGFR","KRT14"),
           thick = FALSE,
           image_title = NULL,
           legend = list(colour_by.title.cex = 0.7,
                         colour_by.labels.cex = 0.7),
           save_plot = list(filename = paste0("/mnt/rcc_volume/TNBC/data_analysis/01_figures/Tumor_clusters_viz/Tumor_viz_metacluster_",i,".png"), scale = 2)
           )
 
  }

```


## Visualize metaclusters on images

```{r viz metaclus, message=FALSE, warning=FALSE}

# 1. Part 1 of immune_metacluster viz 
clus_select <- anno %>% filter(!metacluster %in% c("Endothelial","Stromal","Neutrophil")) %>% pull(metacluster) %>% unfactor()

for (i in clus_select) {
  
##Visualize clusters on images - select 10 images for each category with highest number of cells
cur_sample <- colData(sce) %>% as.data.frame %>% group_by(immune_metacluster) %>% filter(immune_metacluster == i) %>% count(sample_id) %>% arrange(desc(n)) %>% slice(1:10) %>% pull(sample_id)

#Prepare images
cur_images <- images[cur_sample]
cur_images <- cytomapper::normalize(cur_images, separateImages = TRUE)
cur_images <- cytomapper::normalize(cur_images, inputRange = c(0, 0.2))

#Subset sce
cur_sce <- sce[,sce$immune_metacluster == i]

#Plot 
plotPixels(cur_images,
           mask = masks[cur_sample],
           object = cur_sce,
           img_id = "sample_id",
           cell_id = "ObjectNumber",
           missing_colour = "white",
           outline_by = "cluster_130",
           colour_by = c("CD4", "HLADR", "CD68","CD8a", "CD20","CD3"),
           #colour = list("SMA" = c("black", "green"),
           #              "CD3" = c("black", "yellow"),
           #              "CD31_vWF" = c("black", "magenta"),
           #              "CD20" = c("black", "cyan"),
           #              "CD68" = c("black", "red"),
           #              "cluster_130" = metadata(test_sce)$colors$cluster_130
           #              ),
           thick = FALSE,
           image_title = NULL,
           legend = list(colour_by.title.cex = 0.7,
                         colour_by.labels.cex = 0.7),
           save_plot = list(filename = paste0("/mnt/rcc_volume/TNBC/data_analysis/01_figures/TME_clusters_viz/TME_viz_immune_metacluster_",i,".png"), scale = 2)
           )
 
  }


# 2. Part 2 of immune_metacluster viz 

clus_select <- anno %>% filter(metacluster %in% c("Endothelial","Stromal","Neutrophil")) %>% pull(metacluster) %>% unfactor()

for (i in clus_select) {
  
##Visualize clusters on images - select 10 images for each category with highest number of cells
cur_sample <- colData(sce) %>% as.data.frame %>% group_by(immune_metacluster) %>% filter(immune_metacluster == i) %>% count(sample_id) %>% arrange(desc(n)) %>% slice(1:10) %>% pull(sample_id)

#Prepare images
cur_images <- images[cur_sample]
cur_images <- cytomapper::normalize(cur_images, separateImages = TRUE)
cur_images <- cytomapper::normalize(cur_images, inputRange = c(0, 0.2))

#Subset sce
cur_sce <- sce[,sce$immune_metacluster == i]

#Plot 
plotPixels(cur_images,
           mask = masks[cur_sample],
           object = cur_sce,
           img_id = "sample_id",
           cell_id = "ObjectNumber",
           missing_colour = "white",
           outline_by = "cluster_130",
           colour_by = c("CD31_vWF", "SMA", "CD68","CD15", "CD20","CD3"),
           #colour = list("SMA" = c("black", "green"),
           #              "CD3" = c("black", "yellow"),
           #              "CD31_vWF" = c("black", "magenta"),
           #              "CD20" = c("black", "cyan"),
           #              "CD68" = c("black", "red"),
           #              "cluster_130" = metadata(test_sce)$colors$cluster_130
           #              ),
           thick = FALSE,
           image_title = NULL,
           legend = list(colour_by.title.cex = 0.7,
                         colour_by.labels.cex = 0.7),
           save_plot = list(filename = paste0("/mnt/rcc_volume/TNBC/data_analysis/01_figures/TME_clusters_viz/TME_viz_immune_metacluster_",i,".png"), scale = 2)
           )
 
  }
```

## Save sce objects

```{r save_objects, message = FALSE, warning=FALSE}
#Save sce
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/05_sce_TNBC_tumor_new.rds")
```

## Save plots as pdf

```{r save_plots}
##IMPORTANT: change to chunk output in console for this last part 

##save plots as pdf (vector graphics)
pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_ClusterTesting.pdf",width = 10,height = 5)
p1+p2+p3
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_Silhouette_Cluster100.pdf",width = 12,height = 10)
p4
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/05_tumor/TNBC_Tumor_Heatmap_Cluster_Metacluster.pdf",width = 14,height = 9)
h
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_HeatmapCluster_Scales.pdf",width = 20,height = 8)
h_exprs+h_min_max
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_ClusterAnno.pdf",width = 5,height = 8)
h_cluster_anno
dev.off()

pdf("/Volumes/rcc_volume/TNBC/data_analysis/01_figures/06_tumor//TNBC_249_Tumor_CC_HeatmapCluster_subcells.pdf",width = 10,height = 8)
dittoHeatmap(sce_sub, 
             genes = rownames(sce_sub)[rowData(sce_sub)$cluster_channel],
             assay = "min_max", 
             scale = "none", 
             order.by = "cluster_100", 
             heatmap.colors = viridis(100), 
             annot.by = c("cluster_100"),
             annot.colors=col_clusters$cluster_100[order(as.numeric(names(col_clusters$cluster_100)))])
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_ExpressionCor.pdf",width = 10,height = 8)
corrplot(cor(cor_sce,method = "spearman"), method="color", col=brewer.pal(n=8, name="RdBu"),  
         type="upper", order="hclust",hclust.method = "ward.D2", 
         addCoef.col = "black", addCoefasPercent = F,# Add coefficient of correlation
         tl.col="black", tl.srt=40, #Text label color and rotation
         # Combine with significance
         #p.mat = p.mat, sig.level = 0.01, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag=F
)
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_TSNECluster_Metacluster.pdf",width = 12,height = 6)
TSNE_clus+TSNE_metaclus
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_TSNEExpression.pdf",width = 12,height = 6)
exp_plots_TSNE
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_UMAPExpression.pdf",width = 12,height = 6)
exp_plots_UMAP
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_MetaClusterPID.pdf",width = 10,height = 10)
p_clusterPID/p_metaclusterPID
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_PIDMetaCluster_ClusterCor.pdf",width = 12,height = 10)
(p_PID_cluster+SID_cluster_cor_plot)/
(p_PID_metacluster + SID_metacluster_cor_plot)
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/05_tumor/TNBC_Tumor_Meta_HR_OS.pdf",width = 8,height = 7)
hr_prop/
hr_mean
dev.off()


pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/05_tumor/TNBC_Tumor_MC4_KaplanMeier_OS.pdf",width = 6,height = 6, onefile = FALSE)
p1
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_ClusterMeta_HR_DFS.pdf",width = 10,height = 8)
hr_prop/
hr_cat/
hr_cat_GMM
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_Heatmap_metaClus_PIDgroups.pdf",width = 8,height = 8)
h_g_meta
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_Heatmap_Clus_PIDgroups.pdf",width = 8,height = 8)
h_g_clus
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_HeatmapPIDgroups_mean.pdf",width = 11,height = 7)
h_g_rich
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_HeatmapPIDgroupsCLR.pdf",width = 11,height = 7)
h_g_1
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_HeatmapPIDgroupsCLR_mean.pdf",width = 11,height = 7)
h_g_rich_clr
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_PIDgroups_Clus_OS.pdf",width = 8,height = 5)
plot_OS
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/06_tumor/TNBC_249_Tumor_CC_PIDgroups_Clus_DFS.pdf",width = 8,height = 5)
plot_DFS
dev.off()


##IMPORTANT: change back to chunk output inline
```



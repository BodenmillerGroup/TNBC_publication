---
title: "09_combined_spatial"
author: "Lasse Meyer"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Software requirements

```{r lib, message=FALSE,warning=FALSE}
#Data containers
library(SpatialExperiment)
library(SingleCellExperiment)

#Data processing
library(scuttle)
library(scater)
library(scran)
library(imcRtools)

#Data visualization
library(cytomapper)
library(dittoSeq)
library(pheatmap)
library(cowplot)
library(ComplexHeatmap)
library(circlize)

#Utilities
library(tidyverse)
library(openxlsx)
library(stringr)
library(patchwork)
library(parallel)
library(BiocParallel)
library(BiocNeighbors)
library(BiocSingular)
library(tiff)
library(ggrepel)
library(EBImage)
library(viridis)
library(mclust)
library(Rphenograph)
library(igraph)
library(RColorBrewer)
library(foreach)
library(clValid)
library(bluster)
library(psych)
library(corrplot)
library(psych)

#Batch correction
library(batchelor)
```

Here, we will attend to perform analysis akin to what has been proposed as **Tissue schematics (TS)** by Bhate et al., Cell Systems, 2022.

### 1. Cellular neighborhoods 

First, we will find cellular neighborhoods based on all cell type clusters (metaclusters) - "Tumor ecosystem communities"

To this end, we will define cellular neighborhoods by clustering cells based on cell type composition of their k-nearest neighbors. (k=20, euclidian distance between X/Y)


```{r neighborhood-1, message=FALSE, warning=FALSE}
library(imcRtools)
library(bluster)

##Load sce and colors
sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_249_08.rds")
col_clusters <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/color_phenocombined.rds")
sce

# Build 10-nearest neighbor graph (max distance between neighbors 30 um)
sce <- buildSpatialGraph(sce, img_id = "sample_id", type = "knn", k = 10, 
                             coords = c("Pos_X",  "Pos_Y"), max_dist = 30,
                         BPPARAM = MulticoreParam(progressbar = TRUE))

colPairNames(sce) #now includes knn_interaction_graph

# Aggregate across neighbors
sce <- aggregateNeighbors(sce, colPairName = "knn_interaction_graph", 
                              aggregate_by = "metadata", count_by = "metacluster_TME")

head(sce$aggregatedNeighbors)

# Perform cluster sweep for kmeans (silhouette width, wcss)
set.seed(22)
clust_list <- lapply(2:20, function(k){
  cur_km <- kmeans(sce$aggregatedNeighbors, centers = k)
  return(list(wss = sum(cur_km$withinss),
           clusters = cur_km$cluster))
})

sil <- vapply(lapply(clust_list, `[[`, 2), 
              function(x) mean(approxSilhouette(sce$aggregatedNeighbors, x)$width), 
              0)

ggplot(data.frame(k = 2:20, sil = sil))+
  geom_point(aes(k, sil, col = sil))+
  geom_line(aes(k, sil,col=sil))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  xlab("k")+
  ylab("Mean silhouette width")+
  scale_color_continuous(type = "viridis")

ggplot(data.frame(k = 2:20,wss = unlist(lapply(clust_list, `[[`, 1))))+
  geom_point(aes(k, wss, col = wss))+
  geom_line(aes(k, wss, col = wss))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("k")+
  ylab("Total WCSS")+
  scale_color_continuous(type = "viridis")

# Select 11 clusters
cur_clusters <- kmeans(sce$aggregatedNeighbors, centers = 11, nstart = 100)$cluster

sce$cellular_neighborhood <- as.factor(cur_clusters)

##Save sce 
#saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_249_08.rds")
```

We can now visualize a few example images and highlight the type of cells within each neighborhoood.

```{r neighborhood-2, fig.width=15, fig.height=12}
set.seed(22)
cur_sam <- sample(unique(sce$sample_id), 6)

plotSpatial(sce[,sce$sample_id %in% cur_sam], 
            img_id = "sample_id",
            coords = c("Pos_X", "Pos_Y"),
            node_color_by = "cellular_neighborhood",
            draw_edges = TRUE,
            colPairName = "knn_interaction_graph", 
            nodes_first = FALSE,
            directed = FALSE)+
  scale_color_brewer(palette = "Set3")+
  theme_classic()

colPairNames(sce)

plotSpatial(sce[,sce$sample_id %in% cur_sam], 
            img_id = "sample_id",
            coords = c("Pos_X", "Pos_Y"),
            node_color_by = "cluster_combined",
            node_shape_by = "cluster_origin",
            draw_edges = TRUE,
            directed = FALSE,
            colPairName = "knn_interaction_graph", 
            nodes_first = FALSE) +
  scale_color_manual(values = col_clusters$cluster_combined)+
  theme_classic()
```

```{r}
# Visualize cell type proportions of cellular neighborhoods
cn_prop <- table(cellular_neighborhood = sce$cellular_neighborhood,metacluster_TME = sce$metacluster_TME) %>% as.data.frame %>% group_by(cellular_neighborhood) %>% mutate(fra = Freq/sum(Freq))

## 1. Heatmap body
cn_prop_wide <- cn_prop %>% pivot_wider(id_cols = cellular_neighborhood, names_from = metacluster_TME, values_from = fra) %>% column_to_rownames(var = "cellular_neighborhood")

#Option: min_max normalization per neighborhood
cn_prop_wide <- as.matrix(cn_prop_wide)
cn_prop_wide_min_max <- (cn_prop_wide - rowMins(cn_prop_wide))/(rowMaxs(cn_prop_wide)-rowMins(cn_prop_wide))

#Heatmap body color
col_main = viridis(100)

## 2. Row annotation - number of cells/PID
cluster_PID <- colData(sce) %>% as.data.frame() %>% select(cellular_neighborhood,PID) %>% group_by(cellular_neighborhood) %>% table() %>% as.data.frame
n_PID <- cluster_PID %>% filter(Freq>0) %>% group_by(cellular_neighborhood) %>% count(name = "n_PID") %>% column_to_rownames("cellular_neighborhood")
ncells <- colData(sce) %>% as.data.frame() %>% select(cellular_neighborhood) %>% group_by(cellular_neighborhood) %>% count() 

row_anno <- cbind(n_PID,ncells)

#check and correct order
row_anno <- row_anno[match(rownames(cn_prop_wide),row_anno$cellular_neighborhood),]

## 3. Column annotation 
col_anno <- colData(sce) %>% as.data.frame() %>% select(metacluster_TME,metacluster) %>% unique()
col_anno$metacluster_TME <- as.character(col_anno$metacluster_TME)
col_anno$metacluster <- as.character(col_anno$metacluster)

#check and correct order
col_anno <- col_anno[match(colnames(cn_prop_wide),col_anno$metacluster_TME),]


col_ha <- HeatmapAnnotation(metacluster_TME = col_anno$metacluster_TME,
                            metacluster = col_anno$metacluster,
                  #col = col_clusters, 
                  border = TRUE, 
                  na_col = "black",
                  annotation_name_side = "left")

## 4. Plot heatmap
h <- Heatmap(cn_prop_wide_min_max,
             name = "min_max cluster proportion",
        col = col_main, 
        bottom_annotation = col_ha)+
  rowAnnotation(neighborhood = anno_simple(unfactor(row_anno$cellular_neighborhood),pch = unfactor(row_anno$cellular_neighborhood), border = TRUE))+
  rowAnnotation(n_PID = anno_barplot(n_PID, width = unit(10, "mm"),gp = gpar(fill = "#440154FF"), col = 1),annotation_name_rot = 90)+
  rowAnnotation(n_cells = anno_barplot(ncells$n, width = unit(10, "mm"),gp = gpar(fill = "#440154FF"), col = 1),annotation_name_rot = 90)

draw(h)
```


### 2. Spatial contexts

First, we will find spatial contexts based on cellular neighborhoods - "Micro-environments of CN"

To this end, we will define spatial contexts for each cell by the frequency of cellular neighborhood assigments in the cell neighborhood (k=50). We will then use a minimal combination of CN assignments for each window (>90% of cells are assigned to a given CN combination). 


```{r neighborhood-1, message=FALSE, warning=FALSE}
library(imcRtools)
library(bluster)

sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_249_08.rds")

#Subset sce
set.seed(22)
cur_sam <- sample(unique(sce$sample_id),50)
sce <- sce[,sce$sample_id %in% cur_sam]
sce

## 1. Build 50-nearest neighbor graph (max dist?)
sce <- buildSpatialGraph(sce, 
                         img_id = "sample_id", 
                         type = "knn", 
                         k = 50, 
                         max_dist = 30,
                         coords = c("Pos_X",  "Pos_Y"), 
                         name = "knn_spatialcontext_graph",
                         BPPARAM = MulticoreParam(progressbar = TRUE))

## 2. Aggregate across neighbors
sce <- aggregateNeighbors(sce, 
                          colPairName = "knn_spatialcontext_graph", 
                          aggregate_by = "metadata", 
                          count_by = "cellular_neighborhood")

## 3. Find spatial contexts using minimal combination approach
sce <- detectSpatialContext(sce, 
                            threshold = 0.9, 
                            entry = "aggregatedNeighbors",
                            name = "spatial_context")

#Filter abundant spatial context
data <- colData(sce) %>% as.data.frame %>% select(spatial_context, sample_id) %>% table() %>% as.data.frame
anno <- data.frame(spatial_context = data %>% group_by(spatial_context) %>% summarise(sum = sum(Freq)) %>% pull(spatial_context), 
                   Freq = data %>% group_by(spatial_context) %>% summarise(sum = sum(Freq)) %>% pull(sum), 
                   n_samples = data %>% group_by(spatial_context) %>% filter(Freq != 0) %>% count() %>% pull(n))

sc_select <- anno %>% filter(Freq > 200 & n_samples > 5) %>% pull(spatial_context) %>% unfactor()       

cur_sce <- sce[,sce$spatial_context %in% sc_select]

## 4. Build edgelist for plotting
edges <- buildSpatialContextEdgeList(cur_sce, 
                            entry = "spatial_context", 
                            img_id = "sample_id", 
                            combined = TRUE)

## 5. Plot spatial context graphs
plotSpatialContext(edges = edges,
                   object = cur_sce, 
                   entry = "spatial_context",
                   img_id = "sample_id",
                   combined = TRUE,
                   directed = TRUE,
                   node_color_by = "name",
                   node_size_by = "Freq",
                   node_label_color_by = "name"
                   )

#debug(buildSpatialContextEdgeList)
#undebug(buildSpatialContextEdgeList)


##Save sce 
#saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_249_08.rds")
```


# Visualize spatial contexts on example images 

```{r neighborhood-2}
cur_sce <- sce[, sce$sample_id == "ZTMA249.1_ZTMA249_ID_305_CX1Y9_68"]
cur_sce

#by cell types (clusters)
p1 <- plotSpatial(cur_sce, 
            img_id = "sample_id",
            coords = c("Pos_X", "Pos_Y"),
            node_color_by = "cluster_combined",
            draw_edges = FALSE,
            colPairName = "knn_interaction_graph", 
            nodes_first = FALSE,
            node_size_fix = 2,
            node_shape_by = "analysis_cat",
            directed = FALSE)+
  theme_classic()

p1

#by cellular neighborhoods
p2 <- plotSpatial(cur_sce, 
            img_id = "sample_id",
            coords = c("Pos_X", "Pos_Y"),
            node_color_by = "cellular_neighborhood",
            draw_edges = FALSE,
            colPairName = "knn_interaction_graph", 
            nodes_first = FALSE,
            node_size_fix = 2,
            node_shape_by = "analysis_cat",
            directed = FALSE)+
  theme_classic()

#by spatial contexts
p3 <- plotSpatial(cur_sce, 
            img_id = "sample_id",
            coords = c("Pos_X", "Pos_Y"),
            node_color_by = "spatial_context",
            draw_edges = FALSE,
            colPairName = "knn_spatialcontext_graph", 
            nodes_first = FALSE,
            node_size_fix = 2,
            node_shape_by = "analysis_cat",
            directed = FALSE)+
  theme_classic()

p1/p2/p3
```

```{r viz spatial contexts}
## 1. Total number of cells in spatial context
SC_count <- colData(sce) %>% as.data.frame %>% select(spatial_context) %>% group_by(spatial_context) %>% count() %>% arrange(desc(n))

## 2. Fraction of sample_id per spatial
SC_SID <- colData(sce) %>% as.data.frame() %>% select(spatial_context,sample_id) %>% group_by(spatial_context) %>% table() %>% as.data.frame
SC_SID <- SC_SID %>% group_by(spatial_context) %>% mutate(fra = Freq/sum(Freq))

ggplot(SC_SID) +
  geom_tile(color = "black",aes(spatial_context, fra, fill = sample_id), position = "stack")+
  theme_classic(base_size = 15)+
  ylab("SID fraction")+
  theme(axis.title.x = element_blank())+
  guides(fill = "none")

## 3. Fraction of spatial context per PID
SID_SC <- colData(sce) %>% as.data.frame() %>% select(spatial_context,sample_id) %>% group_by(sample_id) %>% table() %>% as.data.frame
SID_SC <- SID_SC %>% group_by(sample_id) %>% mutate(fra = Freq/sum(Freq))

ggplot(SID_SC) +
  geom_tile(color = "black",aes(sample_id, fra, fill = spatial_context), position = "stack")+
  theme_classic(base_size = 15)+
  ylab("SC Fraction")+
  xlab("Sample_ID")+
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())+
  guides(fill = FALSE)


#TO DO: Find filter criteria for abundant spatial contexts - Make workflow more efficient/faster (talk to Nils)
```

```{r cn comb map}
#Plot CN combination map from each sample_id 

##1. Create edgelist for spatial contexts based on either all samples or for each sample separately
## Use self-build function

edges <- buildSpatialContextEdgeList(sce, 
                         entry = "spatial_context",
                         img_id = "sample_id",
                         combined = TRUE)

#debug(buildSpatialContextEdgeList)
#undebug(buildSpatialContextEdgeList)
```


```{r plotspatialcontextgraph}

## 2. Create graph from edgelist using igraph and ggnetwork

source("../code/helper_functions.R")
source("../code/hidden_functions.R")
source("../code/validity_checks.R")

#spatial context abundance filter criteria - important - to be added in function? 
anno <- anno %>% filter(sum > 25 & n_samples > 2)
sc_fil <- unfactor(anno$spatial_context)
edges <- edges %>% filter(from %in% sc_fil & to %in% sc_fil)


plotSpatialContext(edges = edges, 
                   object = sce, 
                   combined = TRUE, 
                   entry = "spatial_context",
                   img_id = "sample_id",
                   directed = TRUE,
                   node_color_by = "name",
                   node_size_by = "n_samples",
                   node_label_repel = TRUE,
                   node_label_color_by = "name"
                   )

#debug(plotSpatialContext)
#undebug(plotSpatialContext)

```
### 3. Interaction testing

```{r interaction testing}
library(imcRtools)
library(circlize)

#Load sce
sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_249_08.rds")

#subset sce to 50 images for time reasons 
set.seed(22)
cur_sam <- sample(unique(sce$sample_id),30)
sce <- sce[,sce$sample_id %in% cur_sam]

# test interaction - see histocat for details (counting method = classic)
out <- testInteractions(sce,
                        group_by = "sample_id",
                        label = "cluster_combined",
                        method = "classic",
                        colPairName = "knn_interaction_graph", 
                        BPPARAM = MulticoreParam())

out <- as.data.frame(out)

## Create heatmaps from interaction testing
col_fun = colorRamp2(c(0.0, 0.1, 0.3,0.5, 0.7), c("#440154FF", "#3C4F8BFF","#238C8DFF", "#4DC36BFF", "#E4E419FF"))

# 1. Significant interaction
sig_int <- out %>% filter(sig == TRUE & interaction == TRUE) %>% select(from_label, to_label, group_by) %>% group_by(from_label, to_label) %>% count()
sig_int_h <- sig_int %>% mutate(fraction_sig = n/length(unique(out$group_by))) %>% arrange(desc(fraction_sig)) %>% pivot_wider(id_cols = from_label, names_from = to_label, values_from = fraction_sig) %>% column_to_rownames("from_label")
sig_int_h[is.na(sig_int_h)] <- 0

h_int <- Heatmap(sig_int_h,
        name = "% images with sign. interaction",
        col = col_fun, 
        row_title = "cluster (from)",
        row_names_side = "left",
        row_title_side = "left",
        row_dend_side = "right",
        column_title = "neighboring cluster (to)",
        column_title_side = "bottom")
h_int

# 2. Significant avoidance
sig_avo <- out %>% filter(sig == TRUE & interaction == FALSE) %>% select(from_label, to_label, group_by) %>% group_by(from_label, to_label) %>% count()
sig_avo_h <- sig_avo %>% mutate(fraction_sig = n/length(unique(out$group_by))) %>% arrange(desc(fraction_sig)) %>% pivot_wider(id_cols = from_label, names_from = to_label, values_from = fraction_sig) %>% column_to_rownames("from_label")
sig_avo_h[is.na(sig_avo_h)] <- 0

h_avo <- Heatmap(sig_avo_h,
        name = "% images with sign. avoidance",
        col = col_fun, 
        row_title = "cluster (from)",
        row_names_side = "left",
        row_title_side = "left",
        row_dend_side = "right",
        column_title = "neighboring cluster (to)",
        column_title_side = "bottom")
h_avo


# 3. Combined interaction/avoidance
sig_comb <- out %>% filter(!is.na(interaction)) %>% select(group_by,from_label, to_label, interaction, sigval) %>% group_by(from_label, to_label) %>% summarise(sum = sum(sigval)) #create sum of sigval (final summary of whether more interaction or avoidance occurs)

sig_comb_h <- sig_comb %>% mutate(fraction_sig = sum/length(unique(out$group_by))) %>% pivot_wider(id_cols = from_label, names_from = to_label, values_from = fraction_sig) %>% column_to_rownames("from_label")

sig_comb_h[is.na(sig_comb_h)] <- 0 #replace na with 0

range(sig_comb_h) #check range, can be used for color mapping

#column anno
col_ha <- HeatmapAnnotation(
  clusters_combined = anno_simple(colnames(sig_comb_h),border=TRUE,col=col_clusters$cluster_combined),
  clusters_combined = anno_text(colnames(sig_comb_h)),
  which = "column",
  show_annotation_name = FALSE
)

#Plot heatmap
rowAnnotation(clusters_combined = anno_text(rownames(sig_comb_h), just = "left"))+
rowAnnotation(clusters_combined = anno_simple(rownames(sig_comb_h),border=TRUE,col=col_clusters$cluster_combined),show_annotation_name = FALSE)+
Heatmap(sig_comb_h,
        name = "% images with sign. interaction",
        row_title = "cluster (from)",
        row_names_side = "left",
        row_title_side = "right",
        row_dend_side = "right",
        column_title = "neighboring cluster (to)",
        column_title_side = "top", 
        bottom_annotation = col_ha
        )
  

#Option: ordered
rowAnnotation(clusters_combined = anno_text(rownames(sig_comb_h), just = "left"))+
rowAnnotation(clusters_combined = anno_simple(rownames(sig_comb_h),border=TRUE,col=col_clusters$cluster_combined),show_annotation_name = FALSE)+
  Heatmap(sig_comb_h,
        name = "% images with sign. interaction", 
        row_title = "cluster (from)",
        row_order = rownames(sig_comb_h),
        column_order = rownames(sig_comb_h),
        row_names_side = "left",
        row_title_side = "right",
        #row_dend_side = "right",
        column_title = "neighboring cluster (to)",
        column_title_side = "top",
        bottom_annotation = col_ha)

h_comb_ord
```

### 4. Patch detection
Try patch/milieu detection method for TnB cell patches.

```{r patch}
#Load sce
sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_249_08.rds")

#subset sce to 30 images with most TnB cells
cur_sam <- colData(sce) %>% as.data.frame %>% select(sample_id, cluster_combined) %>% filter(cluster_combined == "TME_13") %>% group_by(cluster_combined) %>% count(sample_id) %>% arrange(desc(n)) %>% slice(1:30) %>% pull(sample_id)
sce <- sce[,sce$sample_id %in% cur_sam]
sce

colPairNames(sce)

##1. Patch detection
sce <- patchDetection(sce,
               patch_cells = sce$cluster_combined == "TME_13",
               colPairName = "knn_interaction_graph",
               min_patch_size = 20,
               name = "patch_TME13",
               expand_by = 0, 
               img_id = "sample_id")

##2. Milieu detection ("expanded" patch)
sce <- patchDetection(sce,
               patch_cells = sce$cluster_combined == "TME_13",
               colPairName = "knn_interaction_graph",
               min_patch_size = 20,
               name = "milieu_TME13",
               expand_by = 30, 
               img_id = "sample_id")

#Visualize
plotSpatial(sce[,sce$sample_id %in% cur_sam[1:3]], img_id = "sample_id", node_color_by = "cluster_combined")+
  scale_color_manual(values = col_clusters$cluster_combined) #Cell Types
plotSpatial(sce[,sce$sample_id %in% cur_sam[1:3]], img_id = "sample_id", node_color_by = "patch_TME13") #Patch
plotSpatial(sce[,sce$sample_id %in% cur_sam[1:3]], img_id = "sample_id", node_color_by = "milieu_TME13") #Milieu

unique(sce$patch_TME13)
unique(sce$milieu_TME13)
```

```{r milieu enrich}
## Milieu enrichment analysis

#Number of milieus per image
milieu_image <- colData(sce) %>% as.data.frame %>% select(sample_id, milieu_TME13) %>% group_by(sample_id) %>% unique() %>% count()

##TO DO: write another for loop for each cluster in neighborhood - optional write loop for each different milieu (here only TME_13) - see Nils code

milieu_test <- colData(sce) %>% as.data.frame %>% select(sample_id, cluster_combined, milieu_TME13) %>% filter(cluster_combined != "TME_13") %>% group_by(sample_id) %>% 
  summarise(inside = sum(cluster_combined == "TME_1" & !is.na(milieu_TME13)),
            outside = sum(cluster_combined == "TME_1" & is.na(milieu_TME13)),
            other_inside = sum(cluster_combined != "TME_1" & !is.na(milieu_TME13)),
            other_outside = sum(cluster_combined != "TME_1" & is.na(milieu_TME13)))

milieu_final <- foreach(i = seq_along(rownames(milieu_test)), .combine = "rbind")%do%{
cur_mat <- matrix(as.numeric(as.vector(milieu_test[i,2:5])),ncol = 2, nrow = 2, byrow = FALSE)
rownames(cur_mat) <- c("cluster", "other_cluster")
colnames(cur_mat) <- c("inside", "outside")

cur_test <- fisher.test(cur_mat)

milieu_final <- data.frame(
  sample = as.character(as.vector(milieu_test[i,1])),
  milieu = "TME_13",
  p = cur_test$p.value,
  odds = cur_test$estimate,
  row.names = NULL
)

milieu_final 
}


## Code from Science Immunology paper

cur_res_list <- list()
cur_df <- colData(sce)
# Set thresholds
perc_cells <- 0

# We remove ccl8, ccl4 and ccl22 due to few images with milieus
for (i in c("ccl18_pure", "cxcl8_pure", "cxcl10_pure",
            "cxcl12_pure", "cxcl13_pure", "ccl2_pure",
            "cxcl9_pure", "ccl19_pure")) {
    
    cur_perc <- cur_df %>% 
        as.data.frame() %>% 
        group_by(ImageNumber) %>%
        dplyr::summarize(perc_cells = sum(!!sym(i) != 0)/n())
    
    cur_chemo <- toupper(sub("_pure", "", i))
    for (j in unique(cur_df$celltype)) {
        cur_res <- cur_df %>% 
            as.data.frame() %>%
            filter(ImageNumber %in% cur_perc$ImageNumber[cur_perc$perc_cells > perc_cells]) %>%
            filter(!(!!sym(cur_chemo) == 1 & celltype == j)) %>%
            group_by(ImageNumber) %>%
            dplyr::summarize(celltype_inside = sum(celltype == j & !!sym(i) != 0),
                      other_inside = sum(celltype != j & !!sym(i) != 0),
                      celltype_outside = sum(celltype == j & !!sym(i) == 0),
                      other_outside = sum(celltype != j & !!sym(i) == 0))
        
        if (nrow(cur_res) == 0) {
            next
        }
        
        cur_tests <- as.data.frame(t(apply(as.matrix(cur_res), 1, function(x){
            cur_mat <- matrix(x[2:5], ncol = 2, nrow = 2, byrow = FALSE)
            rownames(cur_mat) <- c("celltype", "other")
            colnames(cur_mat) <- c("inside", "outside")
            
            cur_test <- fisher.test(cur_mat)
            
            c(cur_test$p.value, cur_test$estimate)
        })))
        
        colnames(cur_tests)[1] <- "p.value"
        cur_tests$adj.p <- p.adjust(cur_tests$p.value, method = "BH")
        
        cur_tests$community <- i 
        cur_tests$celltype <- j
        cur_tests$ImageNumber <- cur_res$ImageNumber
        
        cur_res_list[[paste0(i, "_", j)]] <- cur_tests
    }
}

out <- do.call("rbind", cur_res_list)
out$adj.p.all <- p.adjust(out$p.value, method = "BH")
final <- out %>% mutate(sigval = ifelse(`odds ratio` > 1 & adj.p.all < 0.1, 1, 
                                        ifelse(`odds ratio` < 1 & adj.p.all < 0.1, -1, 0))) %>%
    group_by(community, celltype) %>%
    dplyr::summarize(mean = mean(sigval))

# Number of tested images
out %>% 
  group_by(community, celltype) %>% 
  dplyr::summarize(count = n()) %>% 
  as.data.frame()



## My old code: 

#Add fisher exact test values
fisher_table_GOI <- GOI_mutations_metVSprim_1  %>% 
  dplyr::select(n_mut_met,n_mut_prim) %>% 
  mutate(n_notmut_met = (length(unique(cnv_snv_comb_filtered_met$PID_old))-n_mut_met)) %>%
  mutate(n_notmut_prim = (length(unique(cnv_snv_comb_filtered_prim$PID_old))-n_mut_prim))

GOI_mutations_metVSprim_1$fisher_test <- 0

for (i in 1:nrow(fisher_table_GOI)) {
  m <- matrix(unlist(fisher_table_GOI[i,]),nrow=2)
  fisher_result <- fisher.test(m)
  GOI_mutations_metVSprim_1$fisher_test[i] <- fisher_result$p.value
}

##Questions: How are patch ID/milieu IDs defined?

cluster_SID <- colData(sce) %>% as.data.frame() %>% select(cluster_100,sample_id) %>% group_by(cluster_100) %>% table() %>% as.data.frame


```










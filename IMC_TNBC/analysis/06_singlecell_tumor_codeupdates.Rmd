---
title: "06_singlecell_tumor"
author: "Lasse Meyer"
date: "4/1/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Software requirements

```{r lib, message=FALSE,warning=FALSE}
#Data containers
library(SpatialExperiment)
library(SingleCellExperiment)

#Data processing
library(scuttle)
library(scater)
library(scran)
library(imcRtools)

#Data visualization
library(cytomapper)
library(dittoSeq)
library(pheatmap)
library(cowplot)
library(ComplexHeatmap)

#Utilities
library(tidyverse)
library(openxlsx)
library(stringr)
library(patchwork)
library(parallel)
library(BiocParallel)
library(BiocNeighbors)
library(BiocSingular)
library(tiff)
library(ggrepel)
library(EBImage)
library(viridis)
library(mclust)
library(Rphenograph)
library(igraph)
library(RColorBrewer)
library(foreach)
library(clValid)

#Batch correction
library(batchelor)
#library(harmony)
```

# Single-cell analysis - Pipeline 2 - TNBC tumor phenotypes

Here, we will perform the second single cell analysis steps, including phenotyping tumor cells.

## Read in data and filter for ZTMA249
First, we will read in the `SingleCellExperiment` object containing the cleaned, spillover- and (batch-corrected) single-cell data. 
**Important:** For now, We will filter the object for ZTMA249 samples, since we are sure that those are TNBC. 

```{r read-data-batch-correction, message=FALSE}
sce <- readRDS("/Volumes/rcc_volume/TNBC/data_analysis/sce_TNBC_Clus_249.rds")
```

## Define markers for clustering
```{r tumor_markers, message = FALSE, warning = FALSE}
cluster_channel = c("CK5","CK8_18","CD15","KRT14","cMYC","HER2","ER","PR","p53","AR","GATA3","EGFR","p_mTOR","CK7","Vimentin","Ki67")

cell_state_channel = c("pH3","H3K27me3","Bcl2", "c_Cas3_PARP","S6","CD44")

other_immune_channel = c("panCK","Ecad","SMA","Fibronectin","CD68","CD3","CD68","CD20","HLA_DR","CD11c","CD45","CD20","CD8a","CD4","CD31_vWF")

#Add to sce
rowData(sce)$cell_state_channel <- (rowData(sce)$clean_target %in% cell_state_channel)
rowData(sce)$cluster_channel <- (rowData(sce)$clean_target %in% cluster_channel)
rowData(sce)$other_immune_channel <- (rowData(sce)$clean_target %in% other_immune_channel)
```

##Filter sce for tumor cells
based on panCK GMM

```{r filter sce, message=FALSE}
#based on GMM (n=327897)
sce <- sce[,colData(sce)$cluster_category %in% c("Epithelial","Mixed")]
sce
```

```{r overcluster, message=FALSE}
#1: for sce
## Subsample 10% of cells from each core 
#to save time and not get super crowded dimensionality reduction plots
set.seed(22011995)
sub <- colData(sce) %>% as.data.frame() %>% group_by("sample_id") %>% slice_sample(prop = 0.1) %>% arrange("sample_id") %>% mutate(sub_id = paste(sample_id,ObjectNumber,sep="_")) %>% pull(sub_id)
sce = sce[,sub]

#k=50
set.seed(22)
snn.sce <- buildSNNGraph(sce[rowData(sce)$cluster_channel==TRUE,], k=50, 
                         d = NA, 
                         type = "jaccard",
                         assay.type = "exprs",
                         BNPARAM=AnnoyParam(),
                         BPPARAM = MulticoreParam(workers = (detectCores()-2), progressbar = TRUE)
                         )

clusters_50 <- igraph::cluster_louvain(snn.sce)
sce$cluster_50 <- as.factor(clusters_50$membership)
unique(sce$cluster_50)

#k=75
set.seed(22)
snn.sce <- buildSNNGraph(sce[rowData(sce)$cluster_channel==TRUE,], k=75, 
                         d = NA, 
                         type = "jaccard",
                         assay.type = "exprs",
                         BNPARAM=AnnoyParam(),
                         BPPARAM = MulticoreParam(workers = (detectCores()-2), progressbar = TRUE)
                         )

clusters_75 <- igraph::cluster_louvain(snn.sce)
sce$cluster_75 <- as.factor(clusters_75$membership)
unique(sce$cluster_75)

#k=100
set.seed(22)
snn.sce <- buildSNNGraph(sce[rowData(sce)$cluster_channel==TRUE,], k=100, 
                         d = NA, 
                         type = "jaccard",
                         assay.type = "exprs",
                         BNPARAM=AnnoyParam(),
                         BPPARAM = MulticoreParam(workers = (detectCores()-2), progressbar = TRUE)
                         )

clusters_100 <- igraph::cluster_louvain(snn.sce)
sce$cluster_100 <- as.factor(clusters_100$membership)
unique(sce$cluster_100)

#k=125
set.seed(22)
snn.sce <- buildSNNGraph(sce[rowData(sce)$cluster_channel==TRUE,], k=125, 
                         d = NA, 
                         type = "jaccard",
                         assay.type = "exprs",
                         BNPARAM=AnnoyParam(),
                         BPPARAM = MulticoreParam(workers = (detectCores()-2), progressbar = TRUE)
                         )

clusters_125 <- igraph::cluster_louvain(snn.sce)
sce$cluster_125 <- as.factor(clusters_125$membership)
unique(sce$cluster_125)

#k=150
set.seed(22)
snn.sce <- buildSNNGraph(sce[rowData(sce)$cluster_channel==TRUE,], k=150, 
                         d = NA, 
                         type = "jaccard",
                         assay.type = "exprs",
                         BNPARAM=AnnoyParam(),
                         BPPARAM = MulticoreParam(workers = (detectCores()-2), progressbar = TRUE)
                         )

clusters_150 <- igraph::cluster_louvain(snn.sce)
sce$cluster_150 <- as.factor(clusters_150$membership)
unique(sce$cluster_150)
```

### Cluster stability testing and comparison

```{r clustree, message = FALSE, warning=FALSE}
#sce <- readRDS("/Volumes/rcc_volume/RCC/IMMUCAN/rcc_sce_BatchCombined_Clustered.rds")

#Pairwise rand index 
#Agreement between two clustering approaches - ARI > 0.5 = "good" similarity
library(bluster)
pairwiseRand(sce$cluster_50,sce$cluster_75, mode = "index")
pairwiseRand(sce$cluster_75,sce$cluster_100, mode = "index")
pairwiseRand(sce$cluster_100,sce$cluster_125, mode = "index")
pairwiseRand(sce$cluster_125,sce$cluster_150, mode = "index")


#Over different resolution parameters - Silhouette width [-1,1,max], Purity[0,1,max], Root-mean-squared difference [min]
clusters <- colnames(colData(sce))[str_detect(colnames(colData(sce)),"cluster_[:digit:]")]
df <- foreach(i = seq_along(clusters),.combine = rbind) %do% {
num_clus <- length(unique(colData(sce)[,clusters[i]]))
sil <- approxSilhouette(t(assay(sce, "exprs")), clusters=colData(sce)[,clusters[i]])
purity <- neighborPurity(t(assay(sce, "exprs")), clusters=colData(sce)[,clusters[i]])
data.frame(num_clus = num_clus,
           k = as.numeric(str_split(clusters[i],"_",simplify = TRUE)[,2]), 
           sil = mean(sil$width), 
           purity = mean(purity$purity))
}

gridExtra::grid.arrange(
  ggplot(df, aes(x=k, y=num_clus))+ 
  geom_line(lwd = 2,color = "#377EB8")+
  theme_classic(),
ggplot(df, aes(x=k, y=sil))+ 
  geom_line(lwd = 2,color = "#377EB8")+
  theme_classic(),
ggplot(df, aes(x=k, y=purity))+ 
  geom_line(lwd = 2,color = "#377EB8")+
  theme_classic(),
ncol=3
)

#Chosen method => k=125

#Cluster colors 
col_clus <- colorRampPalette(brewer.pal(9,"Paired"))(length(unique(sce$cluster_100)))

#By clusters for one method (here k=100)
#1. Silhouette width [-1,1]
#Clusters with large positive silhouette widths are well-separated from other clusters
sil.approx <- approxSilhouette(t(assay(sce, "exprs")), clusters=sce$cluster_100)
sil.data <- as.data.frame(sil.approx)
sil.data$closest <- factor(ifelse(sil.data$width > 0, sce$cluster_100, sil.data$other))
sil.data$cluster <- sce$cluster_100

ggplot(sil.data, aes(x=cluster, y=width, colour=closest)) +
    ggbeeswarm::geom_quasirandom(method="smiley")+
  theme_classic()+
  scale_color_manual(values = col_clus)

#By neighborpurity
pure.approx <- neighborPurity(t(assay(sce, "exprs")), clusters=sce$cluster_100)
pure.data <- as.data.frame(pure.approx)
pure.data$maximum <- factor(pure.data$maximum)
pure.data$cluster <- sce$cluster_100

ggplot(pure.data, aes(x=cluster, y=purity, colour=maximum)) +
    ggbeeswarm::geom_quasirandom(method="smiley")+
  theme_classic()+
  scale_color_manual(values = col_clus)


#Observation: Pay attention to cluster 6, 10, 11
```
## Add metadata to SCE object

```{r metadata addition, message=FALSE,warning=TRUE}
sample_meta <- read.csv("/Users/lasmey/Desktop/TNBC/Metadaten/ZTMA249_metadata_processed.csv")
colData(sce)$ID <- str_split(colData(sce)$sample_id,"_",simplify = TRUE)[,4]

#Add PID and lehmann_subtype
colData(sce)$PID <- sample_meta$PID[match(colData(sce)$ID,sample_meta$ID_Number)]
colData(sce)$lehmann_subtype <- sample_meta$lehmann_subtype[match(colData(sce)$ID,sample_meta$ID_Number)]

patient_meta <- read.csv("/Users/lasmey/Desktop/TNBC/Metadaten/ZTMA249_metadata_processed_byPID.csv")
#Add Grade
colData(sce)$grade <- patient_meta$grade[match(colData(sce)$PID,patient_meta$PID)]
```

## Heatmap 

Heatmap of clusters

```{r heatmap sce_1, message=FALSE,warning=FALSE}
#Read sce after clustering and GMM
#sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_Clus_249.rds")
# sce <- sce

### 1. Marker Heatmaps (Cluster channels, other_immune channels)

#Min-Max [0,1] normalization of arcsinh-transformed counts
assay(sce, "min_max") <- assay(sce, "exprs") - rowMins(assay(sce, "exprs"))
assay(sce, "min_max") <- assay(sce, "min_max") / (rowMaxs(assay(sce, "exprs")) - rowMins(assay(sce, "exprs")))

#Aggregrate across cells with the mean (median is also possible)
cluster_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_125,
                                 statistics = "mean",
                                 use.assay.type = "min_max",
                                 subset.row = rowData(sce)$cluster_channel)

cellstate_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_125,
                                 statistics = "mean",
                                 use.assay.type = "min_max",
                                 subset.row = rowData(sce)$cell_state_channel)

other_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_125,
                                 statistics = "mean",
                                 use.assay.type = "min_max",
                                 subset.row = rowData(sce)$other_immune_channel)

### 2. Spatial Heatmap
#Add number of neighbors to sce object (saved in ColPair)
n_neighbors <- colPair(sce) %>% as.data.frame() %>% group_by(from) %>% count() %>% arrange(desc(n))

sce$n_neighbors <- n_neighbors$n[match(seq_along(colnames(sce)),n_neighbors$from)]
sce$n_neighbors <- sce$n_neighbors %>% replace_na(0)

#Double-check 
p1 <- plotSpatial(sce[,colData(sce)$sample_id == "ZTMA249.1_ZTMA249_ID_1_AX1Y1_93"],img_id = "sample_id",colPairName = "neighborhood",draw_edges = FALSE, node_color_by = "n_neighbors",node_size_fix = 2)+
  scale_color_continuous(type = "viridis")+
  theme_classic()
p2 <- plotSpatial(sce[,colData(sce)$sample_id == "ZTMA249.1_ZTMA249_ID_1_AX1Y1_93"],img_id = "sample_id",colPairName = "neighborhood",draw_edges = TRUE, node_color_by = "GMM_CK")+
  scale_color_brewer(palette = "Set1")+
  theme_classic()
p1+p2

#Select spatial features and average over clusters 
spatial <- colData(sce) %>% as.data.frame %>% select(area,eccentricity,cluster_125,n_neighbors)
spatial <- spatial %>% select(-cluster_125) %>% aggregate(by = list(cluster_125 = spatial$cluster_125), FUN = mean) %>% column_to_rownames("cluster_125")
#define min_max fct
min_max_norm <- function(x) {(x - min(x)) / (max(x) - min(x))}
#normalize
spatial_norm <- as.data.frame(lapply(spatial, min_max_norm))


###3.  Define annotation dataframe with n cells, clusters, metaclusters
anno <- colData(cluster_mean_sce) %>% as.data.frame %>% select(cluster_125, ncells)

col <- list(cluster_125 = colorRampPalette(brewer.pal(9, "Paired"))(length(unique(anno$cluster_125))))

col_list_1 <- foreach(i=1:1) %do% {
  color= col[[i]]
  names(color)= sort(unique(anno[,names(col)[i]]))
  color
}
names(col_list_1) <- c(names(col))

###4. Patient metadata - grade / lehmann subtype

# Proportion of grade per cluster
grade <- colData(sce) %>% as.data.frame() %>% select(cluster_125,grade) %>% group_by(cluster_125) %>% table() %>% as.data.frame
grade <- grade %>% group_by(cluster_125) %>% mutate(fra = Freq/sum(Freq)) 
grade <- grade %>% select(-Freq) %>% pivot_wider(id_cols = cluster_125,names_from = grade,values_from = fra) %>% column_to_rownames("cluster_125")

# Proportion of lehmann subtype per cluster (as bubble plot)
subtype <- colData(sce) %>% as.data.frame() %>% select(cluster_125,lehmann_subtype) %>% group_by(cluster_125) %>% table() %>% as.data.frame
subtype <- subtype %>% group_by(cluster_125) %>% mutate(fra = Freq/sum(Freq)) 
subtype <- subtype %>% select(-Freq) %>% pivot_wider(id_cols = cluster_125,names_from = lehmann_subtype,values_from = fra) %>% column_to_rownames("cluster_125")

col_lehmann = colorRampPalette(brewer.pal(9, "Set2"))(length(unique(colData(sce)$lehmann_subtype)))

#General heatmap color scheme
col_main = viridis(125)

### Plot combined Heatmap
h <-Heatmap(t(assay(cluster_mean_sce, "min_max")),
        column_title = "cluster_channels",
        col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  Heatmap(t(assay(cellstate_mean_sce, "min_max")),
        column_title = "cellstate_channels",
        col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T,
        show_column_names =  T,
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  Heatmap(t(assay(other_mean_sce, "min_max")),
        column_title = "other_channels",
        col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  Heatmap(spatial_norm,
          column_title = "spatial_features",
          col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  rowAnnotation(cluster_125 = anno$cluster_125,
                annotation_name_rot = 90,
                #cluster_category = anno_tumor$cluster_category,
                col = col_list_1, 
                border = TRUE)+
  rowAnnotation(n_cells = anno_barplot(anno$ncells, width = unit(10, "mm"),gp = gpar(fill = "black"), col = 1),annotation_name_rot = 90)+
  rowAnnotation(grade = anno_barplot(grade, width = unit(10, "mm"),gp = gpar(fill = c("#FFF5F0","#FB6A4A","#67000D")), col = 1),annotation_name_rot = 90)+
    rowAnnotation(lehmann_subtype = anno_barplot(subtype, width = unit(15, "mm"), gp = gpar(fill = col_lehmann),col = 1,show_legend = TRUE),annotation_name_rot = 90)
  
draw(h)
```

```{r dimred, message=FALSE,warning=FALSE}
#Run UMAP/TSNE
sce = runUMAP(sce, exprs_values = "exprs", external_neighbors=TRUE, BPPARAM = MulticoreParam((detectCores()-2)))
sce = runTSNE(sce, exprs_values = "exprs", external_neighbors=TRUE, BPPARAM = MulticoreParam((detectCores()-2)))

## 1. Visualize UMAP and TSNE
#panCK and GMM_CK
p1 <- plotReducedDim(sce, dimred = "UMAP", colour_by = "cluster_125")+
  scale_color_manual(values = col_list_1[[1]])

p2 <- plotReducedDim(sce, dimred = "TSNE", colour_by = "cluster_125")+
  scale_color_manual(values = col_list_1[[1]])

(p1+p2)

#Visualize all marker expression
all_plots_UMAP <- lapply(c(rownames(sce)[rowData(sce)$cluster_channel]),
                    function(x){
                      p <- plotReducedDim(sce, dimred = "UMAP", 
                                          colour_by = x, 
                                          by_exprs_values = "exprs",
                                          point_size = 0.5)
                      return(p)                    
                    })

library(cowplot)
plot_grid(plotlist = all_plots_UMAP)

all_plots_TSNE <- lapply(c(rownames(sce)[rowData(sce)$cluster_channel]),
                    function(x){
                      p <- plotReducedDim(sce, dimred = "TSNE", 
                                          colour_by = x, 
                                          by_exprs_values = "exprs",
                                          point_size = 0.5)
                      return(p)                    
                    })

library(cowplot)
plot_grid(plotlist = all_plots_TSNE)
```


```{r cluster-pro, message = FALSE, warning = FALSE}
#Fraction of PID/SID per cluster
cluster_SID <- colData(sce) %>% as.data.frame() %>% select(cluster_125,sample_id) %>% group_by(cluster_125) %>% table() %>% as.data.frame
cluster_SID <- cluster_SID %>% group_by(cluster_125) %>% mutate(fra = Freq/sum(Freq))
cluster_PID <- colData(sce) %>% as.data.frame() %>% select(cluster_125,PID) %>% group_by(cluster_125) %>% table() %>% as.data.frame
cluster_PID <- cluster_PID %>% group_by(cluster_125) %>% mutate(fra = Freq/sum(Freq))

col_PID = colorRampPalette(brewer.pal(9, "Set1"))(length(unique(cluster_PID$PID))) 
col_SID = colorRampPalette(brewer.pal(9, "Set1"))(length(unique(cluster_SID$sample_id))) 

ggplot(cluster_PID) +
  geom_tile(color = "black",aes(cluster_125, fra, fill = PID), position = "stack")+
  scale_fill_manual(values=col_PID) + 
  theme_classic(base_size = 15)+
  ylab("PID fraction per cluster")+
  theme(axis.title.x = element_blank())+
  guides(fill = "none")


#Fraction of cluster per PID/SID
SID_cluster <- colData(sce) %>% as.data.frame() %>% select(cluster_125,sample_id) %>% group_by(sample_id) %>% table() %>% as.data.frame
SID_cluster <- SID_cluster %>% group_by(sample_id) %>% mutate(fra = Freq/sum(Freq))
PID_cluster <- colData(sce) %>% as.data.frame() %>% select(cluster_125,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_cluster <- PID_cluster %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

ggplot(SID_cluster) +
  geom_tile(color = "black",aes(sample_id, fra, fill = cluster_125), position = "stack")+
    scale_fill_manual(values=col_list_1[[1]]) + 
  theme_classic(base_size = 15)+
  ylab("Fraction")+
  xlab("Sample_ID")+
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

ggplot(PID_cluster) +
  geom_tile(color = "black",aes(PID, fra, fill = cluster_125), position = "stack")+
  scale_fill_manual(values=col_list_1[[1]]) + 
  theme_classic(base_size = 15)+
  ylab("Fraction")+
  xlab("PID")+
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
```




```{r patient_groups, message=FALSE,warning=FALSE}

```



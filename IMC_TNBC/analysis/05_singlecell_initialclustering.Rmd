---
title: "05_SingleCell_InitialClustering"
output: html_document
date: '2022-03-30'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Software requirements

```{r lib, message=FALSE,warning=FALSE}
#Data containers
library(SpatialExperiment)
library(SingleCellExperiment)

#Data processing
library(scuttle)
library(scater)
library(scran)
library(imcRtools)

#Data visualization
library(cytomapper)
library(dittoSeq)
library(pheatmap)
library(cowplot)
library(ComplexHeatmap)

#Utilities
library(tidyverse)
library(openxlsx)
library(stringr)
library(patchwork)
library(parallel)
library(BiocParallel)
library(BiocNeighbors)
library(BiocSingular)
library(tiff)
library(ggrepel)
library(EBImage)
library(viridis)
library(mclust)
library(Rphenograph)
library(igraph)
library(RColorBrewer)
library(foreach)

#Batch correction
library(batchelor)
library(harmony)
```

# Single-cell analysis - Pipeline 1 - Distinguish tumor and immune cells

Here, we will perform the first single cell analysis steps, including distinguishing tumor and stromal cells and dimensionality reduction.

## Read in data and filter for ZTMA249
First, we will read in the `SingleCellExperiment` object containing the cleaned, spillover- and (batch-corrected) single-cell data. 
**Important:** For now, We will filter the object for ZTMA249 samples, since we are sure that those are TNBC. 

```{r read-data-batch-correction, message=FALSE}
sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_QC.rds")

#Filter sce for ZTMA249 (n=654357)
summary(str_detect(colData(sce)$sample_id,"ZTMA249"))
sce <- sce[,str_detect(colData(sce)$sample_id,"ZTMA249")]
```

## Perform "overclustering"

Next, we will run a granular Rphenograph (Jaccard-based weights, Louvain clustering as community detection algorithm) clustering. 

```{r overcluster, message=FALSE}
set.seed(22)
snn.sce <- buildSNNGraph(sce[rowData(sce)$use_channel==TRUE,], k=30, 
                         d = NA, 
                         type = "jaccard",
                         assay.type = "exprs",
                         BNPARAM=AnnoyParam(),
                         BPPARAM = MulticoreParam(workers = (detectCores()-2), progressbar = TRUE)
                         )

clusters <- igraph::cluster_louvain(snn.sce) #Memory issues with this function!
sce$cluster <- as.factor(clusters$membership)
```

## Use GMM for panCK

We will use a two component gaussian mixture model to distinguish between tumor (panCK+) and stromal (panCK-) cells. 

```{r GMM_CK, message=FALSE,warning=FALSE}
#Gaussian mixture model to distinguish tumor/stroma based on panCK expression
GMM_CK <- Mclust(assay(sce, "exprs")["panCK",], G = 2)

GMM_df <- data.frame(class_CK = ifelse(GMM_CK$classification == 2 & GMM_CK$uncertainty == 0, "panCK+", "panCK-"), 
                     panCK_exprs = assay(sce, "exprs")["panCK",],
                     uncertainty = GMM_CK$uncertainty)

#Visualize GMM
p1 <- ggplot(GMM_df, aes(x = panCK_exprs, fill = class_CK))+
  geom_density()+
  theme_classic(base_size = 15)+
  theme(axis.title.x = element_blank())+
  scale_fill_brewer(palette = "Set1")
  
p2 <- ggplot(GMM_df, aes(x = panCK_exprs, y = uncertainty, color = class_CK))+
  geom_line()+
  theme_classic(base_size = 15)+
  theme(axis.title.x = element_blank())+
  scale_color_brewer(palette = "Set1")

p1/p2

#Add GMM CK class to SCE
sce$GMM_CK <- GMM_df$class_CK

#Save sce after clustering and GMM
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_Clus_249.rds")
```

## Heatmap 

Heatmap of clusters with GMM information 

```{r}
#Read sce after clustering and GMM
#sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_Clus_249.rds")

### 1. Marker Heatmap 

#Min-Max [0,1] normalization of arcsinh-transformed counts
assay(sce, "min_max") <- assay(sce, "exprs") - rowMins(assay(sce, "exprs"))
assay(sce, "min_max") <- assay(sce, "min_max") / (rowMaxs(assay(sce, "exprs")) - rowMins(assay(sce, "exprs")))

#Aggregrate across cells with the mean (median is also possible)
mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster,
                                 statistics = "mean",
                                 use.assay.type = "min_max",
                                 subset.row = rowData(sce)$use_channel)

### 2. Spatial Heatmap
#Add number of neighbors to sce object (saved in ColPair)
n_neighbors <- colPair(sce) %>% as.data.frame() %>% group_by(from) %>% count() %>% arrange(desc(n))

sce$n_neighbors <- n_neighbors$n[match(seq_along(colnames(sce)),n_neighbors$from)]
sce$n_neighbors <- sce$n_neighbors %>% replace_na(0)

#Double-check 
p1 <- plotSpatial(sce[,colData(sce)$sample_id == "ZTMA249.1_ZTMA249_ID_1_AX1Y1_93"],img_id = "sample_id",colPairName = "neighborhood",draw_edges = FALSE, node_color_by = "n_neighbors",node_size_fix = 2)+
  scale_color_continuous(type = "viridis")+
  theme_classic()
p2 <- plotSpatial(sce[,colData(sce)$sample_id == "ZTMA249.1_ZTMA249_ID_1_AX1Y1_93"],img_id = "sample_id",colPairName = "neighborhood",draw_edges = TRUE, node_color_by = "GMM_CK")+
  scale_color_brewer(palette = "Set1")+
  theme_classic()
p1+p2

#Select spatial features and average over clusters 
spatial <- colData(sce) %>% as.data.frame %>% select(area,eccentricity,cluster,n_neighbors)
spatial <- spatial %>% select(-cluster) %>% aggregate(by = list(cluster = spatial$cluster), FUN = mean) %>% column_to_rownames("cluster")
#define min_max fct
min_max_norm <- function(x) {(x - min(x)) / (max(x) - min(x))}
#normalize
spatial_norm <- as.data.frame(lapply(spatial, min_max_norm))

### 3. Row annotation plots with number and fraction of tumor cells
nr_tum <- colData(sce) %>% as.data.frame %>% select(cluster, GMM_CK) %>% table()
fr_tum <- as.data.frame(nr_tum) %>% pivot_wider(names_from = GMM_CK, values_from = Freq) %>% column_to_rownames("cluster")
fr_tum <- fr_tum %>% transmute(fr_tum = `panCK+`/rowSums(fr_tum)) %>% as.data.frame()

col_main = viridis(100)

### 4. Define tumor and stroma cluster (Fraction of tumor cells according to GMM >80%)
anno_tumor <- fr_tum %>% rownames_to_column(var = "cluster") %>% mutate(cluster_category = ifelse(fr_tum > 0.9,"Tumor",
                                                                                                  ifelse(fr_tum < 0.9 & fr_tum > 0.4,"Mixed","Stroma")))

col <- list(cluster = colorRampPalette(brewer.pal(9, "Paired"))(length(unique(anno_tumor$cluster))),
           cluster_category = c("#A6CEE3","#B2DF8A","#1F78B4"))

col_list_1 <- foreach(i=1:2) %do% {
  color= col[[i]]
  names(color)= sort(unique(anno_tumor[,names(col)[i]]))
  color
}
names(col_list_1) <- c(names(col))

### Plot combined Heatmap
h <- Heatmap(t(assay(mean_sce, "min_max")),
        col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  Heatmap(spatial_norm,
        col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  rowAnnotation(Fraction_tumor = anno_barplot(fr_tum, width = unit(10, "mm"),gp = gpar(fill = "#377EB8", col = 1)),annotation_name_rot = 90)+
  rowAnnotation(Number_tumor = anno_barplot(nr_tum, width = unit(10, "mm"),gp = gpar(fill = c("#E41A1C","#377EB8"), col = 1)),annotation_name_rot = 90)+
  rowAnnotation(cluster = anno_tumor$cluster,
                cluster_category = anno_tumor$cluster_category,
                col = col_list_1, 
                border = TRUE)

draw(h)

### Add cluster_categories to sce
sce$cluster_category <- anno_tumor$cluster_category[match(sce$cluster,anno_tumor$cluster)]

#Save sce
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_Clus_249.rds")
```

## Pie plots for categories

```{r prop_tumor, message=FALSE, warning=FALSE}
#panCK+ per cluster category
prop_tumor <- colData(sce) %>% as.data.frame() %>%
  select(GMM_CK,cluster_category) %>% filter(GMM_CK == "panCK+") %>% group_by(cluster_category) %>% count()
prop_tumor <- prop_tumor %>% mutate(fr_tumor_clus = n/sum(prop_tumor$n))

pie(prop_tumor$fr_tumor_clus, labels = paste0(prop_tumor$cluster_category," - ",round(prop_tumor$fr_tumor_clus,3),"%"),col=col_list_1$cluster_category, main = "panCK+")

#panCK- per cluster category
prop_tumor_1 <- colData(sce) %>% as.data.frame() %>%
  select(GMM_CK,cluster_category) %>% filter(GMM_CK == "panCK-") %>% group_by(cluster_category) %>% count()
prop_tumor_1 <- prop_tumor_1 %>% mutate(fr_tumor_clus = n/sum(prop_tumor_1$n))
pie(prop_tumor_1$fr_tumor_clus, labels = paste0(prop_tumor_1$cluster_category," - ",round(prop_tumor_1$fr_tumor_clus,3),"%"),col=col_list_1$cluster_category, main = "panCK-")

#Tumor per GMM_CK
prop_tumor_2 <- colData(sce) %>% as.data.frame() %>%
  select(GMM_CK,cluster_category) %>% filter(cluster_category == "Tumor") %>% group_by(GMM_CK) %>% count()
prop_tumor_2 <- prop_tumor_2 %>% mutate(fr_tumor_clus = n/sum(prop_tumor_2$n))
pie(prop_tumor_2$fr_tumor_clus, labels = paste0(prop_tumor_2$GMM_CK," - ",round(prop_tumor_2$fr_tumor_clus,3),"%"), col =c("#E41A1C","#377EB8"), main = "Tumor")

prop_tumor_3 <- colData(sce) %>% as.data.frame() %>%
  select(GMM_CK,cluster_category) %>% filter(cluster_category == "Mixed") %>% group_by(GMM_CK) %>% count()
prop_tumor_3 <- prop_tumor_3 %>% mutate(fr_tumor_clus = n/sum(prop_tumor_3$n))
pie(prop_tumor_3$fr_tumor_clus, labels = paste0(prop_tumor_3$GMM_CK," - ",round(prop_tumor_3$fr_tumor_clus,3),"%"), col =c("#E41A1C","#377EB8"), main = "Mixed")

prop_tumor_4 <- colData(sce) %>% as.data.frame() %>%
  select(GMM_CK,cluster_category) %>% filter(cluster_category == "Stroma") %>% group_by(GMM_CK) %>% count()
prop_tumor_4 <- prop_tumor_4 %>% mutate(fr_tumor_clus = n/sum(prop_tumor_4$n))
pie(prop_tumor_4$fr_tumor_clus, labels = paste0(prop_tumor_4$GMM_CK," - ",round(prop_tumor_4$fr_tumor_clus,3),"%"), col =c("#E41A1C","#377EB8"), main = "Stroma")
```

## Visualization of Clustering/GMM on UMAP/TSNE

```{r viz_sub, message = FALSE, warning=FALSE}
## Subsample 10% of cells from each core 
#to save time and not get super crowded dimensionality reduction plots
set.seed(22011995)
sub <- colData(sce) %>% as.data.frame() %>% group_by("sample_id") %>% slice_sample(prop = 0.1) %>% arrange("sample_id") %>% mutate(sub_id = paste(sample_id,ObjectNumber,sep="_")) %>% pull(sub_id)
sce_sub = sce[,sub]
sce_sub$cluster = as.factor(sce_sub$cluster)  
#Run UMAP/TSNE
sce_sub = runUMAP(sce_sub, exprs_values = "exprs", external_neighbors=TRUE, BPPARAM = MulticoreParam((detectCores()-2)))
sce_sub = runTSNE(sce_sub, exprs_values = "exprs", external_neighbors=TRUE, BPPARAM = MulticoreParam((detectCores()-2)))

## 1. Visualize UMAP
#panCK and GMM_CK
p1 <- plotReducedDim(sce_sub, dimred = "UMAP", by_exprs_values = "exprs",colour_by = "panCK")

p2 <- plotReducedDim(sce_sub, dimred = "UMAP", colour_by = "GMM_CK")+
  scale_color_brewer(palette="Set1")

p3 <- plotReducedDim(sce_sub, dimred = "UMAP", colour_by = "cluster")+
  scale_color_manual(values = col_list_1[[1]])

p4 <- plotReducedDim(sce_sub, dimred = "UMAP", colour_by = "cluster_category")+
  scale_color_manual(values = col_list_1[[2]])

(p1+p2)/(p3+p4)

#Visualize all marker expression
all_plots <- lapply(c(rownames(sce_sub)[rowData(sce_sub)$use_channel]),
                    function(x){
                      p <- plotReducedDim(sce_sub, dimred = "UMAP", 
                                          colour_by = x, 
                                          by_exprs_values = "exprs",
                                          point_size = 0.5)
                      return(p)                    
                    })

library(cowplot)
plot_grid(plotlist = all_plots)


## 2. Visualize TSNE
#panCK and GMM_CK
p1 <- plotReducedDim(sce_sub, dimred = "TSNE", by_exprs_values = "exprs",colour_by = "panCK")

p2 <- plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "GMM_CK")+
  scale_color_brewer(palette="Set1")

p3 <- plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "cluster")+
  scale_color_manual(values = col_list_1[[1]])

p4 <- plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "cluster_category")+
  scale_color_manual(values = col_list_1[[2]])

(p1+p2)/(p3+p4)

#Visualize all marker expression
all_plots <- lapply(c(rownames(sce_sub)[rowData(sce_sub)$use_channel]),
                    function(x){
                      p <- plotReducedDim(sce_sub, dimred = "TSNE", 
                                          colour_by = x, 
                                          by_exprs_values = "exprs",
                                          point_size = 0.5)
                      return(p)                    
                    })

library(cowplot)
plot_grid(plotlist = all_plots)

#Save sce_sub
saveRDS(sce_sub, "/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_Clus_249_sub.rds")
```



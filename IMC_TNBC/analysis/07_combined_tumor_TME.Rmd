---
title: "08_combined_tumor_TME"
author: "Lasse Meyer"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Software requirements

```{r lib, message=FALSE,warning=FALSE}
#Data containers
library(SpatialExperiment)
library(SingleCellExperiment)

#Data processing
library(scuttle)
library(scater)
library(scran)
library(imcRtools)

#Data visualization
library(cytomapper)
library(dittoSeq)
library(pheatmap)
library(cowplot)
library(ComplexHeatmap)
library(circlize)

#Utilities
library(tidyverse)
library(openxlsx)
library(stringr)
library(patchwork)
library(parallel)
library(BiocParallel)
library(BiocNeighbors)
library(BiocSingular)
library(tiff)
library(ggrepel)
library(EBImage)
library(viridis)
library(mclust)
library(Rphenograph)
library(igraph)
library(RColorBrewer)
library(foreach)
library(clValid)
library(bluster)
library(psych)
library(corrplot)
library(psych)

#Batch correction
library(batchelor)
```

# Single-cell analysis - Pipeline 4 - Combined analysis

Here, we will perform the first combined analysis steps for tumor and TME phenotypes.

## Load data

```{r load data, message = FALSE, warning = FALSE}
#tumor sce
sce_tumor <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_sce_TNBC_tumor_new.rds") 
sce_tumor

#TME sce
sce_TME <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/06_sce_TNBC_TME_new.rds") 
sce_TME

#sce with all cells
sce <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/04_sce_TNBC_Clus.rds")
sce
```

## 1. Data integration

## Combine tumor and TME cluster/metacluster/color information

```{r combine tumor TME, message=FALSE,warning=FALSE}
## 1. Cluster 
tumor_cluster <- colData(sce_tumor) %>% as.data.frame %>% mutate(cluster_combined = paste0("tumor_",sce_tumor$cluster_110)) %>% select(cell_id,cluster_combined)

TME_cluster <- colData(sce_TME) %>% as.data.frame %>% mutate(cluster_combined = paste0("TME_",sce_TME$cluster_130)) %>% select(cell_id,cluster_combined)

tumor_TME_cluster <- rbind(tumor_cluster, TME_cluster)

### Add to sce
sce$cluster_combined <- tumor_TME_cluster$cluster_combined[match(sce$cell_id, tumor_TME_cluster$cell_id)]
sce$cluster_combined <- factor(sce$cluster_combined)


## 2. Metacluster 
tumor_metacluster <- colData(sce_tumor) %>% as.data.frame %>% mutate(metacluster_combined = paste0("tumor_",sce_tumor$metacluster)) %>% select(cell_id,metacluster_combined)

TME_metacluster <- colData(sce_TME) %>% as.data.frame %>% mutate(metacluster_combined = sce_TME$immune_metacluster) %>% select(cell_id,metacluster_combined)

tumor_TME_metacluster <- rbind(tumor_metacluster, TME_metacluster)

### Add to sce
sce$metacluster_combined <- tumor_TME_metacluster$metacluster_combined[match(sce$cell_id, tumor_TME_metacluster$cell_id)]
sce$metacluster_combined <- factor(sce$metacluster_combined)


## 3. Color mapping
names(metadata(sce_tumor)$colors$cluster_110) <- paste0("tumor_", names(metadata(sce_tumor)$colors$cluster_110))
names(metadata(sce_TME)$colors$cluster_130) <- paste0("TME_", names(metadata(sce_TME)$colors$cluster_130))

names(metadata(sce_tumor)$colors$metacluster) <- paste0("tumor_", names(metadata(sce_tumor)$colors$metacluster))

#Add to sce 
metadata(sce)$colors$cluster_combined <- c(metadata(sce_tumor)$colors$cluster_110, metadata(sce_TME)$colors$cluster_130)
metadata(sce)$colors$metacluster_combined <- c(metadata(sce_tumor)$colors$metacluster, metadata(sce_TME)$colors$immune_metacluster)


## 4. Cluster channels 
rowData(sce)$TME_cluster_channel <- rowData(sce_TME)$cluster_channel
rowData(sce)$tumor_cluster_channel <- rowData(sce_tumor)$cluster_channel
```

```{r save_objects, message = FALSE, warning=FALSE}
#Save sce
saveRDS(sce, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")
```

## Overlay tumor and TME cluster colors onto combined tSNE

```{r combined tSNE}
#Read subsampled sce from pipeline 1
sce <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")
sce_sub <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/04_sce_SUB_TNBC_Clus.rds")

#Add cluster_combined info
sce_sub$cluster_combined <- sce$cluster_combined[match(sce_sub$cell_id, sce$cell_id)]
sce_sub$metacluster_combined <- sce$metacluster_combined[match(sce_sub$cell_id, sce$cell_id)]
sce_sub$pretreatment <- sce$pretreatment[match(sce_sub$cell_id, sce$cell_id)]

#sub cluster categories
sce_sub$metacluster_tumor_combined <- sce$metacluster_tumor_combined[match(sce_sub$cell_id, sce$cell_id)]
sce_sub$metacluster_TME_combined <- unfactor(sce_sub$metacluster_combined)
sce_sub$metacluster_TME_combined[sce_sub$analysis_cat == "non_tumor"] <- "TME"

tumor_color <- c("grey")
names(tumor_color) <- "tumor"
TME_color <- c("grey")
names(TME_color) <- "TME"

color_TME <- c(metadata(sce)$colors$metacluster_combined, tumor_color, TME_color)
color_TME

#Plot TSNE

plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "PID")+#shape_by = "analysis_cat")+
  scale_color_manual(values = metadata(sce)$colors$PID)+
  guides(color = "none")

plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "TMANr")+#shape_by = "analysis_cat")+
  scale_color_manual(values = metadata(sce)$colors$TMANr)

plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "pretreatment")+#shape_by = "analysis_cat")+
  scale_color_manual(values = metadata(sce)$colors$pretreatment)

plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "analysis_cat")+#shape_by = "analysis_cat")+
  scale_color_manual(values = metadata(sce)$colors$analysis_cat)

plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "metacluster_tumor_combined")+#shape_by = "analysis_cat")+
  scale_color_manual(values = color_TME, limits = force)

plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "metacluster_TME_combined")+#shape_by = "analysis_cat")+
  scale_color_manual(values = color_TME, limits = force)
```

## Add missing metadata 

```{r}
# Missing metadata for 10 ZTMA174 patients
sce <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")

meta <- read.csv("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/03_data/Metadata_Combined_TNBC_LM.csv",row.names = 1)

## Add relevant metadata based on PID
for (entry in colnames(meta)[colnames(meta) %in% c("age","grade","pT", "pT_simple", "pN", "pN_simple", "status_OS","status_DFS", "OS_months","DFS_months")]) {
  colData(sce)[,entry] <- meta[,entry][match(colData(sce)[,"PID"],meta[,"PID"])]
}
```

```{r}
# Mark by pre-treatment information
sce$pretreatment_pT <- str_detect(sce$pT, "y")
sce$pretreatment_pN <- str_detect(sce$pN, "y")

test_df <- colData(sce) %>% as.data.frame %>% select(PID, pT, pT_simple, pN, pN_simple, pretreatment_pT, pretreatment_pN) %>% unique() %>% filter(pretreatment_pN == TRUE)

sce$pretreatment <- sce$pretreatment_pT

metadata(sce)$colors$pretreatment <- setNames(brewer.pal(4,"Set3")[3:4], sort(unique(sce$pretreatment)))
```

```{r}
# Proportion of pre-treatment per category 
pretreatment_mc <- colData(sce) %>% as.data.frame() %>% select(spatial_CD8_pheno,pretreatment) %>% group_by(spatial_CD8_pheno) %>% table() %>% as.data.frame
pretreatment_mc <- pretreatment_mc %>% group_by(spatial_CD8_pheno) %>% mutate(fra = Freq/sum(Freq)) 

ggplot(pretreatment_mc, aes(x = spatial_CD8_pheno, y = fra, fill = pretreatment))+
  geom_tile(position = "stack",color = "black")+#+alpha = 0.5)+
  theme_classic()+
  ylab("Fraction of cells per group")+
  scale_fill_manual(values = metadata(sce)$colors$pretreatment)
```

# 2. Image visualization

## Load masks and images 

```{r load images}
#Load images and masks
images <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/images_segtest.rds")
masks <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/masks_segtest_4.rds")
```

## Plot cell features onto image

```{r image viz, eval =F}
set.seed(22)
img_random <- sample(seq_len(length(images)), 10)

img_files <- list.files("/mnt/central_nas/tnbc_volume/TNBC/img/")
img_selected <- c(which(str_detect(img_files ,"ZTMA249_ID_320_CX8Y10")),which(str_detect(img_files ,"ZTMA249_ID_289_CX1Y7")),which(str_detect(img_files ,"ZTMA249_ID_36_AX4Y5")),which(str_detect(img_files ,"ZTMA249_ID_7_AX7Y1")),which(str_detect(img_files ,"ZTMA249_ID_220_BX4Y13")),which(str_detect(img_files ,"ZTMA249_ID_271_CX7Y4")),which(str_detect(img_files ,"ZTMA249_ID_82_AX2Y11")), which(str_detect(img_files ,"ZTMA249_ID_179_BX3Y8")), which(str_detect(img_files ,"ZTMA249_ID_183_BX7Y8")), which(str_detect(img_files ,"ZTMA174_B08.26868_79_AX7Y10")))

img_ids <- c(img_selected,img_random)

#Plot masks of cell phenotypes
plotCells(mask = masks[img_ids], 
          object = sce,
          img_id = "sample_id", 
          cell_id = "ObjectNumber", 
          colour_by = "metacluster_combined",
          outline_by = "analysis_cat",
          colour = list(metacluster_combined = metadata(sce)$colors$metacluster_combined),
          thick = TRUE)
```

# 3. Spatial analysis

```{r load combined sce}
##Load sce
sce <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")
```

# 3.1 Cellular neighborhoods

## Detect CN

In the next section, we will define cellular neighborhoods by clustering cells based on their neighboring cells.

### Based on Metacluster

```{r neighborhood-1, message=FALSE, warning=FALSE}
library(imcRtools)
library(bluster)

# Build spatial knn graph
sce <- buildSpatialGraph(sce, img_id = "sample_id", type = "knn", k = 20, 
                         coords = c("Pos_X",  "Pos_Y"),
                         #max_dist = 30,
                         BPPARAM = MulticoreParam())

colPairNames(sce) #now includes knn_interaction_graph

# Aggregate across neighbors
sce <- aggregateNeighbors(sce, colPairName = "knn_interaction_graph", 
                          aggregate_by = "metadata", count_by = "metacluster_combined", 
                          proportions = TRUE)

head(sce$aggregatedNeighbors)

# Perform cluster sweep for kmeans (silhouette width, wcss)
set.seed(22)
clust_list <- lapply(2:20, function(k){
  cur_km <- kmeans(sce$aggregatedNeighbors, centers = k)
  return(list(wss = sum(cur_km$withinss),
           clusters = cur_km$cluster))
})

sil <- vapply(lapply(clust_list, `[[`, 2), 
              function(x) mean(approxSilhouette(sce$aggregatedNeighbors, x)$width), 
              0)

ggplot(data.frame(k = 2:20, sil = sil))+
  geom_point(aes(k, sil, col = sil))+
  geom_line(aes(k, sil,col=sil))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  xlab("k")+
  ylab("Mean silhouette width")+
  scale_color_continuous(type = "viridis")

ggplot(data.frame(k = 2:20,wss = unlist(lapply(clust_list, `[[`, 1))))+
  geom_point(aes(k, wss, col = wss))+
  geom_line(aes(k, wss, col = wss))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("k")+
  ylab("Total WCSS")+
  scale_color_continuous(type = "viridis")

# Select 13 clusters
set.seed(22)
cur_clusters <- kmeans(sce$aggregatedNeighbors, centers = 18, nstart = 100)$cluster

sce$cellular_neighborhood <- as.factor(cur_clusters)
```

```{r save_objects, message = FALSE, warning=FALSE}
#Save sce
saveRDS(sce, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")
```

### Based on Exprs

```{r neighborhood-1, message=FALSE, warning=FALSE}
library(imcRtools)
library(bluster)

# Build spatial knn graph
sce <- buildSpatialGraph(sce, img_id = "sample_id", type = "knn", k = 20, 
                         coords = c("Pos_X",  "Pos_Y"),
                         #max_dist = 30,
                         BPPARAM = MulticoreParam())

colPairNames(sce) #now includes knn_interaction_graph

# Aggregate across neighbors based on expression 
rowData(sce)$cluster_channel_combined <- ifelse(rowData(sce)$TME_cluster_channel == TRUE|rowData(sce)$tumor_cluster_channel == TRUE, TRUE, FALSE)

sce <- aggregateNeighbors(sce, colPairName = "knn_interaction_graph",
                          aggregate_by = "expression", assay_type = "exprs",
                          subset_row = rowData(sce)$cluster_channel_combined
                          )


head(sce$mean_aggregatedExpression)

# Perform cluster sweep for kmeans (silhouette width, wcss)
set.seed(22)
clust_list <- lapply(2:20, function(k){
  cur_km <- kmeans(sce$mean_aggregatedExpression, centers = k)
  return(list(wss = sum(cur_km$withinss),
           clusters = cur_km$cluster))
})

sil <- vapply(lapply(clust_list, `[[`, 2), 
              function(x) mean(approxSilhouette(sce$mean_aggregatedExpression, x)$width), 
              0)

ggplot(data.frame(k = 2:20, sil = sil))+
  geom_point(aes(k, sil, col = sil))+
  geom_line(aes(k, sil,col=sil))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  xlab("k")+
  ylab("Mean silhouette width")+
  scale_color_continuous(type = "viridis")

ggplot(data.frame(k = 2:20,wss = unlist(lapply(clust_list, `[[`, 1))))+
  geom_point(aes(k, wss, col = wss))+
  geom_line(aes(k, wss, col = wss))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("k")+
  ylab("Total WCSS")+
  scale_color_continuous(type = "viridis")

# Select 13 clusters
set.seed(22)
cur_clusters <- kmeans(sce$mean_aggregatedExpression, centers = 13, nstart = 10)$cluster

sce$cellular_neighborhood_exprs <- as.factor(cur_clusters)
```


### Based on lisaClust

```{r}
library(lisaClust)
library(spicyR)

cells <- data.frame(row.names = colnames(sce))
cells$ObjectNumber <- sce$ObjectNumber
cells$ImageNumber <- sce$sample_id
cells$AreaShape_Center_X <- sce$Pos_X
cells$AreaShape_Center_Y <- sce$Pos_Y
cells$cellType <- sce$metacluster_combined

lisa_sc <- SegmentedCells(cells, cellProfiler = TRUE)

lisa_sc

#
lisaCurves <- lisa(lisa_sc, Rs = c(10, 20, 50))

# Set NA to 0
lisaCurves[is.na(lisaCurves)] <- 0



set.seed(22)
clust_list <- lapply(5:20, function(k){
  cur_km <- kmeans(lisaCurves, centers = k)
  return(list(wss = sum(cur_km$withinss),
           clusters = cur_km$cluster))
})

sil <- vapply(lapply(clust_list, `[[`, 2), 
              function(x) mean(approxSilhouette(lisaCurves, x)$width), 
              0)

ggplot(data.frame(k = 5:20, sil = sil))+
  geom_point(aes(k, sil, col = sil))+
  geom_line(aes(k, sil,col=sil))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  xlab("k")+
  ylab("Mean silhouette width")+
  scale_color_continuous(type = "viridis")

ggplot(data.frame(k = 5:20,wss = unlist(lapply(clust_list, `[[`, 1))))+
  geom_point(aes(k, wss, col = wss))+
  geom_line(aes(k, wss, col = wss))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("k")+
  ylab("Total WCSS")+
  scale_color_continuous(type = "viridis")


set.seed(22)
cur_clusters <- kmeans(lisaCurves, centers = 12, nstart = 10)$cluster

sce$cellular_neighborhood_lisa <- as.factor(cur_clusters)
```



## Heatmap visualization

Quick and easy heatmap to visualize the proportion of metaclusters in each CN

```{r}
library(tidyverse)
for_plot <- colData(sce) %>% as_tibble() %>%
    group_by(cellular_neighborhood, metacluster_combined) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = cellular_neighborhood, names_from = metacluster_combined, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>%
    select(-cellular_neighborhood)

pheatmap(for_plot, #color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column", show_rownames = TRUE)
```
Rich heatmap visualization 

```{r rich heatmap}
### 1. Heatmap body ###

# Visualize cell type proportions of cellular neighborhoods
cn_prop_wide <- colData(sce) %>% as_tibble() %>%
    group_by(cellular_neighborhood, metacluster_combined) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = cellular_neighborhood, names_from = metacluster_combined, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>% column_to_rownames(var = "cellular_neighborhood")


#Option: Column-scaled
cn_prop_wide_scaled <- scale(as.matrix(cn_prop_wide))

#Heatmap body color
col_main = viridis(100)
col_scaled <- colorRamp2(c(-1, 0, 2, 3), c("#A278FAFF", "#F1E9E7FF", "#FF8061FF", "#FF0000FF"))


### 2. Heatmap annotation ###

#Number of cells per cluster 
n_cells <- colData(sce) %>% as.data.frame() %>% select(cellular_neighborhood) %>% group_by(cellular_neighborhood) %>% count() 

# Proportion of grade per cluster
grade <- colData(sce) %>% as.data.frame() %>% select(cellular_neighborhood,grade) %>% group_by(cellular_neighborhood) %>% table() %>% as.data.frame
grade <- grade %>% group_by(cellular_neighborhood) %>% mutate(fra = Freq/sum(Freq)) 
grade <- grade %>% select(-Freq) %>% pivot_wider(id_cols = cellular_neighborhood,names_from = grade,values_from = fra) %>% column_to_rownames("cellular_neighborhood")

# Proportion of pT stage per cluster
pT <- colData(sce) %>% as.data.frame() %>% select(cellular_neighborhood,pT_simple) %>% group_by(cellular_neighborhood) %>% table() %>% as.data.frame
pT <- pT %>% group_by(cellular_neighborhood) %>% mutate(fra = Freq/sum(Freq)) 
pT <- pT %>% select(-Freq) %>% pivot_wider(id_cols = cellular_neighborhood,names_from = pT_simple,values_from = fra) %>% column_to_rownames("cellular_neighborhood")

# Proportion of pN stage per cluster
pN <- colData(sce) %>% as.data.frame() %>% select(cellular_neighborhood,pN_simple) %>% group_by(cellular_neighborhood) %>% table() %>% as.data.frame
pN <- pN %>% group_by(cellular_neighborhood) %>% mutate(fra = Freq/sum(Freq)) 
pN <- pN %>% select(-Freq) %>% pivot_wider(id_cols = cellular_neighborhood,names_from = pN_simple,values_from = fra) %>% column_to_rownames("cellular_neighborhood")

# Number of contributing patients
cluster_PID <- colData(sce) %>% as.data.frame() %>% select(cellular_neighborhood,PID) %>% group_by(cellular_neighborhood) %>% table() %>% as.data.frame
n_PID <- cluster_PID %>% filter(Freq>0) %>% group_by(cellular_neighborhood) %>% count(name = "n_PID") %>% column_to_rownames("cellular_neighborhood")

# Define colors for cellular neighborhood 
cn_col <- setNames(colorRampPalette(brewer.pal(9, "Set1"))(length(unique(sce$cellular_neighborhood))), sort(unique(sce$cellular_neighborhood)))         

metadata(sce)$colors$cellular_neighborhood <- cn_col

# Metadata annotation
ha_meta <- HeatmapAnnotation(cellular_neighborhood = anno_simple(unfactor(n_cells$cellular_neighborhood),pch = unfactor(n_cells$cellular_neighborhood), border=TRUE,col=metadata(sce)$colors$cellular_neighborhood),
                            n_cells = anno_barplot(n_cells$n, width = unit(10, "mm"),gp = gpar(fill = "#440154FF")),
                            n_PID = anno_barplot(n_PID, width = unit(10, "mm"),gp = gpar(fill = "#440154FF")),
                            grade = anno_barplot(grade, width = unit(10, "mm"),gp = gpar(fill = metadata(sce)$colors$grade)),
                            pT = anno_barplot(pT, width = unit(10, "mm"),gp = gpar(fill = metadata(sce)$colors$pT_simple)),
                            pN = anno_barplot(pN, width = unit(10, "mm"),gp = gpar(fill = metadata(sce)$colors$pN_simple)),
                            border = TRUE, 
                            annotation_name_rot = 90,
                            gap = unit(1,"mm"),
                            which = "row")

### 3. Plot heatmap ###
h <- Heatmap(cn_prop_wide,
        name = "MC proportion",
        col = col_main,
        row_title = NULL,
        clustering_method_columns = "ward.D2",
        clustering_method_rows = "ward.D2")+
  Heatmap(cn_prop_wide_scaled,
          col = col_scaled,
          name = "scaled MC proportion")+
  ha_meta

draw(h)
```
## Patient visualization

```{r}
## 1. Fraction of CN per PID
dittoBarPlot(sce, var = "cellular_neighborhood", group.by = "PID")+
  scale_fill_manual(values = metadata(sce)$colors$cellular_neighborhood)+
  theme(axis.text.x = element_blank())

## 2. Fraction of PID per CN
dittoBarPlot(sce, var = "PID", group.by = "cellular_neighborhood")+
  scale_fill_manual(values = metadata(sce)$colors$PID)+
  guides(fill = "none")
```

## Image visualization

We can now visualize a few example images and highlight the CN

```{r neighborhood-2}
#set.seed(22)
#cur_sam <- sample(unique(sce$sample_id), 6)
cur_sam <- colData(sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% filter(metacluster_combined == "tumor_8") %>% count(sample_id) %>% arrange(desc(n)) %>% slice(1:12) %>% pull(sample_id)

# Metacluster
plotSpatial(sce[,sce$sample_id %in% cur_sam], 
            node_color_by = "metacluster_combined", 
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat") +
    scale_color_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)

# Cellular Neighborhoods
plotSpatial(sce[,sce$sample_id %in% cur_sam], 
            node_color_by = "cellular_neighborhood", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood, limits = force)

plotSpatial(sce[,sce$sample_id %in% cur_sam], 
            node_color_by = "cellular_neighborhood_exprs", 
            img_id = "sample_id", 
            node_size_fix = 0.5)
    #scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood)

plotSpatial(sce[,sce$sample_id %in% cur_sam], 
            node_color_by = "cellular_neighborhood_lisa", 
            img_id = "sample_id", 
            node_size_fix = 0.5)

```
## Survival analysis 

### For OS on CN proportions

```{r cox}
library(survival)
library(survminer)

PID_cellular_neighborhood <- colData(sce) %>% as.data.frame() %>% select(cellular_neighborhood,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_cellular_neighborhood <- PID_cellular_neighborhood %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_cellular_neighborhood %>% pivot_wider(id_cols = "PID",names_from = "cellular_neighborhood",values_from = "fra") %>% column_to_rownames("PID")
colnames(PID_metagroups) <- paste0("CN",colnames(PID_metagroups))

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_OS <- sce$status_OS[match(rownames(Cox_df),sce$PID)]
Cox_df$OS_months <- sce$OS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#Based on proportions
covariates <- Cox_df %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -CN7) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+ CN7"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratios
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("CN")+
ylab("HR for con_prop")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop

## 2. Based on categories (mean division of cluster proportions)
Cox_df_mean <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
Cox_df %>% select(i) %>% mutate(mean = ifelse(Cox_df[,i] > mean(Cox_df[,i]),"B","A")) %>% pull(mean)
}

colnames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_mean <- as.data.frame(Cox_df_mean)

identical(rownames(Cox_df), rownames(Cox_df_mean))

Cox_df_mean <- cbind(Cox_df_mean, Cox_df %>% select(status_OS,OS_months, status_OS, OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_mean %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_mean)

summary(multi_model)

multi_res <- summary(multi_model)

plot_df_mean <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_mean <- ggplot(plot_df_mean, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("CN")+
ylab("HR for mean")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_mean

## 3. Based on categories (GMM division of cluster proportions)
Cox_df_GMM <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
GMM_Cox <- Mclust(Cox_df[,i], G = 2)
as.character(GMM_Cox$classification)
}

colnames(Cox_df_GMM) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_GMM) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_GMM <- as.data.frame(Cox_df_GMM,stringsAsFactors=TRUE)

identical(rownames(Cox_df), rownames(Cox_df_GMM))

Cox_df_GMM <- cbind(Cox_df_GMM, Cox_df %>% select(status_OS,OS_months, status_OS, OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_GMM %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_GMM)

summary(multi_model)

summary(Cox_df_GMM)

multi_res <- summary(multi_model)

plot_df_GMM <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_GMM <- ggplot(plot_df_GMM, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("CN")+
ylab("HR for GMM")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop/
hr_mean/
hr_GMM
```
### For DFS on CN proportions

```{r cox}
library(survival)
library(survminer)

PID_cellular_neighborhood <- colData(sce) %>% as.data.frame() %>% select(cellular_neighborhood,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_cellular_neighborhood <- PID_cellular_neighborhood %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_cellular_neighborhood %>% pivot_wider(id_cols = "PID",names_from = "cellular_neighborhood",values_from = "fra") %>% column_to_rownames("PID")
colnames(PID_metagroups) <- paste0("CN",colnames(PID_metagroups))

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#Based on proportions
covariates <- Cox_df %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -CN7) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+ CN7"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratios
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,100))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("CN")+
ylab("HR for con_prop")+
theme_classic()+
#scale_y_continuous(trans="log")+
theme(axis.text.x = element_text(angle = 90))

hr_prop

## 2. Based on categories (mean division of cluster proportions)
Cox_df_mean <- foreach(i = Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
Cox_df %>% select(i) %>% mutate(mean = ifelse(Cox_df[,i] > mean(Cox_df[,i]),"B","A")) %>% pull(mean)
}

colnames(Cox_df_mean) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_mean) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_mean <- as.data.frame(Cox_df_mean)

identical(rownames(Cox_df), rownames(Cox_df_mean))

Cox_df_mean <- cbind(Cox_df_mean, Cox_df %>% select(status_DFS,DFS_months, status_DFS, DFS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_mean %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_mean)

summary(multi_model)

multi_res <- summary(multi_model)

plot_df_mean <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_mean <- ggplot(plot_df_mean, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("CN")+
ylab("HR for mean")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_mean

## 3. Based on categories (GMM division of cluster proportions)
Cox_df_GMM <- foreach(i = Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
GMM_Cox <- Mclust(Cox_df[,i], G = 2)
as.character(GMM_Cox$classification)
}

colnames(Cox_df_GMM) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_GMM) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_GMM <- as.data.frame(Cox_df_GMM,stringsAsFactors=TRUE)

identical(rownames(Cox_df), rownames(Cox_df_GMM))

Cox_df_GMM <- cbind(Cox_df_GMM, Cox_df %>% select(status_DFS,DFS_months, status_DFS, DFS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_GMM %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_GMM)

summary(multi_model)

summary(Cox_df_GMM)

multi_res <- summary(multi_model)

plot_df_GMM <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_GMM <- ggplot(plot_df_GMM, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("CN")+
ylab("HR for GMM")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop/
hr_mean/
hr_GMM
```

## 3.1.1 Density - Detect CN

```{r}
# Aggregate across neighbors
sce_test <- sce
sce_test <- aggregateNeighbors(sce_test, colPairName = "knn_interaction_graph", 
                          aggregate_by = "metadata", count_by = "metacluster_combined", 
                          proportions = FALSE)

sce_test$aggregatedNeighbors

#densities of metaclusters
sce_test$aggregatedNeighbors <- sce_test$aggregatedNeighbors %>% as.data.frame %>% mutate(tissue_area = sce_test$tissue_area) %>% transmute_at(vars(1:ncol(sce_test$aggregatedNeighbors)),list(~./tissue_area))

# Perform cluster sweep for kmeans (silhouette width, wcss)
set.seed(22)
clust_list <- lapply(2:20, function(k){
  cur_km <- kmeans(sce_test$aggregatedNeighbors, centers = k)
  return(list(wss = sum(cur_km$withinss),
           clusters = cur_km$cluster))
})

sil <- vapply(lapply(clust_list, `[[`, 2), 
              function(x) mean(approxSilhouette(sce_test$aggregatedNeighbors, x)$width), 
              0)

ggplot(data.frame(k = 2:20, sil = sil))+
  geom_point(aes(k, sil, col = sil))+
  geom_line(aes(k, sil,col=sil))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  xlab("k")+
  ylab("Mean silhouette width")+
  scale_color_continuous(type = "viridis")

ggplot(data.frame(k = 2:20,wss = unlist(lapply(clust_list, `[[`, 1))))+
  geom_point(aes(k, wss, col = wss))+
  geom_line(aes(k, wss, col = wss))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("k")+
  ylab("Total WCSS")+
  scale_color_continuous(type = "viridis")

# Select 11 clusters
set.seed(22)
cur_clusters <- kmeans(sce_test$aggregatedNeighbors, centers = 11, nstart = 5)$cluster

sce_test$cellular_neighborhood <- as.factor(cur_clusters)

# Viz
for_plot <- colData(sce_test) %>% as_tibble() %>%
    group_by(cellular_neighborhood, metacluster_combined) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = cellular_neighborhood, names_from = metacluster_combined, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>%
    select(-cellular_neighborhood)

pheatmap(for_plot, #color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column", show_rownames = TRUE, cluster_rows = FALSE)

## NO STRONG DIFFERENCES TO PROPORTION APPROACH - ALSO FOR OS, DFS, DIFF. ABUNDANCE
```

# 3.2 Spatial contexts

## Detect SC

Here, we will define spatial contexts based on the previous CN assignments.

```{r detectSpatialContext}
# Generate k-nearest neighbor graph for SC detection (k=40) 
sce <- buildSpatialGraph(sce, 
                         img_id = "sample_id", 
                         type = "knn", 
                         name = "knn_spatialcontext_graph", 
                         k = 40,
                         BPPARAM = MulticoreParam(progressbar = TRUE, workers = 20))

# Aggregate based on clustered_neighbors
sce <- aggregateNeighbors(sce, 
                          colPairName = "knn_spatialcontext_graph",
                          aggregate_by = "metadata",
                          count_by = "cellular_neighborhood",
                          name = "aggregatedNeighborhood")

# Detect spatial contexts
sce <- detectSpatialContext(sce, 
                            entry = "aggregatedNeighborhood",
                            threshold = 0.90,
                            name = "spatial_context")

length(unique(sce$spatial_context))
```

## Filter SC 

```{r}
#Abundant SC - at least 20 PID and 500 cells
sce <- filterSpatialContext(sce, group_by = "PID", group_threshold = 15, cells_threshold = 1000)

#20, 500

dat <- metadata(sce)$filterSpatialContext
length(unique(sce$spatial_context_filtered))
SC <- metadata(sce)$filterSpatialContext

# Define SC color scheme and add to metadata
col_SC <- setNames(colorRampPalette(brewer.pal(8, "Accent"))(length(unique(sce$spatial_context_filtered))), 
                   sort(unique(sce$spatial_context_filtered)))

metadata(sce)$colors$col_SC <- col_SC 
```

```{r save_objects, message = FALSE, warning=FALSE}
#Save sce
saveRDS(sce, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")
```

## Plot SC Graph 

```{r}
plotSpatialContext(sce, entry = "spatial_context_filtered", 
                   group_by = "PID", node_color_by = "name", node_size_by = "n_cells")+
  #scale_color_manual(values = metadata(sce)$colors$col_SC)


plotSpatialContext(sce, entry = "spatial_context_filtered", 
                   group_by = "PID", node_color_by = "n_group", node_size_by = "n_cells")+
  scale_color_viridis()
```

## Image visualization 

```{r}
set.seed(22)
cur_sam <- sample(unique(sce$sample_id), 6)
cur_sam <- c("ZTMA249.2_ZTMA249_ID_183_BX7Y8_208")

sce$sample_id[which(str_detect(sce$sample_id,"ZTMA249_ID_183_BX7Y8"))]

# Cellular Neighborhoods
p1 <- plotSpatial(sce[,sce$sample_id %in% cur_sam], 
            node_color_by = "cellular_neighborhood", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood)

# Spatial Contexts
p2 <- plotSpatial(sce[,sce$sample_id %in% cur_sam], 
            node_color_by = "spatial_context_filtered", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_manual(values = metadata(sce)$colors$col_SC, limits = force)

p1+p2
```

## Patient visualization

```{r}
## 1. Fraction of CN per PID
dittoBarPlot(sce, var = "spatial_context_filtered", group.by = "PID")+
  scale_fill_manual(values = metadata(sce)$colors$col_SC)+
  theme(axis.text.x = element_blank())

## 2. Fraction of PID per CN
dittoBarPlot(sce, var = "PID", group.by = "spatial_context_filtered")+
  scale_fill_manual(values = metadata(sce)$colors$PID)+
  guides(fill = "none")
```

## Survival analysis

### Lasso - OS

```{r lasso OS clusters}
library(glmnet)
library(broom) 

PID_SC <- colData(sce) %>% as.data.frame() %>% select(spatial_context_filtered,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_SC <- PID_SC %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))
PID_SC <- PID_SC %>% pivot_wider(id_cols = "PID",names_from = "spatial_context_filtered",values_from = "fra") %>% column_to_rownames("PID")

### Lasso regularization
### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)

## 1. Based on continuous cluster proportions
Cox_df <- PID_SC

#add covariates for correction
Cox_df$status_OS <- sce$status_OS[match(rownames(Cox_df),sce$PID)]
Cox_df$OS_months <- sce$OS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)]) #remove from model otherwise coefficients are shrinked to 0 for all others? 

## Run lasso regularized coxph model
Cox_df <- Cox_df[complete.cases(Cox_df),] #only have complete rows as input

x <- data.matrix(Cox_df %>% select(-status_OS,-OS_months)) #predictor variables

y <- Surv(time = Cox_df$OS_months, event = Cox_df$status_OS) #response variables

set.seed(22)
cv.fit <- cv.glmnet(x, y, family="cox", type.measure = "C")
plot(cv.fit)

fit <- glmnet(x, y, family="cox")

coef(fit, s = cv.fit$lambda.min)

# ## Run lasso 100 times and average error curves to be more robust
# set.seed(22)
# MSEs <- NULL
# for (i in 1:10){
#                  cv <- cv.glmnet(x, y, family="cox", type.measure = "C")
#                  MSEs <- cbind(MSEs, cv$cvm)
#              }
# 
# rownames(MSEs) <- cv$lambda
# lambda.min <- as.numeric(names(which.min(rowMeans(MSEs))))
# 
# fit <- glmnet(x, y, family="cox")
# coef(fit, s = lambda.min)

#Extract output
lasso_df <- tidy(coef(fit, s = cv.fit$lambda.min))
colnames(lasso_df) <- c("predictor","column","coef")

#Visualize hazard ratios
lasso_plot <- ggplot(lasso_df, aes(x = reorder(predictor,-exp(coef)), y = exp(coef))) +
  geom_point(size = 4, aes(color = exp(coef)>1)) +
  geom_hline(yintercept = 1,color = "black")+
  scale_y_continuous(trans="log")+
  ylab("Lasso HR")+
  xlab("Predictors")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90))+
  ggtitle("OS")+
  scale_color_brewer(palette = "Set1")
  scale_color_manual(values = metadata(sce)$colors$cluster_110, limits = force, na.value = "black")
  lasso_plot
```
### Lasso - DFS

```{r lasso OS clusters}
library(glmnet)
library(broom) 

PID_SC <- colData(sce) %>% as.data.frame() %>% select(spatial_context_filtered,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_SC <- PID_SC %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))
PID_SC <- PID_SC %>% pivot_wider(id_cols = "PID",names_from = "spatial_context_filtered",values_from = "fra") %>% column_to_rownames("PID")

### Lasso regularization
### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)

## 1. Based on continuous cluster proportions
Cox_df <- PID_SC

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)]) #remove from model otherwise coefficients are shrinked to 0 for all others? 

## Run lasso regularized coxph model
Cox_df <- Cox_df[complete.cases(Cox_df),] #only have complete rows as input

Cox_df <- Cox_df %>% filter(DFS_months != 0)

x <- data.matrix(Cox_df %>% select(-status_DFS,-DFS_months)) #predictor variables

y <- Surv(time = Cox_df$DFS_months, event = Cox_df$status_DFS) #response variables

require(doMC)
registerDoMC(cores = 20)
set.seed(22)
cv.fit <- cv.glmnet(x, y, family="cox", type.measure = "C", nfolds = 50, parallel = TRUE)
plot(cv.fit)

fit <- glmnet(x, y, family="cox")

coef(fit, s = cv.fit$lambda.min)

# ## Run lasso 100 times and average error curves to be more robust
# MSEs <- NULL
# for (i in 1:100){
#                  cv <- cv.glmnet(x, y, family="cox", type.measure = "C")
#                  MSEs <- cbind(MSEs, cv$cvm)
#              }
# 
# rownames(MSEs) <- cv$lambda
# lambda.min <- as.numeric(names(which.min(rowMeans(MSEs))))
# 
# fit <- glmnet(x, y, family="cox")
# coef(fit, s = lambda.min)

#Extract output
lasso_df <- tidy(coef(fit, s = cv.fit$lambda.min))
colnames(lasso_df) <- c("predictor","column","coef")

#Visualize hazard ratios
lasso_plot <- ggplot(lasso_df, aes(x = reorder(predictor,-exp(coef)), y = exp(coef))) +
  geom_point(size = 4, aes(color = exp(coef)>1)) +
  geom_hline(yintercept = 1,color = "black")+
  scale_y_continuous(trans="log")+
  ylab("Lasso HR")+
  xlab("Predictors")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90))+
  ggtitle("DFS")+
  scale_color_brewer(palette = "Set1")
  scale_color_manual(values = metadata(sce)$colors$cluster_110, limits = force, na.value = "black")
lasso_plot
```

# 3.3 Spatial communities 

## Detect Spatial Community

```{r detect spatial community}
library(igraph)

set.seed(22)

# Spatial community detection - tumor
tumor_sce <- sce[,sce$analysis_cat == "tumor"]

gr <- graph_from_data_frame(as.data.frame(colPair(tumor_sce, "neighborhood")), 
                            directed = FALSE, 
                            vertices = data.frame(index = seq_len(ncol(tumor_sce))))

cl_comm <- cluster_louvain(gr)
comm_tumor <- paste0("tumor_", membership(cl_comm))
comm_tumor[membership(cl_comm) %in% which(sizes(cl_comm) < 10)] <- NA
names(comm_tumor) <- colnames(tumor_sce)

tumor_sce$spatial_community <- comm_tumor

# Spatial community detection - non-tumor
stroma_sce <- sce[,sce$analysis_cat == "non_tumor"]

gr <- graph_from_data_frame(as.data.frame(colPair(stroma_sce, "neighborhood")), 
                            directed = FALSE, 
                            vertices = data.frame(index = seq_len(ncol(stroma_sce))))

cl_comm <- cluster_louvain(gr)
comm_stroma <- paste0("TME_", membership(cl_comm))
comm_stroma[membership(cl_comm) %in% which(sizes(cl_comm) < 10)] <- NA
names(comm_stroma) <- colnames(stroma_sce)

length(unique(comm_tumor))
length(unique(comm_stroma))

stroma_sce$spatial_community <- comm_stroma

# Combine and add to sce
comm <- c(comm_tumor, comm_stroma)

sce$spatial_community <- comm[colnames(sce)]
```

```{r}
set.seed(22)
sce <- detectCommunity(sce, 
                colPairName = "neighborhood", 
                size_threshold = 10, 
                group_by = "analysis_cat", 
                name = "spatial_community", 
                BPPARAM = MulticoreParam(workers = 20, RNGseed = 123)
                )

length(unique(sce$spatial_community))
```

## Detect recurrent Spatial Communities

1. For Tumor communities 

```{r filter tumor communities}
library(pheatmap)
library(viridis)

tumor_sce <- sce[,sce$analysis_cat == "tumor"]

tumor_sce$metacluster_combined <- unfactor(tumor_sce$metacluster_combined)

for_plot <- prop.table(table(tumor_sce$spatial_community, tumor_sce$metacluster_combined), margin = 1)

pheatmap(for_plot, color = viridis(100), show_rownames = FALSE, name = "Fraction per community")

## Identify recurrent spatial communities 

cur_dat <- colData(tumor_sce) %>% as.data.frame() %>% select(spatial_community, metacluster_combined) %>% group_by(spatial_community) %>% table() %>% as.data.frame
cur_dat <- cur_dat %>% group_by(spatial_community) %>% mutate(fra = Freq/sum(Freq)) 
cur_dat <- cur_dat  %>% select(-Freq) %>% pivot_wider(id_cols = spatial_community,names_from = metacluster_combined,values_from = fra) %>% column_to_rownames("spatial_community")

# Perform cluster sweep for kmeans (silhouette width, wcss)
set.seed(22)
clust_list <- lapply(2:20, function(k){
  cur_km <- kmeans(cur_dat, centers = k)
  return(list(wss = sum(cur_km$withinss),
           clusters = cur_km$cluster))
})

sil <- vapply(lapply(clust_list, `[[`, 2), 
              function(x) mean(approxSilhouette(cur_dat, x)$width), 
              0)

ggplot(data.frame(k = 2:20, sil = sil))+
  geom_point(aes(k, sil, col = sil))+
  geom_line(aes(k, sil,col=sil))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  xlab("k")+
  ylab("Mean silhouette width")+
  scale_color_continuous(type = "viridis")

ggplot(data.frame(k = 2:20,wss = unlist(lapply(clust_list, `[[`, 1))))+
  geom_point(aes(k, wss, col = wss))+
  geom_line(aes(k, wss, col = wss))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("k")+
  ylab("Total WCSS")+
  scale_color_continuous(type = "viridis")

# Select 10 clusters
set.seed(22)
tumor_cur_clusters <- kmeans(cur_dat, centers = 10, nstart = 100)$cluster

tumor_sce$tumor_meta_community <- tumor_cur_clusters[match(tumor_sce$spatial_community, names(tumor_cur_clusters))]

# Visualize 
for_plot <- prop.table(table(tumor_sce$spatial_metacommunity, tumor_sce$metacluster_combined), margin = 1)
#rownames(for_plot) <- paste0("tumor_SMC_",rownames(for_plot))

scale(for_plot)

pheatmap(for_plot, show_rownames = TRUE, scale = "column", name = "scaled fraction")

```

2. For Stroma communities 

```{r filter stroma communities}
stroma_sce <- sce[,sce$analysis_cat == "non_tumor"]

stroma_sce$metacluster_combined <- unfactor(stroma_sce$metacluster_combined)

for_plot <- prop.table(table(stroma_sce$spatial_community, stroma_sce$metacluster_combined), margin = 1)

pheatmap(for_plot, color = viridis(100), show_rownames = FALSE, name = "Fraction per community")

## Identify recurrent spatial communities 

cur_dat <- colData(stroma_sce) %>% as.data.frame() %>% select(spatial_community, metacluster_combined) %>% group_by(spatial_community) %>% table() %>% as.data.frame
cur_dat <- cur_dat %>% group_by(spatial_community) %>% mutate(fra = Freq/sum(Freq)) 
cur_dat <- cur_dat  %>% select(-Freq) %>% pivot_wider(id_cols = spatial_community,names_from = metacluster_combined,values_from = fra) %>% column_to_rownames("spatial_community")

# Perform cluster sweep for kmeans (silhouette width, wcss)
set.seed(22)
clust_list <- lapply(2:20, function(k){
  cur_km <- kmeans(cur_dat, centers = k)
  return(list(wss = sum(cur_km$withinss),
           clusters = cur_km$cluster))
})

sil <- vapply(lapply(clust_list, `[[`, 2), 
              function(x) mean(approxSilhouette(cur_dat, x)$width), 
              0)

ggplot(data.frame(k = 2:20, sil = sil))+
  geom_point(aes(k, sil, col = sil))+
  geom_line(aes(k, sil,col=sil))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  xlab("k")+
  ylab("Mean silhouette width")+
  scale_color_continuous(type = "viridis")

ggplot(data.frame(k = 2:20,wss = unlist(lapply(clust_list, `[[`, 1))))+
  geom_point(aes(k, wss, col = wss))+
  geom_line(aes(k, wss, col = wss))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  xlab("k")+
  ylab("Total WCSS")+
  scale_color_continuous(type = "viridis")

# Select 6 clusters
set.seed(22)
stroma_cur_clusters <- kmeans(cur_dat, centers = 6, nstart = 100)$cluster

stroma_sce$stroma_meta_community <- stroma_cur_clusters[match(stroma_sce$spatial_community, names(stroma_cur_clusters))]


# Visualize 
for_plot <- prop.table(table(stroma_sce$spatial_metacommunity, stroma_sce$metacluster_combined), margin = 1)
#rownames(for_plot) <- paste0("TME_SMC_",rownames(for_plot))

pheatmap(for_plot, show_rownames = TRUE, scale = "column", name = "scaled fraction")
```

Add to sce

```{r}
cur_clusters <- c(paste0("tumor_SMC_",tumor_cur_clusters),paste0("TME_SMC_",stroma_cur_clusters))
names(cur_clusters) <- c(names(tumor_cur_clusters), names(stroma_cur_clusters))

sce$spatial_metacommunity <- cur_clusters[match(sce$spatial_community, names(cur_clusters))]
```

```{r save_objects, message = FALSE, warning=FALSE}
#Save sce
saveRDS(sce, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")
```

## Image visualization

```{r}
set.seed(22)
cur_sam <- sample(unique(sce$sample_id), 6)

# Spatial_metacommunity
plotSpatial(sce[,sce$sample_id %in% cur_sam], 
            node_color_by = "spatial_metacommunity", 
            img_id = "sample_id", 
            node_size_fix = 0.5)

## Specifically spatial metacommunity 3
cur_sample <- colData(sce) %>% as.data.frame %>% group_by(spatial_metacommunity) %>% filter(spatial_metacommunity == "tumor_SMC_8") %>% count(sample_id) %>% arrange(desc(n)) %>% slice(1:15) %>% pull(sample_id)

plotSpatial(tumor_sce[,tumor_sce$sample_id %in% cur_sample], 
            node_color_by = "metacluster_combined", 
            img_id = "sample_id", 
            node_size_fix = 0.5)+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined)

plotSpatial(sce[,sce$sample_id %in% cur_sample], 
            node_color_by = "spatial_metacommunity", 
            img_id = "sample_id", 
            node_size_fix = 0.5)
  
```

## Patient visualization

```{r}
## 1. Fraction of SMC per PID
dittoBarPlot(sce, var = "spatial_metacommunity", group.by = "PID")+
  theme(axis.text.x = element_blank())
```

## Metacommunity size analysis

```{r}
# Mean Metacommunity cell number - per PID
com_size <- colData(sce) %>% as.data.frame %>% select(PID, cell_id, spatial_metacommunity) %>% filter(!is.na(spatial_metacommunity)) %>% group_by(PID, spatial_metacommunity) %>% count() 

com_tumor_size <- com_size %>% filter(str_detect(spatial_metacommunity,"tumor_"))

ggplot(com_tumor_size, aes(x = reorder(spatial_metacommunity,n), y = n))+
  geom_boxplot(outlier.color = NA)+
  geom_jitter(aes(color = spatial_metacommunity), size = 3, position=position_jitter(w=0.1,h=0.1))+
  #coord_cartesian(ylim = c(3,13))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90))+
  ylab("Mean metacommunity cell number per PID")+
  stat_compare_means(method = "kruskal.test")

# Mean metacommunity density - per PID
com_size$tissue_area <- sce$tissue_area[match(com_size$PID, sce$PID)]
com_density <- com_size %>% mutate(density = n/(tissue_area/1000000))

com_tumor_density <- com_density %>% filter(str_detect(spatial_metacommunity,"tumor_"))

ggplot(com_tumor_density, aes(x = reorder(spatial_metacommunity,density), y = density))+
  geom_boxplot(outlier.color = NA)+
  geom_jitter(aes(color = spatial_metacommunity), size = 3, position=position_jitter(w=0.1,h=0.1))+
  #coord_cartesian(ylim = c(3,13))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90))+
  ylab("Mean metacommunity density per PID")+
  stat_compare_means(method = "kruskal.test")


# Number of cells per metacommunity - per Community
com_1 <- colData(sce) %>% as.data.frame %>% select(PID, spatial_metacommunity, spatial_community) %>% filter(!is.na(spatial_metacommunity)) %>% group_by(PID, spatial_metacommunity, spatial_community) %>% count() 

com_1 <- com_1 %>% filter(str_detect(spatial_metacommunity,"tumor_"))
ggplot(com_1, aes(x = reorder(spatial_metacommunity,n), y = log10(n)))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = spatial_metacommunity), size = 3, position=position_jitter(w=0.1,h=0.1))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90))+
  ylab("Number of cells per metacommunity")+
  stat_compare_means(method = "kruskal.com_1")

# Metacommunity cell density - per Community
com_1$tissue_area <- sce$tissue_area[match(com_1$PID, sce$PID)]
com_1 <- com_1 %>% mutate(density = n/(tissue_area/1000000))
com_1 <- com_1 %>% filter(str_detect(spatial_metacommunity,"tumor_"))

ggplot(com_1, aes(x = reorder(spatial_metacommunity,density), y = log10(density)))+
  geom_boxplot(outlier.color = NA)+
  geom_jitter(aes(color = spatial_metacommunity), size = 3, position=position_jitter(w=0.1,h=0.1))+
  #coord_cartesian(ylim = c(3,13))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90))+
  ylab("Metacommunity density per PID")+
  stat_compare_means(method = "kruskal.com_1")
```

## Survival analysis 

### For OS on community proportions

```{r cox}
library(survival)
library(survminer)

PID_spatial_metacommunity <- colData(sce) %>% as.data.frame() %>% select(spatial_metacommunity,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_spatial_metacommunity <- PID_spatial_metacommunity %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_spatial_metacommunity %>% pivot_wider(id_cols = "PID",names_from = "spatial_metacommunity",values_from = "fra") %>% column_to_rownames("PID")

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_OS <- sce$status_OS[match(rownames(Cox_df),sce$PID)]
Cox_df$OS_months <- sce$OS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#Based on proportions
covariates <- Cox_df %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -tumor_SMC_5) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+ tumor_SMC_5"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratios
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("SMC")+
ylab("HR for con_prop")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop

## 2. Based on categories (mean division of cluster proportions)
Cox_df_mean <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
Cox_df %>% select(i) %>% mutate(mean = ifelse(Cox_df[,i] > mean(Cox_df[,i]),"B","A")) %>% pull(mean)
}

colnames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_mean <- as.data.frame(Cox_df_mean)

identical(rownames(Cox_df), rownames(Cox_df_mean))

Cox_df_mean <- cbind(Cox_df_mean, Cox_df %>% select(status_OS,OS_months, status_OS, OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_mean %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_mean)

summary(multi_model)

multi_res <- summary(multi_model)

plot_df_mean <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_mean <- ggplot(plot_df_mean, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("SMC")+
ylab("HR for mean")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_mean

## 3. Based on categories (GMM division of cluster proportions)
Cox_df_GMM <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
GMM_Cox <- Mclust(Cox_df[,i], G = 2)
as.character(GMM_Cox$classification)
}

colnames(Cox_df_GMM) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_GMM) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_GMM <- as.data.frame(Cox_df_GMM,stringsAsFactors=TRUE)

identical(rownames(Cox_df), rownames(Cox_df_GMM))

Cox_df_GMM <- cbind(Cox_df_GMM, Cox_df %>% select(status_OS,OS_months, status_OS, OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_GMM %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_GMM)

summary(multi_model)

summary(Cox_df_GMM)

multi_res <- summary(multi_model)

plot_df_GMM <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_GMM <- ggplot(plot_df_GMM, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("SMC")+
ylab("HR for GMM")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop/
hr_mean
#/
#hr_GMM
```

### For DFS on community proportions

```{r cox}
library(survival)
library(survminer)

PID_spatial_metacommunity <- colData(sce) %>% as.data.frame() %>% select(spatial_metacommunity,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_spatial_metacommunity <- PID_spatial_metacommunity %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_spatial_metacommunity %>% pivot_wider(id_cols = "PID",names_from = "spatial_metacommunity",values_from = "fra") %>% column_to_rownames("PID")

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#Based on proportions
covariates <- Cox_df %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -tumor_SMC_5) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+ tumor_SMC_5"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratios
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("SMC")+
ylab("HR for con_prop")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop

## 2. Based on categories (mean division of cluster proportions)
Cox_df_mean <- foreach(i = Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
Cox_df %>% select(i) %>% mutate(mean = ifelse(Cox_df[,i] > mean(Cox_df[,i]),"B","A")) %>% pull(mean)
}

colnames(Cox_df_mean) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_mean) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_mean <- as.data.frame(Cox_df_mean)

identical(rownames(Cox_df), rownames(Cox_df_mean))

Cox_df_mean <- cbind(Cox_df_mean, Cox_df %>% select(status_DFS,DFS_months, status_DFS, DFS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_mean %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_mean)

summary(multi_model)

multi_res <- summary(multi_model)

plot_df_mean <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_mean <- ggplot(plot_df_mean, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("SMC")+
ylab("HR for mean")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_mean

## 3. Based on categories (GMM division of cluster proportions)
Cox_df_GMM <- foreach(i = Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
GMM_Cox <- Mclust(Cox_df[,i], G = 2)
as.character(GMM_Cox$classification)
}

colnames(Cox_df_GMM) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_GMM) <- Cox_df %>% select(-status_DFS,-DFS_months, -status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_GMM <- as.data.frame(Cox_df_GMM,stringsAsFactors=TRUE)

identical(rownames(Cox_df), rownames(Cox_df_GMM))

Cox_df_GMM <- cbind(Cox_df_GMM, Cox_df %>% select(status_DFS,DFS_months, status_DFS, DFS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_GMM %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_GMM)

summary(multi_model)

summary(Cox_df_GMM)

multi_res <- summary(multi_model)

plot_df_GMM <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_GMM <- ggplot(plot_df_GMM, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("SMC")+
ylab("HR for GMM")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop/
hr_mean/
hr_GMM
```

# 3.4 Interaction testing

## Classical method

A) Classical method: "How many neighbors of type B does a cell of type A have on average?"

```{r interaction testing}
library(scales)
out <- testInteractions(sce, 
                        method = "classic",
                        group_by = "PID",
                        label = "metacluster_combined", 
                        colPairName = "neighborhood",
                        BPPARAM = MulticoreParam())
head(out)
```

```{r viz interaction}
library(scales)
out_viz <- out %>% as_tibble() %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>% 
  pivot_wider(id_cols = "from_label", names_from = "to_label", values_from = "sum_sigval") %>%
  column_to_rownames("from_label")

Heatmap(out_viz,
        name = "Interaction_score",
        row_title = "from_label",
        column_title = "to_label",
        cluster_columns = FALSE,
        cluster_rows = FALSE)
```

## Patch method 

B) Patch method - "What fraction of cells of type A have at least a given number of neighbors of type B?"

```{r}
out <- testInteractions(sce, 
                        group_by = "sample_id",
                        label = "metacluster_combined", 
                        colPairName = "neighborhood",
                        method = "patch", 
                        patch_size = 5,
                        BPPARAM = MulticoreParam())
head(out)
```

```{r}
library(scales)
out_viz <- out %>% as_tibble() %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>% 
  pivot_wider(id_cols = "from_label", names_from = "to_label", values_from = "sum_sigval") %>%
  column_to_rownames("from_label")

Heatmap(out_viz,
        name = "Interaction_score",
        row_title = "from_label",
        column_title = "to_label",
        cluster_columns = FALSE,
        cluster_rows = FALSE)
```


# 3.5 Patch detection

## Detect Patch

Example: For Tumor_6 

```{r patch}
## Patch detection
sce <- patchDetection(sce,
               patch_cells = sce$metacluster_combined == "tumor_6",
               colPairName = "knn_interaction_graph",
               min_patch_size = 15,
               name = "patch_tumor_6",
               expand_by = 0, 
               img_id = "sample_id", 
               BPPARAM = MulticoreParam())

unique(sce$patch_tumor_6)
length(unique(sce$patch_tumor_6))

#subset sce to 20 images with most cluster cells
cur_sam <- colData(sce) %>% as.data.frame %>% select(sample_id, metacluster_combined) %>% filter(metacluster_combined == "tumor_6") %>% group_by(metacluster_combined) %>% count(sample_id) %>% arrange(desc(n)) %>% slice(1:10) %>% pull(sample_id)

#Visualize
plotSpatial(sce[,sce$sample_id %in% cur_sam], img_id = "sample_id", node_color_by = "metacluster_combined")+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined) #Cell Types
plotSpatial(sce[,sce$sample_id %in% cur_sam], img_id = "sample_id", node_color_by = "patch_tumor_6") #Patch
```

### For Tumor patches in general 

```{r patch}
## Combine tumor clusters 
sce$metacluster_tumor_combined <- ifelse(str_detect(unfactor(sce$metacluster_combined),"tumor"),"tumor",unfactor(sce$metacluster_combined))

## Patch detection
sce <- patchDetection(sce,
               patch_cells = sce$metacluster_tumor_combined == "tumor",
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = "patch_tumor",
               expand_by = 0, 
               img_id = "sample_id", 
               BPPARAM = MulticoreParam(workers = 20))

unique(sce$patch_tumor)
length(unique(sce$patch_tumor))

#select 10 images
set.seed(22)
cur_sam <- sample(sce$sample_id, 10)

#Visualize
plotSpatial(sce[,sce$sample_id %in% cur_sam], img_id = "sample_id", node_color_by = "metacluster_combined")+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined) #Cell Types
plotSpatial(sce[,sce$sample_id %in% cur_sam], img_id = "sample_id", node_color_by = "patch_tumor") #Patch
```

### All phenotypes 

```{r patch-milieu}
# Patch detection for all phenotypes

for(i in unfactor(unique(sce$metacluster_combined))){ 
  sce <- patchDetection(sce,
               patch_cells = sce$metacluster_combined == i,
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = paste0("patch_",i),
               expand_by = 0, 
               img_id = "sample_id",
               BPPARAM = MulticoreParam(workers = 20))
}

#subset sce to 20 images with most cluster cells
#cur_sam <- colData(sce) %>% as.data.frame %>% select(sample_id, metacluster_combined) %>% filter(metacluster_combined == "tumor_6") %>% group_by(metacluster_combined) %>% count(sample_id) %>% arrange(desc(n)) %>% slice(1:10) %>% pull(sample_id)

#Visualize
#plotSpatial(sce[,sce$sample_id %in% cur_sam], img_id = "sample_id", node_color_by = "metacluster_combined")+
#  scale_color_manual(values = metadata(sce)$colors$metacluster_combined) #Cell Types
#plotSpatial(sce[,sce$sample_id %in% cur_sam], img_id = "sample_id", node_color_by = "patch_tumor_6") #Patch
#plotSpatial(sce[,sce$sample_id %in% cur_sam], img_id = "sample_id", node_color_by = "milieu_tumor_6") #Milieu
```

### MC8 patches and milieus

```{r}
## Patch detection
sce <- patchDetection(sce,
               patch_cells = sce$metacluster_combined == "tumor_8",
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = "patch_MC8",
               expand_by = 0, 
               img_id = "sample_id", 
               BPPARAM = MulticoreParam(workers = 10))
gc()

sce <- patchDetection(sce,
               patch_cells = sce$metacluster_combined == "tumor_8",
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = "milieu_MC8",
               expand_by = 30, 
               img_id = "sample_id",
               BPPARAM = MulticoreParam(workers = 10))
gc()

## Distance to patchAnalysis 
sce <- minDistToCells(sce, img_id = "sample_id", x_cells = !is.na(sce$patch_tumor_8), BPPARAM = MulticoreParam(workers = 10, stop.on.error = FALSE))
```

### CK5/7 score 

```{r}
sce_tumor <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_sce_TNBC_tumor_new.rds")

sce$CK5_7_score <- sce_tumor$CK5_7_score[match(sce$cell_id, sce_tumor$cell_id)]
```

```{r}
sce <- patchDetection(sce,
               patch_cells = ifelse(is.na(sce$CK5_7_score == "CK5/7+") | sce$CK5_7_score != "CK5/7+", FALSE, TRUE),
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = "patch_CK57pos",
               expand_by = 0, 
               img_id = "sample_id",
               BPPARAM = MulticoreParam(workers = 20))

sce <- patchDetection(sce,
               patch_cells = ifelse(is.na(sce$CK5_7_score == "CK5/7+") | sce$CK5_7_score != "CK5/7+", FALSE, TRUE),
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = "milieu_CK57pos",
               expand_by = 30, 
               img_id = "sample_id",
               BPPARAM = MulticoreParam(workers = 20))
gc()
```

```{r save_objects, message = FALSE, warning=FALSE}
#Save sce
saveRDS(sce, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")
```

## Patch size analysis 

```{r}
library(ggpubr)

size_plot <- colData(sce) %>% as.data.frame %>% select(PID, cell_id, contains("patch_")) %>% pivot_longer(cols = 3:ncol(.),names_to = "patch_name", values_to = "patch_ID") %>% filter(!is.na(patch_ID)) %>% group_by(PID, patch_name, patch_ID) %>% count() 

# Mean tumor patch size per PID 
size_tumor_plot <- size_plot %>% filter(str_detect(patch_name,"patch_tumor_")) %>% group_by(PID,patch_name) %>% mutate(mean_PID = mean(n), median_PID = median(n)) %>% select(patch_name,median_PID,mean_PID) %>% unique()

size_tumor_plot$metacluster <- str_replace(size_tumor_plot$patch_name, "patch_","")

ggplot(size_tumor_plot, aes(x = reorder(metacluster,median_PID), y = log2(mean_PID)))+
  geom_boxplot(outlier.color = NA)+
  geom_jitter(aes(color = metacluster), size = 3, position=position_jitter(w=0.1,h=0.1))+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90))+
  stat_compare_means(method = "kruskal.test", label.y = 12.5)+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined)+
  ggtitle("Mean cell number per tumor patch per PID")


# # Mean TME patch size per PID 
# size_TME_plot <- size_plot %>% filter(!str_detect(patch_name,"patch_tumor_") & !str_detect(patch_name,"patch_MC")) %>% group_by(PID,patch_name) %>% mutate(mean_PID = mean(n), median_PID = median(n)) %>% select(patch_name,mean_PID) %>% unique()
# 
# ggplot(size_TME_plot, aes(x = reorder(patch_name,mean_PID), y = log2(mean_PID)))+
#   geom_boxplot(outlier.color = NA)+
#   geom_jitter(aes(color = patch_name), size = 3, position=position_jitter(w=0.1,h=0.1))+
#   coord_cartesian(ylim = c(3,13))+
#   theme_classic()+
#   theme(axis.text.x = element_text(angle = 90))+
#   stat_compare_means(method = "kruskal.test", label.y = 12.5)
```


```{r}
cur_out <- foreach(i=1:11, .combine = "rbind")%do%{
  cur_dat <- as.data.frame(patchSize(sce, patch_name = paste0("patch_tumor_",i)))
  colnames(cur_dat) <- c("patch_id","polygon","size")
  cur_dat$type <- paste0("patch_tumor_",i)
  cur_dat$PID <- sce$PID[match(cur_dat$patch_id, sce[[paste0("patch_tumor_",i)]])]
  return(cur_dat)
  }


cur_out <- cur_out %>% group_by(type) %>% mutate(mean = mean(size), median = median(size))
cur_out <- cur_out %>% group_by(type, PID) %>% mutate(mean_PID = mean(size), median_PID = median(size))

# Plot mean patch size per PID
ggplot(cur_out, aes(x = reorder(type,mean_PID), y = log2(mean_PID)))+
  geom_boxplot(outlier.color = NA)+
  geom_jitter(aes(color = type), size = 3, position=position_jitter(w=0.1,h=0.1))+
  stat_compare_means()
```


# 3.6 MC8 / CK5/7+ score analysis 

## Metacluster 8 

### Heatmap for PID with patches 

```{r}
patch_MC8_PID <- colData(sce) %>% as.data.frame() %>% filter(!is.na(patch_tumor_8)) %>% pull(PID) %>% unique()
cells_MC8_PID <- colData(sce) %>% as.data.frame() %>% select(metacluster_combined,PID) %>% group_by(PID) %>% table() %>% as.data.frame

sce$patch_MC8_classification <- ifelse(sce$PID %in% patch_MC8_PID,"patch_MC8","no_patch_MC8")

PID_patch <- colData(sce) %>% as.data.frame() %>% select(metacluster_combined,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_patch <- PID_patch %>% group_by(PID) %>% filter(PID %in% patch_MC8_PID) %>% filter(str_detect(metacluster_combined,"tumor")) %>% mutate(fra = Freq/sum(Freq)) 

cur_df <- PID_patch %>% pivot_wider(id_cols = "PID", names_from = "metacluster_combined",values_from = "fra") %>% column_to_rownames("PID")

# Perform hierarchical clustering on fractions
dd <- dist(cur_df, method = "euclidean")
hc <- hclust(dd, method = "ward.D2")
plot(hc)
row_sorted <- hc$order

cur_df <- cur_df[row_sorted,]

# Define annotation dataframe
anno <- colData(sce) %>% as.data.frame %>% select(PID, age_bin, grade, pT_simple, pN_simple, pM_simple) %>% unique()
anno <- anno[match(rownames(cur_df), anno$PID),]


# Plot annotation dataframe with ComplexHeatmap
fraction_anno <- HeatmapAnnotation(MC_fractions = anno_barplot(cur_df, gp=gpar(fill=metadata(sce)$colors$metacluster[colnames(cur_df)]),
                                   bar_width = 1,
                                   height = unit(25,"cm"),
                                   width = unit(11,"cm"),
                                   show_row_names = FALSE), 
                          PID = anno_simple(anno$PID, col=metadata(sce)$colors$PID, border=TRUE),
                          age = anno_simple(anno$age_bin, col = metadata(sce)$colors$age_bin, border = TRUE),
                          grade = anno_simple(anno$grade, col = metadata(sce)$colors$grade, border = TRUE),
                          pT = anno_simple(anno$pT_simple, col=metadata(sce)$colors$pT_simple, border=TRUE),
                          pN = anno_simple(anno$pN_simple, col=metadata(sce)$colors$pN_simple, border=TRUE),
                          pM = anno_simple(anno$pM_simple, col=metadata(sce)$colors$pM_simple, border = TRUE),
                          border = TRUE, 
                          #annotation_name_rot = 90,
                          gap = unit(1,"mm"),
                          which = "row")

fraction_anno + NULL
```

### Most abundant phenotype 

```{r}
# most abundant phenotype in patients with MC8 patches 
PID_patch_abundant <- PID_patch %>% #filter(metacluster_combined != "tumor_8") %>% 
  mutate(max = max(fra)) %>% filter(fra == max) %>% ungroup() %>% count(metacluster_combined) %>% mutate(fra = n/sum(n), category = "cat") %>% arrange(fra)

PID_patch_abundant$metacluster_combined <- factor(PID_patch_abundant$metacluster_combined, levels = unfactor(PID_patch_abundant$metacluster_combined))

ggplot(PID_patch_abundant) +
  geom_tile(color = "black",aes(category, n, fill = metacluster_combined), position = "stack")+
  scale_fill_manual(values=metadata(sce)$colors$metacluster_combined) + 
  theme_classic(base_size = 15)+
  ylab("Density")+
  xlab("PID")+
  theme(axis.text.x = element_blank())
```

### Overall frequency plot

```{r}
PID_dom_MC8 <- PID_patch %>% mutate(max = max(fra)) %>% filter(fra == max) %>% ungroup() %>% filter(metacluster_combined == "tumor_8") %>% pull(PID)

PID_overall <- colData(sce) %>% as.data.frame() %>% select(metacluster_combined,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_MC8_overall <- PID_overall %>% group_by(PID) %>% filter(metacluster_combined == "tumor_8" & Freq > 5) %>% mutate(patch = ifelse(PID %in% patch_MC8_PID, TRUE, FALSE)) %>% mutate(dominated = ifelse(PID %in% PID_dom_MC8, TRUE, FALSE)) %>% mutate(PID_category = ifelse(patch && dominated, "dominated", ifelse(patch, "patch", "cells")))                                                                                    
PID_MC8_overall_plot <- PID_MC8_overall %>% group_by(PID_category) %>% count() %>% ungroup() %>% mutate(fra = n/sum(n)) %>% mutate(category = "MC8")


PID_MC8_overall_plot$PID_category <- factor(PID_MC8_overall_plot$PID_category, levels = c("cells","patch","dominated"))

ggplot(PID_MC8_overall_plot) +
  geom_tile(color = "black",aes(category, n, fill = PID_category), position = "stack")+
  scale_fill_brewer(palette = "Blues")+
  theme_classic(base_size = 15)+
  ylab("Density")+
  theme(axis.title.x = element_blank())
```

### Patch distance analysis 

```{r}
library(ggpubr)

## Distance to patchAnalysis 
sce <- minDistToCells(sce, img_id = "sample_id", x_cells = !is.na(sce$patch_tumor_8), name = "distToMC8Patch",BPPARAM = MulticoreParam(workers = 10, stop.on.error = FALSE))

dist_df <- colData(sce) %>% as.data.frame %>% filter(!is.na(distToPatchMC8) & metacluster_combined != "tumor_8") %>% select(sample_id, metacluster_combined, distToPatchMC8) %>% group_by(sample_id, metacluster_combined) %>% summarize(mean = mean(distToPatchMC8))

dist_df$pN_merg <- sce$pN_merg[match(dist_df$sample_id, sce$sample_id)]

# Filter for tumor phenotypes 
dist_df <- dist_df %>% filter(str_detect(metacluster_combined, "tumor"))

# 1. Difference of cell phenotype distances to patches
test_dist <- compare_means(mean ~ metacluster_combined, data = dist_df, method = "kruskal.test")$p

# Density plot 
ggplot(dist_df, aes(mean, color = metacluster_combined))+
  geom_density(size = 0.8)+
  geom_rug()+
  #facet_wrap(~B_cell_score)+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)+
  xlab("Mean distance to MC8 cell patch (per image)")+
  theme_classic()+
  ggtitle(paste("p =",round(test_dist, 4),"(kruskal-wallis)"))

# Boxplot 
ggplot(dist_df, aes(x = reorder(metacluster_combined, mean), y = mean))+
  geom_boxplot()+
  geom_jitter(aes(color = metacluster_combined), size = 3, position=position_jitter(w=0.1,h=0.1))+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90), axis.title.x = element_blank())+
  ylab("Mean distance to MC8 cell patch (per image)")+
  guides(fill = "none")+
  stat_compare_means(method = "kruskal.test")
```

### Interaction testing 

```{r}
sce_tumor <- sce[,sce$analysis_cat == "tumor"]
sce_tumor$metacluster_combined <- unfactor(sce_tumor$metacluster_combined)

# For PID with at least 5 MC8 cells 
PID_overall <- colData(sce_tumor) %>% as.data.frame() %>% select(metacluster_combined,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_MC8_overall <- PID_overall %>% group_by(PID) %>% filter(metacluster_combined == "tumor_8" & Freq > 5)

sce_tumor_MC8 <- sce_tumor[,sce_tumor$PID %in% PID_MC8_overall$PID]

interaction_tumor_MC8 <- testInteractions(sce_tumor_MC8, 
                 group_by = "sample_id", 
                 label = "metacluster_combined", 
                 colPairName = "neighborhood", 
                 BPPARAM = MulticoreParam())

# Full tumor compartments
interaction_tumor <- testInteractions(sce_tumor, 
                  group_by = "sample_id", 
                  label = "metacluster_combined", 
                  colPairName = "neighborhood", 
                  BPPARAM = MulticoreParam())
```

Visualization 

```{r}
interaction_tumor_MC8 %>% as_tibble() %>% filter(from_label %in% c("tumor_8")) %>% filter(to_label != "tumor_8") %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
    ggplot() +
        geom_tile(aes(from_label, to_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  theme_classic()

interaction_tumor_plot <- interaction_tumor_MC8 %>% as_tibble() %>% filter(from_label %in% c("tumor_8")) %>% filter(to_label != "tumor_8") %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE))

ggplot(interaction_tumor_plot) +
        geom_tile(aes(reorder(to_label,sum_sigval), from_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  theme_classic()
```

### Milieu enrichment analysis 

```{r milieu enrich}
#Number of milieus per image
milieu_image <- colData(sce) %>% as.data.frame %>% select(sample_id, milieu_MC8) %>% filter(!is.na(milieu_MC8)) %>% group_by(sample_id) %>% unique() %>% count()
milieu_PID <- colData(sce) %>% as.data.frame %>% select(PID, milieu_MC8) %>% filter(!is.na(milieu_MC8)) %>% group_by(PID) %>% unique() %>% count()

## Milieu enrichment analysis
## Code adopted from Science Immunology paper

cur_res_list <- list()
cur_df <- colData(sce)

# Set thresholds
#perc_cells <- 0

for (i in c("milieu_MC8")){
  
  cur_images <- cur_df %>% 
    as.data.frame %>% 
    select(sample_id, as.name(i)) %>% 
    filter(complete.cases(.)) %>% #remove images with no milieu - also possible to use a threshold
    group_by(sample_id) %>% 
    unique() %>% 
    count()
  
  for (j in unique(cur_df$metacluster_combined)) {
  z <- str_split(i,"u_", simplify = TRUE)[,2]
    cur_res <- cur_df %>% 
      as.data.frame() %>%
      select(sample_id, metacluster_combined, as.name(i)) %>% 
      filter(sample_id %in% cur_images$sample_id) %>%
      filter(metacluster_combined != z) %>%
      group_by(sample_id) %>%
      summarise(inside = sum(metacluster_combined == j & !is.na(.data[[i]])),
            outside = sum(metacluster_combined == j & is.na(.data[[i]])),
            other_inside = sum(metacluster_combined != j & !is.na(.data[[i]])),
            other_outside = sum(metacluster_combined != j & is.na(.data[[i]])))
    
    out_dat <- foreach(x = seq_along(rownames(cur_res)), .combine = "rbind")%do%{
    cur_mat <- matrix(as.numeric(as.vector(cur_res[x,2:5])),ncol = 2, nrow = 2, byrow = FALSE)
    rownames(cur_mat) <- c("cluster", "other_cluster")
    colnames(cur_mat) <- c("inside", "outside")
    cur_test <- fisher.test(cur_mat)
   
    out_dat <- data.frame(
      sample = as.character(as.vector(cur_res[x,1])),
      milieu = i,
      metacluster_combined = j,
      p = cur_test$p.value,
      odds = cur_test$estimate,
      row.names = NULL)
    }
      
cur_res_list[[paste0(i, "_", j)]] <- out_dat

  }   
}

# Final output - Can be interpreted as "Fraction of images with significant enrichment or depletion of cell types within milieus"
out <- do.call("rbind", cur_res_list)
out$adj.p <- p.adjust(out$p, method = "BH")

final <- out %>% mutate(sigval = ifelse(odds > 1 & adj.p < 0.1, 1, ifelse(odds < 1 & adj.p < 0.1, -1, 0))) %>%
    group_by(milieu, metacluster_combined) %>%
    dplyr::summarize(mean = mean(sigval))

# Number of tested images
out %>% 
  group_by(milieu, metacluster_combined) %>% 
  dplyr::summarize(count = n()) %>% 
  as.data.frame()
```

```{r}
final_plot <- final %>% filter(str_detect(metacluster_combined, "tumor"))  %>% filter(metacluster_combined != "tumor_8") %>% arrange(desc(mean))

ggplot(final_plot) +
        geom_tile(aes(milieu, reorder(metacluster_combined,mean), fill = mean)) +
        scale_fill_gradient2(low = "blue", mid = "white", high = "red")+
  theme_classic()+
  theme(axis.title.x = element_blank())
```


### Survival analysis for MC8 patches 

```{r}
# Survival estimations for DFS when patches of MC8 cells are present 

#Assess survival impact 
library(survival)
library(survminer)

cur_surv <- colData(sce) %>% as.data.frame() %>% select(PID, patch_MC8_classification, OS_months, DFS_months, status_DFS, status_OS) %>% unique() 

#Plot survival curves
fit <- survfit(Surv(DFS_months, status_DFS) ~ patch_MC8_classification, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("#377EB8", "#E41A1C"),
          #log.rank.weights = "n"
)
```

Univariate Cox model 

```{r}
library(survival)
library(survminer)

PID_patch_MC8 <- colData(sce) %>% as.data.frame() %>% select(patch_MC8_classification,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_patch_MC8 <- PID_patch_MC8 %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_patch_MC8 %>% pivot_wider(id_cols = "PID",names_from = "patch_MC8_classification",values_from = "fra") %>% column_to_rownames("PID")
#colnames(PID_metagroups) <- paste0("CK57_",colnames(PID_metagroups))

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

#Based on proportions
covariates <- Cox_df %>% select(-status_DFS,-DFS_months, -no_patch_MC8) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~", paste(covariates, collapse = " + "),"+no_patch_MC8"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratiDFS
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
#coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_manual(values = c("#377EB8"))+
xlab("Tumor metaclusters")+
ylab("HR for con_prop")+
theme_classic()+
coord_cartesian(ylim=c(0,5))+
#scale_y_continuous(trans = "log10")
theme(axis.text.x = element_text(angle = 90))

hr_prop
```

Multivariate 

```{r}
library(survival)
library(survminer)

PID_patch_MC8 <- colData(sce) %>% as.data.frame() %>% select(patch_MC8_classification,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_patch_MC8 <- PID_patch_MC8 %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_patch_MC8 %>% pivot_wider(id_cols = "PID",names_from = "patch_MC8_classification",values_from = "fra") %>% column_to_rownames("PID")
#colnames(PID_metagroups) <- paste0("CK57_",colnames(PID_metagroups))

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#Based on proportions
covariates <- Cox_df %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -no_patch_MC8) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+no_patch_MC8"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratiDFS
hr_prop <- 
ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
#coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for con_prop")+
theme_classic()+
coord_cartesian(ylim=c(0,40))+
#scale_y_continuous(trans = "log10")
theme(axis.text.x = element_text(angle = 90))

hr_prop
```


## CK5/7+ 

### Heatmap for PID with patches

```{r}
patch_CK57_PID <- colData(sce) %>% as.data.frame() %>% filter(!is.na(patch_CK57pos)) %>% pull(PID) %>% unique()
cells_MC8_PID <- colData(sce) %>% as.data.frame() %>% select(metacluster_combined,PID) %>% group_by(PID) %>% table() %>% as.data.frame

sce$patch_CK57_classification <- ifelse(sce$PID %in% patch_CK57_PID,"patch_CK57","no_patch_CK57")

PID_patch <- colData(sce) %>% as.data.frame() %>% select(CK5_7_score,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_patch <- PID_patch %>% group_by(PID) %>% filter(PID %in% patch_CK57_PID) %>% mutate(fra = Freq/sum(Freq)) 

cur_df <- PID_patch %>% pivot_wider(id_cols = "PID", names_from = "CK5_7_score",values_from = "fra") %>% column_to_rownames("PID")

# Perform hierarchical clustering on fractions
dd <- dist(cur_df, method = "euclidean")
hc <- hclust(dd, method = "ward.D2")
plot(hc)
row_sorted <- hc$order

cur_df <- cur_df[row_sorted,]

# Define annotation dataframe
anno <- colData(sce) %>% as.data.frame %>% select(PID, age_bin, grade, pT_simple, pN_simple, pM_simple) %>% unique()
anno <- anno[match(rownames(cur_df), anno$PID),]

metadata(sce)$colors$CK5_7_score <- setNames(c("grey",wes_palette("Moonrise3")[1:3]), c("CK5/7-", "CK5/7+","CK5+", "CK7+"))

# Plot annotation dataframe with ComplexHeatmap
fraction_anno <- HeatmapAnnotation(MC_fractions = anno_barplot(cur_df, gp=gpar(fill=metadata(sce)$colors$CK5_7_score[colnames(cur_df)]),
                                   bar_width = 1,
                                   height = unit(25,"cm"),
                                   width = unit(11,"cm"),
                                   show_row_names = FALSE), 
                          PID = anno_simple(anno$PID, col=metadata(sce)$colors$PID, border=TRUE),
                          age = anno_simple(anno$age_bin, col = metadata(sce)$colors$age_bin, border = TRUE),
                          grade = anno_simple(anno$grade, col = metadata(sce)$colors$grade, border = TRUE),
                          pT = anno_simple(anno$pT_simple, col=metadata(sce)$colors$pT_simple, border=TRUE),
                          pN = anno_simple(anno$pN_simple, col=metadata(sce)$colors$pN_simple, border=TRUE),
                          pM = anno_simple(anno$pM_simple, col=metadata(sce)$colors$pM_simple, border = TRUE),
                          border = TRUE, 
                          #annotation_name_rot = 90,
                          gap = unit(1,"mm"),
                          which = "row")

fraction_anno + NULL
```

### Most abundant phenotype 

```{r}
# most abundant phenotype in patients with CK5/7+ score 
PID_patch_abundant <- PID_patch %>% #filter(CK5_7_score != "CK5/7+") %>% 
  mutate(max = max(fra)) %>% filter(fra == max) %>% ungroup() %>% count(CK5_7_score) %>% mutate(fra = n/sum(n), category = "cat") %>% arrange(fra)

PID_patch_abundant$CK5_7_score <- factor(PID_patch_abundant$CK5_7_score, levels = unfactor(PID_patch_abundant$CK5_7_score))

ggplot(PID_patch_abundant) +
  geom_tile(color = "black",aes(category, fra, fill = CK5_7_score), position = "stack")+
  scale_fill_manual(values=metadata(sce)$colors$CK5_7_score) + 
  theme_classic(base_size = 15)+
  ylab("Density")+
  xlab("PID")+
  theme(axis.text.x = element_blank())
```

### Overall frequency plot 

```{r}
PID_dom_CK57 <- PID_patch %>% mutate(max = max(fra)) %>% filter(fra == max) %>% ungroup() %>% filter(CK5_7_score == "CK5/7+") %>% pull(PID)

PID_overall <- colData(sce) %>% as.data.frame() %>% select(CK5_7_score,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_CK57_overall <- PID_overall %>% group_by(PID) %>% filter(CK5_7_score == "CK5/7+" & Freq > 5) %>% mutate(patch = ifelse(PID %in% patch_CK57_PID, TRUE, FALSE)) %>% mutate(dominated = ifelse(PID %in% PID_dom_CK57, TRUE, FALSE)) %>% mutate(PID_category = ifelse(patch && dominated, "dominated", ifelse(patch, "patch", "cells")))                                                                                    
PID_CK57_overall_plot <- PID_CK57_overall %>% group_by(PID_category) %>% count() %>% ungroup() %>% mutate(fra = n/sum(n)) %>% mutate(category = "CK57")


PID_CK57_overall_plot$PID_category <- factor(PID_CK57_overall_plot$PID_category, levels = c("cells","patch","dominated"))

ggplot(PID_CK57_overall_plot) +
  geom_tile(color = "black",aes(category, n, fill = PID_category), position = "stack")+
  scale_fill_brewer(palette = "Blues")+
  theme_classic(base_size = 15)+
  ylab("Density")+
  theme(axis.title.x = element_blank())
```

### Interaction testing 

```{r}
sce_tumor <- sce[,sce$analysis_cat == "tumor"]

# For PID with CK5/7 patch 
PID_overall <- colData(sce_tumor) %>% as.data.frame() %>% select(metacluster_combined,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_MC8_overall <- PID_overall %>% group_by(PID) %>% filter(metacluster_combined == "tumor_8" & Freq > 5)

sce_tumor_CK57 <- sce_tumor[,sce_tumor$PID %in% PID_MC8_overall$PID]

interaction_tumor_CK57 <- testInteractions(sce_tumor_CK57, 
                 group_by = "sample_id", 
                 label = "CK5_7_score", 
                 colPairName = "neighborhood", 
                 BPPARAM = MulticoreParam())
```

Visualization 

```{r}
interaction_tumor_CK57 %>% as_tibble() %>% 
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
    ggplot() +
        geom_tile(aes(from_label, to_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  theme_classic()

interaction_tumor_CK57_total %>% as_tibble() %>% filter(from_label %in% c("CK5/7+")) %>% filter(to_label != "CK5/7+") %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
    ggplot() +
        geom_tile(aes(from_label, to_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  theme_classic()
```




## Patch distance analysis 

```{r dist to patch}
sce <- minDistToCells(sce, img_id = "sample_id", x_cells = !is.na(sce$patch_tumor_8), name = "distToMC8patch", BPPARAM = MulticoreParam(workers = 10, stop.on.error = FALSE))

## Visualize 
library(wesanderson)
pal <- wes_palette("Zissou1", 100, type = "continuous")

test_df <- colData(sce) %>% as.data.frame %>% filter(!is.na(distToMC8patch) & metacluster_combined != "tumor_8") %>% filter(str_detect(metacluster_combined, "tumor")) %>% select(PID, metacluster_combined, distToMC8patch) %>% group_by(PID, metacluster_combined) %>% summarize(mean = mean(distToMC8patch))

#Boxplot
ggplot(test_df, aes(x = reorder(metacluster_combined, mean), y = mean))+
  geom_boxplot()+
  geom_jitter(aes(color = metacluster_combined), size = 3, position=position_jitter(w=0.1,h=0.1))+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90), axis.title.x = element_blank())+
  ylab("Mean distance to patch")+
  ggtitle("patch_tumor_6")+
  guides(fill = "none")+
  stat_compare_means()
  
#Density plot  
ggplot(test_df, aes(mean, color = metacluster_combined))+
  geom_density(size = 0.8)+
  geom_rug()+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined)+
  xlab("Mean distance to patch (per image)")+
  ggtitle("patch_tumor_6")+
  theme_classic()
```



# 3.6 Immune scores 

```{r}
## Combine tumor clusters 
sce$metacluster_tumor_combined <- ifelse(str_detect(unfactor(sce$metacluster_combined),"tumor"),"tumor",unfactor(sce$metacluster_combined))

sce <- aggregateNeighbors(sce, colPairName = "neighborhood", aggregate_by = "metadata", count_by = "metacluster_tumor_combined", proportions = FALSE, name = "count_neighbors")
```

## Spatial CD8 Phenotype
based on Ruben Casanova and Hammerl et al., 2022

```{r}
## Step 1: CD8 T cell type scoring 
cur_dat <- sce$count_neighbors %>% as.data.frame
rownames(cur_dat) <- sce$cell_id
cur_dat$PID <- sce$PID
cur_dat$metacluster_tumor_combined <- sce$metacluster_tumor_combined

# Define CD8+ T cells as infiltrating, bystanding, ignored
cur_dat <- cur_dat %>% filter(metacluster_tumor_combined == "CD8_T_cell") %>% 
  mutate(CD8Tcell_type = ifelse(tumor >= 3, "infiltrating", 
                                ifelse(tumor < 3 & tumor > 0, "bystanding", "ignored")))

sce$CD8Tcell_type <- cur_dat$CD8Tcell_type[match(sce$cell_id, rownames(cur_dat))]
  
## Fraction and count of CD8Tcell_type per PID
p1 <- dittoBarPlot(sce[,!is.na(sce$CD8Tcell_type)], var = "CD8Tcell_type", group.by = "PID")+
  theme(axis.text.x = element_blank(), axis.title.x = element_blank())

p2 <- dittoBarPlot(sce[,!is.na(sce$CD8Tcell_type)], var = "CD8Tcell_type", group.by = "PID", scale = "count")+
  theme(axis.text.x = element_blank())+
  ggtitle("")

p1 / p2
```

Visualization 

```{r}
# Select images of interest
cur_sample <- (colData(sce) %>% as.data.frame %>% select(sample_id, spatial_CD8_pheno) %>% group_by(sample_id) %>% filter(spatial_CD8_pheno == "inflamed") %>% count() %>% arrange(desc(n)) %>% pull(sample_id))[1:10]

cur_images <- images[mcols(images)$sample_id %in% cur_sample]
cur_masks <- masks[mcols(masks)$sample_id %in% cur_sample]
cur_sce <- sce[,sce$sample_id %in% cur_sample & sce$metacluster_tumor_combined %in% c("tumor", "CD8_T_cell")]

cur_sce$CD8Tcell_tumor_type <- ifelse(is.na(cur_sce$CD8Tcell_type), "tumor", cur_sce$CD8Tcell_type)
```

We will use cytoviewer for image exploration and download

```{r}
library(cytoviewer)
app <- cytoviewer(image = cur_images, mask = cur_masks, object = cur_sce, img_id = "sample_id", cell_id = "ObjectNumber")

shiny::runApp(app)
```


```{r}
plotSpatial(
  object = sce[, sce$sample_id == "ZTMA174.2_ZTMA174_B06.22442_10_AX2Y2_93" & sce$metacluster_tumor_combined %in% c("tumor", "CD8_T_cell")], 
  img_id = "sample_id", 
  node_color_by = "CD8Tcell_type", 
  node_shape_by = "metacluster_tumor_combined", 
  colPairName = "neighborhood", 
  draw_edges = TRUE, 
  nodes_first = FALSE, 
  directed = FALSE)+
  scale_color_manual(values = c("navy", "steelblue1", "firebrick"))
```

```{r}
## Step 2: Classify Patients based on spatial CD8 T cell scores

out <- cur_dat %>% group_by(PID, CD8Tcell_type) %>% count() %>% 
  pivot_wider(id_cols = PID, values_from = n, names_from = CD8Tcell_type) %>% 
  mutate(ratio_inf_ex = bystanding / infiltrating, number_inf_ex = bystanding + infiltrating) %>% 
  mutate(spatial_CD8_phenotype = ifelse(ratio_inf_ex >= 8 | infiltrating <= 20, "excluded", "inflamed")) %>% 
  mutate(spatial_CD8_phenotype = ifelse(number_inf_ex <= 10 | is.na(number_inf_ex), "cold", spatial_CD8_phenotype))

# Inflamed: ratio_inf_ex < 8 or > 20 inf CD8
# Excluded: ratio_inf_ex >= 8 
# Cold: number_inf_ex <= 10? 

# Add to sce
sce$spatial_CD8_pheno <- out$spatial_CD8_phenotype[match(sce$PID, out$PID)]

sce[,is.na(sce$spatial_CD8_pheno)]$spatial_CD8_pheno <- "cold"

spatial_CD8_pheno_col <- setNames(c("firebrick", "steelblue1","navy"), unique(sce$spatial_CD8_pheno)) 
metadata(sce)$colors$spatial_CD8_pheno <- spatial_CD8_pheno_col
```

### Kaplan-Meier 

```{r}
#Assess survival impact 
library(patchwork)
library(survival)
library(survminer)

## Spatial_CD8_pheno
cur_surv <- colData(sce) %>% as.data.frame() %>% select(PID, spatial_CD8_pheno, OS_months, DFS_months, status_DFS, status_OS) %>% unique()

#Plot survival curves
fit <- survfit(Surv(OS_months, status_OS) ~ spatial_CD8_pheno, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("steelblue1","navy","firebrick"),
          log.rank.weights = "n")

fit <- survfit(Surv(DFS_months, status_DFS) ~ spatial_CD8_pheno, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("steelblue1","navy","firebrick"),
          log.rank.weights = "n")


## Spatial_CD8_pheno_merg
cur_surv <- colData(sce) %>% as.data.frame() %>% select(PID, spatial_CD8_pheno_merg, OS_months, DFS_months, status_DFS, status_OS) %>% unique()

#Plot survival curves
fit <- survfit(Surv(OS_months, status_OS) ~ spatial_CD8_pheno_merg, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("steelblue1","firebrick"),
          log.rank.weights = "n")

fit <- survfit(Surv(DFS_months, status_DFS) ~ spatial_CD8_pheno_merg, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("steelblue1","firebrick"),
          log.rank.weights = "n")

```

### Cox proportional Hazards model 

Multivariate 

A: Merged spatial CD8 phenotype

```{r}
library(survival)
library(survminer)

sce$spatial_CD8_pheno_merg[sce$spatial_CD8_pheno_merg == "cold/excluded"] <- "cold_excluded"

PID_CD8 <- colData(sce) %>% as.data.frame() %>% select(spatial_CD8_pheno_merg,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_CD8 <- PID_CD8 %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_CD8 %>% pivot_wider(id_cols = "PID",names_from = "spatial_CD8_pheno_merg",values_from = "fra") %>% column_to_rownames("PID")

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#Based on proportions
covariates <- Cox_df %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -inflamed) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+inflamed"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratiDFS
#hr_prop <- 
ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
#coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for con_prop")+
theme_classic()+
coord_cartesian(ylim=c(0,40))+
#scale_y_continuous(trans = "log10")
theme(axis.text.x = element_text(angle = 90))

#hr_prop
```

Univariate 

```{r}
library(survival)
library(survminer)

sce$spatial_CD8_pheno_merg[sce$spatial_CD8_pheno_merg == "cold/excluded"] <- "cold_excluded"

PID_CD8 <- colData(sce) %>% as.data.frame() %>% select(spatial_CD8_pheno_merg,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_CD8 <- PID_CD8 %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_CD8 %>% pivot_wider(id_cols = "PID",names_from = "spatial_CD8_pheno_merg",values_from = "fra") %>% column_to_rownames("PID")

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

#Based on proportions
covariates <- Cox_df %>% select(-status_DFS,-DFS_months, -inflamed) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~", paste(covariates, collapse = " + "),"+inflamed"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratiDFS
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
#coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_manual(values = c("#377EB8"))+
xlab("Tumor metaclusters")+
ylab("HR for con_prop")+
theme_classic()+
coord_cartesian(ylim=c(0,10))+
#scale_y_continuous(trans = "log10")
theme(axis.text.x = element_text(angle = 90))

hr_prop
```

B: Spatial CD8 phenotypes

Multivariate 

```{r}
library(survival)
library(survminer)

PID_CD8 <- colData(sce) %>% as.data.frame() %>% select(spatial_CD8_pheno,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_CD8 <- PID_CD8 %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_CD8 %>% pivot_wider(id_cols = "PID",names_from = "spatial_CD8_pheno",values_from = "fra") %>% column_to_rownames("PID")

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

Cox_df$age <- sce$age[match(rownames(Cox_df),sce$PID)]
Cox_df$grade <- factor(sce$grade[match(rownames(Cox_df),sce$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce$pT_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pN_simple <- as.factor(sce$pN_simple[match(rownames(Cox_df),sce$PID)])
Cox_df$pM_simple <- as.factor(sce$pM_simple[match(rownames(Cox_df),sce$PID)])

#Based on proportions
covariates <- Cox_df %>% select(-status_DFS,-DFS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -inflamed) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+inflamed"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratiDFS
#hr_prop <- 
ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
#coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for con_prop")+
theme_classic()+
coord_cartesian(ylim=c(0,63))+
#scale_y_continuous(trans = "log10")
theme(axis.text.x = element_text(angle = 90))

#hr_prop
```

Univariate 

```{r}
library(survival)
library(survminer)

PID_CD8 <- colData(sce) %>% as.data.frame() %>% select(spatial_CD8_pheno,PID) %>% group_by(PID) %>% table() %>% as.data.frame

PID_CD8 <- PID_CD8 %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_CD8 %>% pivot_wider(id_cols = "PID",names_from = "spatial_CD8_pheno",values_from = "fra") %>% column_to_rownames("PID")

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_DFS <- sce$status_DFS[match(rownames(Cox_df),sce$PID)]
Cox_df$DFS_months <- sce$DFS_months[match(rownames(Cox_df),sce$PID)]

#Based on proportions
covariates <- Cox_df %>% select(-status_DFS,-DFS_months, -inflamed) %>% colnames

multi_formula <- as.formula(paste("Surv(DFS_months, status_DFS) ~", paste(covariates, collapse = " + "),"+inflamed"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratiDFS
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
#coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_manual(values = c("#377EB8"))+
xlab("Tumor metaclusters")+
ylab("HR for con_prop")+
theme_classic()+
coord_cartesian(ylim=c(0,8))+
#scale_y_continuous(trans = "log10")
theme(axis.text.x = element_text(angle = 90))

hr_prop
```

### spicyR - Test for differential interaction of CD8 T cells between conditions 

Here we will use spicyR. 

```{r}
library(lisaClust)
library(spicyR)

### First comparison: CD8-T-cell interaction with tumor (phenotypes combined) between "cold/excluded" vs. "inflamed"

# Generate segmentedCells object 
cur_sce <- sce[, sce$metacluster_tumor_combined %in% c("CD8_T_cell","tumor")]

cells <- data.frame(row.names = colnames(cur_sce))
cells$x <- cur_sce$Pos_X
cells$y <- cur_sce$Pos_Y
cells$imageID <- cur_sce$sample_id
cells$imageCellID <- cur_sce$ObjectNumber
cells$cellType <- cur_sce$metacluster_tumor_combined

cells_sc <- SegmentedCells(cells, cellProfiler = TRUE)

# Add condition and patient id
spatial_CD8_factor <- relevel(x=factor(cur_sce$spatial_CD8_pheno_merg), ref = "cold/excluded")

imagePheno(cells_sc) <- DataFrame(imageID = cur_sce$sample_id, 
          PID = cur_sce$PID,
          spatial_CD8 = spatial_CD8_factor
          )

cells_sc

# Run differential interaction analysis 
spicyTest <- spicy(cells_sc, 
      condition = "spatial_CD8", 
      subject = "PID", 
      BPPARAM = BiocParallel::MulticoreParam(),
      includeZeroCells = TRUE)

saveRDS(spicyTest, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_inflamedvscold_CD8vstumor_withzero.rds")

spicyTest <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_inflamedvscold_CD8vstumor_withzero.rds")
topPairs(spicyTest)

signifPlot(spicyTest,
           type = "heatmapbliblablub",
           breaks=c(-3, 3, 0.5),
           fdr = TRUE,
           marksToPlot = c("tumor","CD8_T_cell"))


### Second comparison: CD8-T-cell interaction with tumor phenotypes between "cold/excluded" vs. "inflamed"

# Generate segmentedCells object 
cur_sce <- sce[, sce$metacluster_tumor_combined %in% c("CD8_T_cell","tumor")]

cells <- data.frame(row.names = colnames(cur_sce))
cells$x <- cur_sce$Pos_X
cells$y <- cur_sce$Pos_Y
cells$imageID <- cur_sce$sample_id
cells$imageCellID <- cur_sce$ObjectNumber
cells$cellType <- cur_sce$metacluster_combined

cells_sc <- SegmentedCells(cells, cellProfiler = TRUE)

# Add condition and patient id
spatial_CD8_factor <- relevel(x=factor(cur_sce$spatial_CD8_pheno_merg), ref = "cold/excluded")

imagePheno(cells_sc) <- DataFrame(imageID = cur_sce$sample_id, 
          PID = cur_sce$PID,
          spatial_CD8 = spatial_CD8_factor
          )

cells_sc

# Run differential interaction analysis 
spicyTest <- spicy(cells_sc, 
      condition = "spatial_CD8", 
      subject = "PID", 
      BPPARAM = BiocParallel::MulticoreParam(),
      includeZeroCells = TRUE)

saveRDS(spicyTest, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_inflamedvscold_CD8vstumorphenotypes_withzero.rds")
spicyTest2 <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_inflamedvscold_CD8vstumorphenotypes_withzero.rds")

topPairs(spicyTest2)

signifPlot(spicyTest2,
           type = "heatmapbliblablub",
           breaks=c(-3, 3, 0.5),
           fdr = TRUE,
           marksToPlot = unfactor(unique(cur_sce$metacluster_combined)))


### Third comparison: General phenotype interaction between "cold/excluded" vs. "inflamed"

# Generate segmentedCells object 
cur_sce <- sce

cells <- data.frame(row.names = colnames(cur_sce))
cells$x <- cur_sce$Pos_X
cells$y <- cur_sce$Pos_Y
cells$imageID <- cur_sce$sample_id
cells$imageCellID <- cur_sce$ObjectNumber
cells$cellType <- cur_sce$metacluster_combined

cells_sc <- SegmentedCells(cells, cellProfiler = TRUE)

# Add condition and patient id
unique(cur_sce$spatial_CD8_pheno_merg)

spatial_CD8_factor <- relevel(x=factor(cur_sce$spatial_CD8_pheno_merg), ref = "cold_excluded")

imagePheno(cells_sc) <- DataFrame(imageID = cur_sce$sample_id, 
          PID = cur_sce$PID,
          spatial_CD8 = spatial_CD8_factor
          )

cells_sc

# Run differential interaction analysis 
spicyTest <- spicy(cells_sc, 
      condition = "spatial_CD8", 
      subject = "PID", 
      BPPARAM = BiocParallel::MulticoreParam(),
      includeZeroCells = TRUE)

saveRDS(spicyTest, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_inflamedvscold_allVSall_withzero.rds")

spicyTest3 <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_inflamedvscold_allVSall_withzero.rds")
topPairs(spicyTest3)

signifPlot(spicyTest,
           type = "heatmapbliblablub",
           breaks=c(-3, 3, 0.5),
           fdr = TRUE,
           marksToPlot = unfactor(unique(sce$metacluster_combined)))
```

### B cell patch analysis 

```{r}
## Patch detection
sce <- patchDetection(sce,
               patch_cells = sce$metacluster_tumor_combined == "B_cell",
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = "patch_B_cell",
               expand_by = 0, 
               img_id = "sample_id", 
               BPPARAM = MulticoreParam(workers = 20))

## 1. Number of patches per PID 
n_Bpatch_PID <- colData(sce) %>% as.data.frame %>% select(PID, spatial_CD8_pheno_merg, patch_B_cell) %>% 
  filter(!is.na(patch_B_cell)) %>% 
  unique() %>% 
  group_by(spatial_CD8_pheno_merg, PID) %>% 
  count()

plot_df <- colData(sce) %>% as.data.frame %>% select(PID, spatial_CD8_pheno_merg) %>% 
  unique() 
rownames(plot_df) <- NULL
plot_df$n_Bpatch <- n_Bpatch_PID$n[match(plot_df$PID, n_Bpatch_PID$PID)]
plot_df$n_Bpatch[is.na(plot_df$n_Bpatch)] <- 0

plot_df$spatial_CD8_pheno <- sce$spatial_CD8_pheno[match(plot_df$PID, sce$PID)]

library(ggpubr)
ggplot(plot_df, aes(x = spatial_CD8_pheno, y = n_Bpatch))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = spatial_CD8_pheno), size = 3, position=position_jitter(w=0.1,h=0.1))+
  guides(color = "none")+
  scale_color_manual(values = metadata(sce)$colors$spatial_CD8_pheno)+
  theme_classic(base_size = 12)+
  coord_cartesian(ylim = c(0,15))+
  theme(axis.title.x = element_blank())+
  ylab("Number of B cell patches per PID")+
  stat_compare_means(method = "kruskal.test")
  

## 2. Size of B cell patches 

size_Bpatch_PID <- colData(sce) %>% as.data.frame %>% select(PID, spatial_CD8_pheno_merg, patch_B_cell) %>% 
  filter(!is.na(patch_B_cell)) %>% 
  group_by(patch_B_cell, PID) %>% 
  count()

size_Bpatch_PID$spatial_CD8_pheno_merg <- plot_df$spatial_CD8_pheno_merg[match(size_Bpatch_PID$PID, plot_df$PID)]
size_Bpatch_PID$spatial_CD8_pheno <- sce$spatial_CD8_pheno[match(size_Bpatch_PID$PID, sce$PID)]

ggplot(size_Bpatch_PID, aes(x = spatial_CD8_pheno, y = n))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = spatial_CD8_pheno), size = 3, position=position_jitter(w=0.1,h=0.1))+
  guides(color = "none")+
  scale_color_manual(values = metadata(sce)$colors$spatial_CD8_pheno)+
  theme_classic(base_size = 12)+
  #coord_cartesian(ylim = c(0,15))+
  theme(axis.title.x = element_blank())+
  #scale_y_log10()+
  ylab("Number of B cells per patch")+
  stat_compare_means(method = "kruskal.test")

# Define cut-off for small and large B cell follicles - use median (21 B cells per patch)
summary(size_Bpatch_PID$n)

size_Bpatch_PID <- size_Bpatch_PID %>% mutate(patch_score = ifelse(n > median(size_Bpatch_PID$n), "large", "small"))

PID_large_patches <- size_Bpatch_PID %>% filter(patch_score == "large") %>% pull(PID) %>% unique()

size_Bpatch_PID <- size_Bpatch_PID %>% mutate(large_Bpatch = ifelse(PID %in% PID_large_patches, TRUE, FALSE))

## 3. Create B cell score per PID 
# No B cells = 1 
# No B cell patches = 2
# Small B cell patches = 3
# Large B cell patches = 4 

B_cells_PID <- colData(sce) %>% as.data.frame %>% select(PID, metacluster_combined) %>% filter(metacluster_combined == "B_cell") %>% group_by(PID, metacluster_combined) %>% count()

plot_df$n_Bcells <- B_cells_PID$n[match(plot_df$PID, B_cells_PID$PID)]

plot_df$n_Bcells[is.na(plot_df$n_Bcells)] <- 0

plot_df$large_Bpatch <- size_Bpatch_PID$large_Bpatch[match(plot_df$PID, size_Bpatch_PID$PID)]


plot_df <- plot_df %>% mutate(B_cell_score = ifelse(n_Bcells == 0, "No_B_cell", 
                                         ifelse(n_Bpatch == 0, "No_B_patch", 
                                                ifelse(large_Bpatch == FALSE, "Small_B_patch", "Large_B_patch"))))

plot_df$B_cell_score <- factor(plot_df$B_cell_score, levels = c("No_B_cell","No_B_patch", "Small_B_patch", "Large_B_patch"))


plot <- plot_df %>%
  group_by(B_cell_score, spatial_CD8_pheno) %>%
  summarise(n=n()) %>%
  group_by(spatial_CD8_pheno) %>%
  mutate(fraction = n / sum(n)) %>%
  ungroup()


plot_test <- plot %>% pivot_wider(names_from = spatial_CD8_pheno, id_cols = B_cell_score, values_from = n) %>% column_to_rownames("B_cell_score")

plot_test_out <- fisher.test(plot_test, simulate.p.value = TRUE)

round(plot_test_out$p.value, 4)

ggplot(plot) + 
  geom_col(aes(y=spatial_CD8_pheno, x=fraction, fill=B_cell_score), color = "black") +
  theme_classic() + 
  xlab("Fraction of PID") +
  ylab("")+
  scale_fill_brewer(palette = "Paired")+
  ggtitle(paste0("p (Fisher) = ", plot_test_out$p.value))


## 4. Add to sce
sce$B_cell_score <- plot_df$B_cell_score[match(sce$PID, plot_df$PID)]
```

### B patch distance analysis 

```{r}
sce <- minDistToCells(sce, img_id = "sample_id", x_cells = !is.na(sce$patch_B_cell), BPPARAM = MulticoreParam(workers = 10, stop.on.error = FALSE), name = "distToPatchB") 

## Visualize

library(wesanderson)
pal <- wes_palette("Zissou1", 100, type = "continuous")

#subset sce to 5 images with large B cell patches
cur_sam <- colData(sce) %>% as.data.frame %>% select(sample_id, patch_B_cell) %>% filter(!is.na(patch_B_cell)) %>% group_by(sample_id) %>% count() %>% arrange(desc(n)) %>% filter(n > 1300) %>% pull(sample_id)

plotSpatial(sce[,sce$sample_id %in% cur_sam], img_id = "sample_id", node_color_by = "patch_B_cell") #Patch
plotSpatial(sce[,sce$sample_id %in% cur_sam], img_id = "sample_id", node_color_by = "distToPatchB")+
  scale_color_gradientn(colors = pal) # DistToPatch
plotSpatial(sce[,sce$sample_id %in% cur_sam], img_id = "sample_id", node_color_by = "metacluster_combined")+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined) # Metacluster
```


```{r}
library(ggpubr)
dist_df <- colData(sce) %>% as.data.frame %>% filter(!is.na(distToPatchB) & metacluster_tumor_combined != "B_cell") %>% select(sample_id, metacluster_tumor_combined, distToPatchB) %>% group_by(sample_id, metacluster_tumor_combined) %>% summarize(mean = mean(distToPatchB))

dist_df$B_cell_score <- sce$B_cell_score[match(dist_df$sample_id, sce$sample_id)]

# 1. Difference of cell phenotype distances to B cell patches
# Density plot 
ggplot(dist_df, aes(mean, color = metacluster_tumor_combined))+
  geom_density(size = 0.8)+
  geom_rug()+
  #facet_wrap(~B_cell_score)+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)+
  xlab("Mean distance to B cell patch (per image)")+
  theme_classic()
# Boxplot 
ggplot(dist_df, aes(x = reorder(metacluster_tumor_combined, mean), y = mean))+
  geom_boxplot()+
  geom_jitter(aes(color = metacluster_tumor_combined), size = 3, position=position_jitter(w=0.1,h=0.1))+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90), axis.title.x = element_blank())+
  ylab("Mean distance to B cell patch (per image)")+
  guides(fill = "none")+
  stat_compare_means(method = "kruskal.test")

# 2. Difference of cell phenotype distances to B cell patches BETWEEN B cell scores
ggplot(dist_df, aes(mean, color = metacluster_tumor_combined))+
  geom_density(size = 0.8)+
  geom_rug()+
  facet_wrap(~B_cell_score)+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)+
  xlab("Mean distance to B cell patch (per image)")+
  theme_classic()

ggplot(dist_df, aes(mean, color = B_cell_score))+
  geom_density(size = 0.8)+
  geom_rug()+
  facet_wrap(~metacluster_tumor_combined)+
  #scale_color_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)+
  xlab("Mean distance to B cell patch (per image)")+
  theme_classic()

ggplot(dist_df, aes(x = B_cell_score, y = mean))+
  geom_boxplot()+
  geom_jitter(aes(color = B_cell_score), size = 3, position=position_jitter(w=0.1,h=0.1))+
  facet_wrap(~metacluster_tumor_combined)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90), axis.title.x = element_blank())+
  ylab("Mean distance to B cell patch (per image)")+
  guides(fill = "none")

# 3. Difference of tumor phenotype distances to B cell patches

dist_tumor_df <- colData(sce) %>% as.data.frame %>% filter(!is.na(distToPatchB) & metacluster_tumor_combined != "B_cell" & metacluster_tumor_combined == "tumor") %>% select(sample_id, metacluster_combined, distToPatchB) %>% group_by(sample_id, metacluster_combined) %>% summarize(mean = mean(distToPatchB))

dist_tumor_df$B_cell_score <- sce$B_cell_score[match(dist_tumor_df$sample_id, sce$sample_id)]

ggplot(dist_tumor_df, aes(x = reorder(metacluster_combined, mean), y = mean))+
  geom_boxplot()+
  geom_jitter(aes(color = metacluster_combined), size = 3, position=position_jitter(w=0.1,h=0.1))+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90), axis.title.x = element_blank())+
  ylab("Mean distance to B cell patch (per image)")+
  guides(fill = "none")+
  stat_compare_means(method = "kruskal.test")
```

### T cell expression analysis 

```{r}
# Focus on Ki67 

# Subset to CD8_T_cells
cur_sce <- sce[,sce$metacluster_combined == "CD8_T_cell"]


# Define Ki67 positivity cut-off based on GMM (exprs)
GMM_Ki67 <- Mclust(assay(sce, "exprs")["Ki67",], G = 2)

GMM_df <- data.frame(class_Ki67 = ifelse(GMM_Ki67$classification == 2 & GMM_Ki67$uncertainty == 0, 
                                        "Ki67+",
                                        "Ki67-"), 
                     Ki67_exprs = assay(sce, "exprs")["Ki67",],
                     uncertainty = GMM_Ki67$uncertainty)

#Visualize GMM
ggplot(GMM_df, aes(x = Ki67_exprs, fill = class_Ki67))+
  geom_density()+
  theme_classic(base_size = 15)+
  theme(axis.title.x = element_blank())+
  scale_fill_brewer(palette = "Set1")
  
#Add GMM epi class to SCE
sce$GMM_Ki67 <- GMM_df$class_Ki67

# Violin plot
cur_dat <- t(assay(cur_sce, "exprs")) %>% as.data.frame
cur_dat$CD8Tcell_type <- sce$CD8Tcell_type[match(rownames(cur_dat),colnames(sce))]
cur_dat$CD8Tcell_type <- factor(cur_dat$CD8Tcell_type, levels = c("ignored","bystanding","infiltrating"))
cur_dat$Ki67_GMM <- sce$GMM_Ki67[match(rownames(cur_dat),colnames(sce))]

cur_out <- cur_dat %>% select(CD8Tcell_type, Ki67_GMM) %>% group_by(CD8Tcell_type, Ki67_GMM) %>% count()

cur_plot <- cur_out %>% group_by(CD8Tcell_type) %>% mutate(fra = n/sum(n))

cur_test <- cur_plot %>% pivot_wider(names_from = CD8Tcell_type, id_cols = Ki67_GMM, values_from = n) %>% column_to_rownames("Ki67_GMM")

cur_test_out <- chisq.test(cur_test)

cur_test_out$p.value

ggplot(cur_plot) +
  geom_tile(color = "black",aes(CD8Tcell_type, fra, fill = Ki67_GMM), position = "stack")+
  scale_fill_brewer(palette = "Paired")+
  theme_classic(base_size = 15)+
  ylab("Density")+
  theme(axis.title.x = element_blank())+
  ggtitle(paste("p (Chi-Square) = ",cur_test_out$p.value))
```

### Tumor expression analysis 

```{r}
## Analyse tumor compartment expression 

# Subset to tumor cells
sce_tumor <- sce[,sce$analysis_cat == "tumor"]

# Aggregate expression per PID 
spatialpheno_mean_PID <- aggregateAcrossCells(sce_tumor, ids = sce_tumor$PID,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce_tumor)$tumor_cluster_channel)

# Test for differential expression per category 
test <- t(assay(spatialpheno_mean_PID, "exprs")[rowData(spatialpheno_mean_PID)$tumor_cluster_channel,]) %>% as.data.frame %>% mutate(spatial_CD8_pheno = spatialpheno_mean_PID$spatial_CD8_pheno) 

test$spatial_CD8_pheno <- unfactor(test$spatial_CD8_pheno)

test_result <- compare_means(c(H3K27me3, CK5, HLADR, CK8_18, CD15, KRT14, Vimentin, 
cMYC, HER2, pH3, ER, PR, p53, AR, GATA3, CAIX, 
Ki67, EGFR, S6, p_mTOR, CK7, c_Cas3_PARP)~spatial_CD8_pheno, method = "kruskal.test",data = test)

test_result$p.adj <- p.adjust(test_result$p, method = "BH") 

test_result$psignif.adj <- as.matrix(symnum(test_result$p.adj,
       cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1), 
       symbols = c("****", "***", "**", "*", "ns")))[,1]

rownames(test_result) <- test_result$.y.

sig.poteins <- unfactor(test_result$.y.[test_result$p.adj < 0.05])


# Aggregate expression per spatial phenotype
spatialpheno_mean_sce <- aggregateAcrossCells(sce_tumor, ids = sce_tumor$spatial_CD8_pheno,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce_tumor)$tumor_cluster_channel)

mat_scaled<- t(scale(t(assay(spatialpheno_mean_sce, "exprs"))))


highest_cat <- mat_scaled %>% as.data.frame() %>% rownames_to_column("gene") %>% pivot_longer(cols = 2:4, names_to = "spatial_CD8", values_to = "exprs") %>% group_by(gene) %>% mutate(max = max(exprs)) %>% filter(exprs == max) %>% select(gene, spatial_CD8) %>% as.data.frame() %>% column_to_rownames("gene")

## Visualize 

# Heatmap 
h <- Heatmap(assay(spatialpheno_mean_sce, "exprs"), col = viridis(100), name = "exprs", cluster_columns = FALSE, row_names_side = "left", show_row_dend = FALSE)+
  #Heatmap(mat_scaled, name = "scaled exprs", cluster_columns = FALSE)+
  rowAnnotation(cat = anno_simple(highest_cat, col = metadata(sce)$colors$spatial_CD8_pheno, width = unit(10, "mm")))+
  rowAnnotation(test = anno_text(test_result$psignif.adj))

lgd_cat <- Legend(title = "Highest_exprs", at = names(metadata(sce)$colors$spatial_CD8_pheno), 
              legend_gp = gpar(fill = metadata(sce)$colors$spatial_CD8_pheno))


draw(h,annotation_legend_list = list(lgd_cat))

# Violin plot
plotExpression(spatialpheno_mean_PID, 
               features = sig.poteins,
               x = "spatial_CD8_pheno", exprs_values = "exprs", 
               colour_by = "spatial_CD8_pheno") +
    theme(axis.text.x =  element_text(angle = 90))+
    scale_color_manual(values = metadata(sce)$colors$spatial_CD8_pheno)
```

```{r}
set.seed(22)

cur_sce <- sce[,sce$metacluster_tumor_combined %in% c("tumor")]

cur_cells <- sample(seq_len(ncol(cur_sce)), 100000)

# Heatmap visualization - DittoHeatmap
dittoHeatmap(cur_sce[,cur_cells],
             genes = rownames(sce) %in% c("HLADR","Ki67", "Vimentin"),
             assay = "min_max", 
             heatmap.colors = viridis(100), 
             scale = "none", 
             cluster_cols = FALSE, 
             annot.by = c("spatial_CD8_pheno"))

plotExpression(cur_sce[,cur_cells], 
               features = c("HLADR"),
               x = "spatial_CD8_pheno", exprs_values = "exprs", 
               colour_by = "spatial_CD8_pheno") 

```


### Tumor patch analysis 

```{r}
## Tumor patch detection
sce <- patchDetection(sce,
               patch_cells = sce$metacluster_tumor_combined == "tumor",
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = "patch_tumor",
               expand_by = 0, 
               img_id = "sample_id", 
               BPPARAM = MulticoreParam(workers = 10))


sce <- minDistToCells(sce, img_id = "sample_id", x_cells = !is.na(sce$patch_tumor), BPPARAM = MulticoreParam(workers = 10, stop.on.error = FALSE))
sce$distToTumor <- sce$distToCells
#sce$distToCells <- NULL
```

```{r}
dist_CD8_df <- colData(sce) %>% as.data.frame %>% filter(!is.na(distToTumor) & metacluster_combined == "CD8_T_cell") %>% select(sample_id, metacluster_combined, distToTumor) %>% group_by(sample_id, metacluster_combined) %>% summarize(mean = mean(distToTumor)) 

dist_CD8_df$spatial_CD8_pheno <- sce$spatial_CD8_pheno[match(dist_CD8_df$sample_id, sce$sample_id)]

dist_CD8_df <- dist_CD8_df %>% group_by(spatial_CD8_pheno) %>% mutate(mean_dist = mean(mean), median_dist = median(mean))


# 1. Difference of CD8 T cell distances to tumor cell patches
# Density plot 
ggplot(dist_CD8_df, aes(mean, color = spatial_CD8_pheno))+
  geom_density(size = 0.8)+
  geom_rug()+
  facet_wrap(~spatial_CD8_pheno)+
  geom_vline(aes(xintercept = mean_dist, color = spatial_CD8_pheno), linetype = "dashed")+
  scale_color_manual(values = metadata(sce)$colors$spatial_CD8_pheno, limits = force)+
  xlab("Mean distance to tumor patch (per image)")+
  theme_classic()+
  ggtitle("Kruskal-Wallis, p = 0.00012")


# Boxplot 
ggplot(dist_CD8_df, aes(x = reorder(spatial_CD8_pheno, mean), y = mean))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = spatial_CD8_pheno), size = 3, position=position_jitter(w=0.1,h=0.1))+
  scale_color_manual(values = metadata(sce)$colors$spatial_CD8_pheno, limits = force)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90), axis.title.x = element_blank())+
  ylab("Mean distance to tumor patch (per image)")+
  guides(fill = "none")+
  ggtitle("CD8_T_cells")+
  stat_compare_means(method = "kruskal.test")


# 2. Difference of TME cell distances to tumor cell patches
dist_df <- colData(sce) %>% as.data.frame %>% filter(!is.na(distToTumor) & metacluster_tumor_combined != "tumor") %>% select(sample_id, metacluster_combined, distToTumor) %>% group_by(sample_id, metacluster_combined) %>% summarize(mean = mean(distToTumor)) 

dist_df$spatial_CD8_pheno <- sce$spatial_CD8_pheno[match(dist_df$sample_id, sce$sample_id)]

dist_df <- dist_df %>% group_by(spatial_CD8_pheno, metacluster_combined) %>% mutate(mean_dist = mean(mean), median_dist = median(mean))


ggplot(dist_df, aes(mean, color = spatial_CD8_pheno))+
  geom_density(size = 0.8)+
  geom_rug()+
  facet_wrap(~metacluster_combined)+
  scale_color_manual(values = metadata(sce)$colors$spatial_CD8_pheno, limits = force)+
  xlab("Mean distance to tumor patch (per image)")+
  theme_classic()
  #geom_vline(aes(xintercept = median_dist),color = "black", linetype = "dashed") #red

ggplot(dist_df, aes(x = reorder(spatial_CD8_pheno, mean), y = mean))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = spatial_CD8_pheno), size = 3, position=position_jitter(w=0.1,h=0.1))+
  facet_wrap(~metacluster_combined)+
  stat_compare_means(method = "kruskal.test")+
  scale_color_manual(values = metadata(sce)$colors$spatial_CD8_pheno, limits = force)+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 90), axis.title.x = element_blank())+
  ylab("Mean distance to tumor patch (per image)")+
  guides(fill = "none")+
  ggtitle("CD8_T_cells")+
  stat_compare_means(method = "kruskal.test")
```

### HLADR Tumor analysis 

```{r}
## Tumor 7 Milieu detection 
sce <- patchDetection(sce,
               patch_cells = sce$metacluster_combined == "tumor_7",
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = "milieu_MC7",
               expand_by = 30, 
               img_id = "sample_id", 
               BPPARAM = MulticoreParam(workers = 10))

gc()

## Tumor 7 Patch detection 
sce <- patchDetection(sce,
               patch_cells = sce$metacluster_combined == "tumor_7",
               colPairName = "knn_interaction_graph",
               min_patch_size = 10,
               name = "patch_MC7",
               expand_by = 0, 
               img_id = "sample_id", 
               BPPARAM = MulticoreParam(workers = 10))

gc()
```

```{r}
#Number of milieus per image
milieu_image <- colData(sce) %>% as.data.frame %>% select(sample_id, milieu_MC7) %>% filter(!is.na(milieu_MC7)) %>% group_by(sample_id) %>% unique() %>% count()
milieu_PID <- colData(sce) %>% as.data.frame %>% select(PID, milieu_MC7) %>% filter(!is.na(milieu_MC7)) %>% group_by(PID) %>% unique() %>% count()

## Milieu enrichment analysis
## Code adopted from Science Immunology paper

cur_res_list <- list()
cur_df <- colData(sce)

# Set thresholds
#perc_cells <- 0

for (i in c("milieu_MC7")){
  
  cur_images <- cur_df %>% 
    as.data.frame %>% 
    select(sample_id, as.name(i)) %>% 
    filter(complete.cases(.)) %>% #remove images with no milieu - also possible to use a threshold
    group_by(sample_id) %>% 
    unique() %>% 
    count()
  
  for (j in unique(cur_df$metacluster_combined)) {
  z <- str_split(i,"u_", simplify = TRUE)[,2]
    cur_res <- cur_df %>% 
      as.data.frame() %>%
      select(sample_id, metacluster_combined, as.name(i)) %>% 
      filter(sample_id %in% cur_images$sample_id) %>%
      filter(metacluster_combined != z) %>%
      group_by(sample_id) %>%
      summarise(inside = sum(metacluster_combined == j & !is.na(.data[[i]])),
            outside = sum(metacluster_combined == j & is.na(.data[[i]])),
            other_inside = sum(metacluster_combined != j & !is.na(.data[[i]])),
            other_outside = sum(metacluster_combined != j & is.na(.data[[i]])))
    
    out_dat <- foreach(x = seq_along(rownames(cur_res)), .combine = "rbind")%do%{
    cur_mat <- matrix(as.numeric(as.vector(cur_res[x,2:5])),ncol = 2, nrow = 2, byrow = FALSE)
    rownames(cur_mat) <- c("cluster", "other_cluster")
    colnames(cur_mat) <- c("inside", "outside")
    cur_test <- fisher.test(cur_mat)
   
    out_dat <- data.frame(
      sample = as.character(as.vector(cur_res[x,1])),
      milieu = i,
      metacluster_combined = j,
      p = cur_test$p.value,
      odds = cur_test$estimate,
      row.names = NULL)
    }
      
cur_res_list[[paste0(i, "_", j)]] <- out_dat

  }   
}

# Final output - Can be interpreted as "Fraction of images with significant enrichment or depletion of cell types within milieus"
out <- do.call("rbind", cur_res_list)
out$adj.p <- p.adjust(out$p, method = "BH")

final <- out %>% mutate(sigval = ifelse(odds > 1 & adj.p < 0.1, 1, ifelse(odds < 1 & adj.p < 0.1, -1, 0))) %>%
    group_by(milieu, metacluster_combined) %>%
    dplyr::summarize(mean = mean(sigval))

# Number of tested images
out %>% 
  group_by(milieu, metacluster_combined) %>% 
  dplyr::summarize(count = n()) %>% 
  as.data.frame()

final_heatmap <- final %>% pivot_wider(id_cols = milieu, names_from = metacluster_combined, values_from = mean) %>% column_to_rownames("milieu")

Heatmap(final_heatmap, 
        name = "Enrichment score")
```


## Immune mixing score - Keren et al., 2020

```{r}
# Patients with less than 500 immune cells - cold
# Calculate mixing score based on immune-immune and tumor-immune interactions
# Classify rest of patients as mixed or compartmentalized

## Step 1: Count interactions for immune-immune and tumor-immune
cur_dat <- sce$count_neighbors %>% as.data.frame
rownames(cur_dat) <- sce$cell_id
cur_dat$PID <- sce$PID
cur_dat$analysis_cat <- sce$analysis_cat

#Exclude endothelial, immune_low and stromal cells
cur_dat <- cur_dat %>% select(-Endothelial, -Immune_low, -Stromal)
cur_dat <- cur_dat %>% mutate(immune = B_cell+CD4_T_cell+CD8_T_cell+HLA_DR+Monocyte+Neutrophil, .after = Neutrophil)

#calculate number of immune cells
number_immune <- cur_dat %>% filter(analysis_cat == "non_tumor") %>% select(PID, analysis_cat) %>% group_by(PID) %>% count()

## Step 2: Calculate mixing score
cur_out <- cur_dat %>% group_by(PID, analysis_cat) %>% summarise(immune = sum(immune))
cur_out <- cur_out %>% pivot_wider(id_cols = PID, names_from = analysis_cat, values_from = immune) %>% mutate(mixing_score = tumor/non_tumor) %>% filter(tumor != 0)

cur_out$number_immune <- number_immune$n[match(cur_out$PID, number_immune$PID)]

## Step 3: Classify mixing score with kmeans

#Exclude "cold" tumors
cur_k <- cur_out %>% filter(number_immune > 500)

#kmeans
set.seed(22)
cur_k$mixing_pheno <- kmeans(cur_k$mixing_score, 2, nstart = 1000)$cluster

cur_k$mixing_pheno <- ifelse(cur_k$mixing_pheno == "1", "mixed","compartmentalized")

#add back
cur_out$mixing_pheno <- cur_k$mixing_pheno[match(cur_out$PID, cur_k$PID)]
cur_out$mixing_pheno[is.na(cur_out$mixing_pheno)] <- "cold"

## Add to sce
sce$mixing_pheno <- cur_out$mixing_pheno[match(sce$PID, cur_out$PID)]

## Create color scheme
mixing_pheno_col <- setNames(c("seagreen","purple","steelblue1"), unique(sce$mixing_pheno))
metadata(sce)$colors$mixing_pheno <- mixing_pheno_col
```

```{r}
#Assess survival impact 

library(survival)
library(survminer)

cur_surv <- colData(sce) %>% as.data.frame() %>% select(PID, mixing_pheno, OS_months, DFS_months, status_DFS, status_OS) %>% unique()
  #filter(!mixing_pheno %in% "cold")

#Plot survival curves
fit <- survfit(Surv(OS_months, status_OS) ~ mixing_pheno, data = cur_surv)
print(fit)

mix_OS <- ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("steelblue1","purple","seagreen"),
          log.rank.weights = "n")

fit <- survfit(Surv(DFS_months, status_DFS) ~ mixing_pheno, data = cur_surv)
print(fit)

mix_DFS <- ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("steelblue1","purple","seagreen"),
          log.rank.weights = "n")

mix_OS
mix_DFS
```

```{r save_objects, message = FALSE, warning=FALSE}
#Save sce
saveRDS(sce, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/07_sce_combined.rds")
```


## 3.7 Node positivity analysis

```{r}
#Assess survival impact 
library(patchwork)
library(survival)
library(survminer)

sce$pN_merg <- colData(sce) %>% 
  as.data.frame %>% 
  select(pN_simple) %>% 
  mutate(pN_merg = ifelse(pN_simple %in% c("1","2","3"),"1/2/3", pN_simple)) %>% pull(pN_merg)


#also possible to use spatial_CD8_pheno_merg (cold/excluded vs inflamed)
cur_surv <- colData(sce) %>% as.data.frame() %>% select(PID, pN_merg, OS_months, DFS_months, status_DFS, status_OS) %>% unique()

#Plot survival curves
fit <- survfit(Surv(OS_months, status_OS) ~ pN_merg, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          #palette = c("steelblue1","navy","firebrick"),
          log.rank.weights = "n")

fit <- survfit(Surv(DFS_months, status_DFS) ~ pN_merg, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          #palette = c("steelblue1","navy","firebrick"),
          log.rank.weights = "n")
```
### spicyR test for differential interaction

```{r}
library(lisaClust)
library(spicyR)

### First comparison: Differential interaction of tumor phenotypes between "node negative" vs. "node positive"

# Generate segmentedCells object 
cur_sce <- sce[,sce$metacluster_tumor_combined == "tumor"]

cells <- data.frame(row.names = colnames(cur_sce))
cells$x <- cur_sce$Pos_X
cells$y <- cur_sce$Pos_Y
cells$imageID <- cur_sce$sample_id
cells$imageCellID <- cur_sce$ObjectNumber
cells$cellType <- cur_sce$metacluster_combined

cells_sc <- SegmentedCells(cells, cellProfiler = TRUE)

# Add condition and patient id
node_factor <- relevel(x=factor(cur_sce$pN_merg), ref = "0")

imagePheno(cells_sc) <- DataFrame(imageID = cur_sce$sample_id, 
          PID = cur_sce$PID,
          node = node_factor
          )

cells_sc

# Run differential interaction analysis 
spicyTest <- spicy(cells_sc, 
      condition = "node", 
      subject = "PID", 
      BPPARAM = BiocParallel::MulticoreParam(workers = 10),
      includeZeroCells = TRUE)

saveRDS(spicyTest, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_nodeinvolment_tumor_withzero.rds")

topPairs(spicyTest)

### Second comparison: Differential interaction of tumor vs microenvironment between "node negative" vs. "node positive"

# Generate segmentedCells object 
cur_sce <- sce

cells <- data.frame(row.names = colnames(cur_sce))
cells$x <- cur_sce$Pos_X
cells$y <- cur_sce$Pos_Y
cells$imageID <- cur_sce$sample_id
cells$imageCellID <- cur_sce$ObjectNumber
cells$cellType <- cur_sce$metacluster_tumor_combined

cells_sc <- SegmentedCells(cells, cellProfiler = TRUE)

# Add condition and patient id
node_factor <- relevel(x=factor(cur_sce$pN_merg), ref = "0")

imagePheno(cells_sc) <- DataFrame(imageID = cur_sce$sample_id, 
          PID = cur_sce$PID,
          node = node_factor
          )

cells_sc

# Run differential interaction analysis 
spicyTest <- spicy(cells_sc, 
      condition = "node", 
      subject = "PID", 
      BPPARAM = BiocParallel::MulticoreParam(workers = 10),
      includeZeroCells = TRUE)

saveRDS(spicyTest, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_nodeinvolment_tumorvsTME_withzero.rds")

topPairs(spicyTest)

spicy1 <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_nodeinvolment_tumorvsTME_withzero.rds")
topPairs(spicy1)
signifPlot(spicy1,
           type = "heatmapbliblablub",
           breaks=c(-3, 3, 1),
           fdr = TRUE,
           marksToPlot =unique(cur_sce$metacluster_tumor_combined))


### Second comparison: Differential interaction of all phenotypes between "node negative" vs. "node positive"

# Generate segmentedCells object 
cur_sce <- sce

cells <- data.frame(row.names = colnames(cur_sce))
cells$x <- cur_sce$Pos_X
cells$y <- cur_sce$Pos_Y
cells$imageID <- cur_sce$sample_id
cells$imageCellID <- cur_sce$ObjectNumber
cells$cellType <- cur_sce$metacluster_combined

cells_sc <- SegmentedCells(cells, cellProfiler = TRUE)

# Add condition and patient id
node_factor <- relevel(x=factor(cur_sce$pN_merg), ref = "0")

imagePheno(cells_sc) <- DataFrame(imageID = cur_sce$sample_id, 
          PID = cur_sce$PID,
          node = node_factor
          )

cells_sc

# Run differential interaction analysis 
spicyTest <- spicy(cells_sc, 
      condition = "node", 
      subject = "PID", 
      BPPARAM = BiocParallel::MulticoreParam(workers = 10),
      includeZeroCells = TRUE)

saveRDS(spicyTest, "/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_nodeinvolment_AllVSAll_withzero.rds")

spicy2 <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/05_spicyR/spicy_nodeinvolment_AllVSAll_withzero.rds")

topPairs(spicy2)

signifPlot(spicy2,
           type = "heatmapbliblablub",
           breaks=c(-3, 3, 0.5),
           fdr = TRUE,
           marksToPlot = unique(sce$metacluster_combined))
```

# 4. Differential abundance analysis 

## For pT 

```{r}
#pT overview
pT_simple_n <- colData(sce) %>% 
  as.data.frame %>% 
  select(sample_id,pT_simple) %>% 
  mutate(pT_simple = as.character(pT_simple)) %>%
  unique() %>% 
  group_by(pT_simple) %>% 
  count()

ggplot(pT_simple_n, aes(x=pT_simple,y=n,fill=pT_simple))+
  geom_bar(stat = "identity", color = "black")+
  scale_fill_manual(values = metadata(sce)$colors$pT_simple)+
  theme_classic()
```

```{r}
#Assess survival impact 
library(patchwork)
library(survival)
library(survminer)

sce$pT_merg_2 <- colData(sce) %>% 
  as.data.frame %>% 
  select(pT_simple) %>% 
  mutate(pT_merg = ifelse(pT_simple %in% c("3","4"),"3/4", pT_simple)) %>% pull(pT_merg)

sce$pT_merg

#also possible to use spatial_CD8_pheno_merg (cold/excluded vs inflamed)
cur_surv <- colData(sce) %>% as.data.frame() %>% 
  select(PID, pM_simple,OS_months, DFS_months, status_DFS, status_OS) %>% unique()

#Plot survival curves
fit <- survfit(Surv(OS_months, status_OS) ~ pM_simple, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          #palette = c("steelblue1","navy","firebrick"),
          log.rank.weights = "n")

fit <- survfit(Surv(DFS_months, status_DFS) ~ pM_simple, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          #palette = c("steelblue1","navy","firebrick"),
          log.rank.weights = "n")
```

### For metaclusters

```{r}
### Differential abundance analysis based on edgeR
library(edgeR)

sce <- sce[,sce$analysis_cat == "tumor"]

sce$pT_merg <- colData(sce) %>% 
  as.data.frame %>% 
  select(pT_simple) %>% 
  mutate(pT_merg = ifelse(pT_simple %in% c("3","4"),"3/4", pT_simple)) %>% pull(pT_merg)

sce <- sce[,sce$analysis_cat == "tumor"]

abundances <- table(unfactor(sce$metacluster_combined), sce$PID)
abundances <- unclass(abundances) 
head(abundances)

#relevant patient metadata (Relevel so that pT 1/2 is baseline)
meta <- colData(sce)[match(colnames(abundances), sce$PID),]
meta$pT_merg_2 <- relevel(x=factor(meta$pT_merg_2), ref = "1")

#filter
meta <- meta[!is.na(meta$pT_merg_2),]
abundances <- abundances[,colnames(abundances) %in% meta$PID]

#create DGEList - based on edgeR package
y.ab <- DGEList(abundances, samples=meta, group = meta$pT_merg_2)

#Design matrix
design <- model.matrix(~pT_merg_2, data = y.ab$samples)

#Visualize
# logCPM of abundances per cluster
cur_mat <- cpm(abundances,prior.count = 1,log = TRUE)

Heatmap(cur_mat, 
        col = viridis(100),
        column_split = unfactor(meta$pT_merg_2))%v%
  columnAnnotation(pT_merg_2 = anno_simple(unfactor(meta$pT_merg_2)))


# Estimate NB and QL dispersion 
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)

fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
plotQLDisp(fit.ab, cex=1)

# Test for differential abundance of clusters between tumor stages
res <- glmQLFTest(fit.ab, coef=ncol(design))

res$coefficients
summary(decideTests(res))

DA <- res$table

DA <- topTags(res, n = nrow(DA), adjust.method = "BH")$table

DA <- DA %>% mutate(cluster = rownames(DA), sign = DA$FDR<0.1, result = ifelse(DA$logFC > 0 & DA$FDR < 0.1, "UP",ifelse(DA$logFC < 0 & DA$FDR < 0.1, "DOWN", "NOTSIG"))) %>% 
  arrange(desc(logFC))

DA$cluster <- factor(DA$cluster, levels = DA$cluster)

sig <- DA %>% filter(FDR<0.1) %>% pull(cluster) %>% unfactor

## Visualize
#Barplot
ggplot(DA, aes(cluster, y = logFC))+
  geom_col(aes(fill=result), col = "black")+
  scale_fill_manual(values = c("#377EB8","lightgrey","#E41A1C"))+
  ylab("logFC")+
  xlab("Cluster")+
  labs(fill = "FDR<0.1")+
  ggtitle("pT_stage (1 vs 2/3/4)")+
  theme_classic()

#Volcano plot  
ggplot(DA, aes(x = logFC, y = -log10(FDR)))+
  geom_point(aes(col=cluster, size = -log10(FDR)))+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined)+
  xlab("logFC (pT: 1 vs 2/3/4)")+
  ylab("-log10(FDR)")+
  theme_classic()+
  geom_hline(yintercept = -log10(0.1), linetype = "dashed")+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")

#Abundance vs log fold change (best?)
ggplot(DA, aes(x = logFC, y = logCPM))+
  geom_point(aes(col= cluster, 
                 size = -log10(FDR)))+
  geom_label_repel(data = DA %>% filter(FDR<0.1), aes(label = cluster))+
  #scale_color_manual(values = metadata(sce)$colors$metacluster_combined)+
  xlab("logFC (pT: 1 vs 2/3/4)")+
  ylab("Abundance (logCPM)")+
  theme_classic()+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")
```



### For cellular neighborhoods

```{r}
### Differential abundance analysis based on edgeR
library(edgeR)

sce$pT_merg <- colData(sce) %>% 
  as.data.frame %>% 
  select(pT_simple) %>% 
  mutate(pT_merg = ifelse(pT_simple %in% c("2","3","4"),"2/3/4", pT_simple)) %>% pull(pT_merg)

abundances <- table(sce$cellular_neighborhood, sce$PID)
abundances <- unclass(abundances) 
head(abundances)

#relevant patient metadata (Relevel so that pT 1/2 is baseline)
meta <- colData(sce)[match(colnames(abundances), sce$PID),]
meta$pT_merg <- relevel(x=factor(meta$pT_merg), ref = "1")

#filter
meta <- meta[!is.na(meta$pT_merg),]
abundances <- abundances[,colnames(abundances) %in% meta$PID]

#create DGEList - based on edgeR package
y.ab <- DGEList(abundances, samples=meta, group = meta$pT_merg)

#Design matrix
design <- model.matrix(~pT_merg, data = y.ab$samples)

#Visualize
# logCPM of abundances per cluster
cur_mat <- cpm(abundances,prior.count = 1,log = TRUE)

Heatmap(cur_mat, 
        col = viridis(100),
        column_split = unfactor(meta$pT_merg))%v%
  columnAnnotation(pT_merg = anno_simple(unfactor(meta$pT_merg)))


# Estimate NB and QL dispersion 
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)

fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
plotQLDisp(fit.ab, cex=1)

# Test for differential abundance of clusters between tumor stages
res <- glmQLFTest(fit.ab, coef=ncol(design))

res$coefficients
summary(decideTests(res))

DA <- res$table

DA <- topTags(res, n = nrow(DA), adjust.method = "BH")$table

DA <- DA %>% mutate(cluster = rownames(DA), sign = DA$FDR<0.1, result = ifelse(DA$logFC > 0 & DA$FDR < 0.1, "UP",ifelse(DA$logFC < 0 & DA$FDR < 0.1, "DOWN", "NOTSIG"))) %>% 
  arrange(desc(logFC))

DA$cluster <- factor(DA$cluster, levels = DA$cluster)

sig <- DA %>% filter(FDR<0.1) %>% pull(cluster) %>% unfactor

## Visualize
#Barplot
ggplot(DA, aes(cluster, y = logFC))+
  geom_col(aes(fill=result), col = "black")+
  scale_fill_manual(values = c("#377EB8","lightgrey","#E41A1C"))+
  ylab("logFC")+
  xlab("Cluster")+
  labs(fill = "FDR<0.1")+
  ggtitle("pT_stage (1 vs 2/3/4)")+
  theme_classic()

#Volcano plot  
ggplot(DA, aes(x = logFC, y = -log10(FDR)))+
  geom_point(aes(col=cluster, size = -log10(FDR)))+
  #scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood)+
  xlab("logFC (pT: 1 vs 2/3/4)")+
  ylab("-log10(FDR)")+
  theme_classic()+
  geom_hline(yintercept = -log10(0.1), linetype = "dashed")+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")

#Abundance vs log fold change (best?)
diffabun_plot_1 <- ggplot(DA, aes(x = logFC, y = logCPM))+
  geom_point(aes(col= cluster, 
                 size = -log10(FDR)))+
  geom_label_repel(data = DA %>% filter(FDR<0.1), aes(label = cluster))+
  #scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood)+
  xlab("logFC (pT: 1 vs 2/3/4)")+
  ylab("Abundance (logCPM)")+
  theme_classic()+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")
```

### For spatial contexts

```{r, out.width=10, out.height=10}
### Differential abundance analysis based on edgeR
library(edgeR)

sce$pT_merg <- colData(sce) %>% 
  as.data.frame %>% 
  select(pT_simple) %>% 
  mutate(pT_merg = ifelse(pT_simple %in% c("2","3","4"),"2/3/4", pT_simple)) %>% pull(pT_merg)

abundances <- table(sce$spatial_context_filtered, sce$PID)
abundances <- unclass(abundances) 
head(abundances)

#relevant patient metadata (Relevel so that pT 1/2 is baseline)
meta <- colData(sce)[match(colnames(abundances), sce$PID),]
meta$pT_merg <- relevel(x=factor(meta$pT_merg), ref = "1")

#filter
meta <- meta[!is.na(meta$pT_merg),]
abundances <- abundances[,colnames(abundances) %in% meta$PID]

#create DGEList - based on edgeR package
y.ab <- DGEList(abundances, samples=meta, group = meta$pT_merg)

#Design matrix
design <- model.matrix(~pT_merg, data = y.ab$samples)

#Visualize
# logCPM of abundances per cluster
cur_mat <- cpm(abundances,prior.count = 1,log = TRUE)

Heatmap(cur_mat, 
        col = viridis(100),
        column_split = unfactor(meta$pT_merg))%v%
  columnAnnotation(pT_merg = anno_simple(unfactor(meta$pT_merg)))


# Estimate NB and QL dispersion 
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)

fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
plotQLDisp(fit.ab, cex=1)

# Test for differential abundance of clusters between tumor stages
res <- glmQLFTest(fit.ab, coef=ncol(design))

res$coefficients
summary(decideTests(res))

DA <- res$table

DA <- topTags(res, n = nrow(DA), adjust.method = "BH")$table

DA <- DA %>% mutate(cluster = rownames(DA), sign = DA$FDR<0.1, result = ifelse(DA$logFC > 0 & DA$FDR < 0.1, "UP",ifelse(DA$logFC < 0 & DA$FDR < 0.1, "DOWN", "NOTSIG"))) %>% 
  arrange(desc(logFC))

DA$cluster <- factor(DA$cluster, levels = DA$cluster)

sig <- DA %>% filter(FDR<0.1) %>% pull(cluster) %>% unfactor

## Visualize
#Barplot
ggplot(DA, aes(cluster, y = logFC))+
  geom_col(aes(fill=result), col = "black")+
  scale_fill_manual(values = c("#377EB8","lightgrey","#E41A1C"))+
  ylab("logFC")+
  xlab("Cluster")+
  labs(fill = "FDR<0.1")+
  ggtitle("pT_stage (1 vs 2/3/4)")+
  theme_classic()

#Volcano plot  
ggplot(DA, aes(x = logFC, y = -log10(FDR)))+
  geom_point(aes(col=cluster, size = -log10(FDR)))+
  #scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood)+
  xlab("logFC (pT: 1 vs 2/3/4)")+
  ylab("-log10(FDR)")+
  theme_classic()+
  geom_hline(yintercept = -log10(0.1), linetype = "dashed")+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")

#Abundance vs log fold change (best?)
diff.abun_SC <- ggplot(DA, aes(x = logFC, y = logCPM))+
  geom_point(aes(col= cluster, 
                 size = -log10(FDR)))+
  geom_label_repel(data = DA %>% filter(FDR<0.1), aes(label = cluster))+
  #scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood)+
  xlab("logFC (pT: 1 vs 2/3/4)")+
  ylab("Abundance (logCPM)")+
  theme_classic()+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")

```

## For pN 

```{r}
#pT overview
pN_simple_n <- colData(sce) %>% 
  as.data.frame %>% 
  select(sample_id,pN_simple) %>% 
  mutate(pN_simple = as.character(pN_simple)) %>%
  unique() %>% 
  group_by(pN_simple) %>% 
  count()

ggplot(pN_simple_n, aes(x=pN_simple,y=n,fill=pN_simple))+
  geom_bar(stat = "identity", color = "black")+
  scale_fill_manual(values = metadata(sce)$colors$pN_simple)+
  theme_classic()
```

```{r}
#Assess survival impact 
library(patchwork)
library(survival)
library(survminer)


#also possible to use spatial_CD8_pheno_merg (cold/excluded vs inflamed)
cur_surv <- colData(sce) %>% as.data.frame() %>% 
  select(PID, pN_merg,OS_months, DFS_months, status_DFS, status_OS) %>% unique()

#Plot survival curves
fit <- survfit(Surv(OS_months, status_OS) ~ pN_merg, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          #palette = c("steelblue1","navy","firebrick"),
          log.rank.weights = "n")

fit <- survfit(Surv(DFS_months, status_DFS) ~ pN_merg, data = cur_surv)
print(fit)

ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          #palette = c("steelblue1","navy","firebrick"),
          log.rank.weights = "n")
```


### For metaclusters

```{r}
### Differential abundance analysis based on edgeR
  library(edgeR)

sce_tumor$pN_merg <- colData(sce_tumor) %>% 
  as.data.frame %>% 
  select(pN_simple) %>% 
  mutate(pN_merg = ifelse(pN_simple %in% c("1","2","3"),"1/2/3", pN_simple)) %>% pull(pN_merg)

sce_tumor <- sce
abundances <- table(unfactor(sce_tumor$metacluster_combined), sce_tumor$PID)
abundances <- unclass(abundances) 
head(abundances)

#relevant patient metadata (Relevel so that pN0 is baseline)
meta <- colData(sce_tumor)[match(colnames(abundances), sce_tumor$PID),]
meta$pN_merg <- relevel(x=factor(meta$pN_merg), ref = "0")

#filter
meta <- meta[!is.na(meta$pN_merg),]
abundances <- abundances[,colnames(abundances) %in% meta$PID]

#create DGEList - based on edgeR package
y.ab <- DGEList(abundances, samples=meta, group = meta$pN_merg)

#Design matrix
design <- model.matrix(~pN_merg, data = y.ab$samples)

#Visualize
# logCPM of abundances per cluster
cur_mat <- cpm(abundances,prior.count = 1,log = TRUE)

Heatmap(cur_mat, 
        col = viridis(100),
        column_split = unfactor(meta$pN_merg))%v%
  columnAnnotation(pN_merg = anno_simple(unfactor(meta$pN_merg)))


# Estimate NB and QL dispersion 
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)

fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
plotQLDisp(fit.ab, cex=1)

# Test for differential abundance of clusters between tumor stages
res <- glmQLFTest(fit.ab, coef=ncol(design))

res$coefficients
summary(decideTests(res))

DA <- res$table

DA <- topTags(res, n = nrow(DA), adjust.method = "BH")$table

DA <- DA %>% mutate(cluster = rownames(DA), sign = DA$FDR<0.1, result = ifelse(DA$logFC > 0 & DA$FDR < 0.1, "UP",ifelse(DA$logFC < 0 & DA$FDR < 0.1, "DOWN", "NOTSIG"))) %>% 
  arrange(desc(logFC))

DA$cluster <- factor(DA$cluster, levels = DA$cluster)

sig <- DA %>% filter(FDR<0.1) %>% pull(cluster) %>% unfactor

## Visualize
#Barplot
ggplot(DA, aes(cluster, y = logFC))+
  geom_col(aes(fill=result), col = "black")+
  scale_fill_manual(values = c("#377EB8","lightgrey","#E41A1C"))+
  ylab("logFC")+
  xlab("Cluster")+
  labs(fill = "FDR<0.1")+
  ggtitle("pN_stage (1 vs 2/3/4)")+
  theme_classic()

#Volcano plot  
ggplot(DA, aes(x = logFC, y = -log10(FDR)))+
  geom_point(aes(col=cluster, size = -log10(FDR)))+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined)+
  xlab("logFC (pN: 1 vs 2/3/4)")+
  ylab("-log10(FDR)")+
  theme_classic()+
  geom_hline(yintercept = -log10(0.1), linetype = "dashed")+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")

#Abundance vs log fold change (best?)
ggplot(DA, aes(x = logFC, y = logCPM))+
  geom_point(aes(col= cluster, 
                 size = -log10(FDR)))+
  geom_label_repel(data = DA %>% filter(FDR<0.1), aes(label = cluster))+
  #scale_color_manual(values = metadata(sce)$colors$metacluster_combined)+
  xlab("logFC (pN: 1 vs 2/3/4)")+
  ylab("Abundance (logCPM)")+
  theme_classic()+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")
```

## For CD8 spatial scores 

### For metaclusters

```{r}
### Differential abundance analysis based on edgeR
library(edgeR)

sce$spatial_CD8_pheno_merg <- colData(sce) %>% 
  as.data.frame %>% 
  select(spatial_CD8_pheno) %>% 
  mutate(spatial_CD8_pheno_merg = ifelse(spatial_CD8_pheno %in% c("cold","excluded"),"cold/excluded", spatial_CD8_pheno)) %>% pull(spatial_CD8_pheno_merg)

#test_sce <- sce[,sce$spatial_CD8_pheno %in% c("cold","inflamed")]

abundances <- table(sce$metacluster_combined, sce$PID)
abundances <- unclass(abundances) 
head(abundances)

#relevant patient metadata (Relevel so that pT 1/2 is baseline)
meta <- colData(sce)[match(colnames(abundances), sce$PID),]
meta$spatial_CD8_pheno_merg <- relevel(x=factor(meta$spatial_CD8_pheno_merg), ref = "cold/excluded")

#filter
meta <- meta[!is.na(meta$spatial_CD8_pheno_merg),]
abundances <- abundances[,colnames(abundances) %in% meta$PID]

#create DGEList - based on edgeR package
y.ab <- DGEList(abundances, samples=meta, group = meta$spatial_CD8_pheno_merg)

#Design matrix
design <- model.matrix(~spatial_CD8_pheno_merg, data = y.ab$samples)

#Visualize
# logCPM of abundances per cluster
cur_mat <- cpm(abundances,prior.count = 1,log = TRUE)

Heatmap(cur_mat, 
        col = viridis(100),
        column_split = unfactor(meta$spatial_CD8_pheno_merg))%v%
  columnAnnotation(spatial_CD8_pheno_merg_merg = anno_simple(unfactor(meta$spatial_CD8_pheno_merg)))


# Estimate NB and QL dispersion 
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)

fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
plotQLDisp(fit.ab, cex=1)

# Test for differential abundance of clusters between tumor stages
res <- glmQLFTest(fit.ab, coef=ncol(design))

res$coefficients
summary(decideTests(res))

DA <- res$table

DA <- topTags(res, n = nrow(DA), adjust.method = "BH")$table

DA <- DA %>% mutate(cluster = rownames(DA), sign = DA$FDR<0.1, result = ifelse(DA$logFC > 0 & DA$FDR < 0.1, "UP",ifelse(DA$logFC < 0 & DA$FDR < 0.1, "DOWN", "NOTSIG"))) %>% arrange(desc(logFC)) %>% mutate(category = ifelse(str_detect(cluster,"tumor"),"tumor","non_tumor"))

DA$cluster <- factor(DA$cluster, levels = DA$cluster)

sig <- DA %>% filter(FDR<0.1) %>% pull(cluster) %>% unfactor



## Visualize
#Barplot
ggplot(DA, aes(cluster, y = logFC))+
  geom_col(aes(fill=result), col = "black")+
  scale_fill_manual(values = c("#377EB8","lightgrey","#E41A1C"))+
  ylab("logFC")+
  xlab("Cluster")+
  labs(fill = "FDR<0.1")+
  ggtitle("Spatial CD8 phenotype (cold vs inflamed)")+
  theme_classic()

#Volcano plot  
ggplot(DA, aes(x = logFC, y = -log10(FDR)))+
  geom_point(aes(col=cluster, size = -log10(FDR)))+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined)+
  xlab("logFC (cold vs inflamed)")+
  ylab("-log10(FDR)")+
  theme_classic()+
  geom_hline(yintercept = -log10(0.1), linetype = "dashed")+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")

#Abundance vs log fold change (best?)
ggplot(DA, aes(x = logFC, y = logCPM))+
  geom_point(aes(col= cluster, 
                 size = -log10(FDR), shape = category))+
  geom_label_repel(data = DA %>% filter(FDR<0.1), aes(label = cluster))+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined)+
  xlab("logFC (cold/excluded vs inflamed)")+
  ylab("Abundance (logCPM)")+
  theme_classic()+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")
```

### For spatial communities

```{r}
### Differential abundance analysis based on edgeR
library(edgeR)

sce$spatial_CD8_pheno_merg <- colData(sce) %>% 
  as.data.frame %>% 
  select(spatial_CD8_pheno) %>% 
  mutate(spatial_CD8_pheno_merg = ifelse(spatial_CD8_pheno %in% c("cold","excluded"),"cold/excluded", spatial_CD8_pheno)) %>% pull(spatial_CD8_pheno_merg)

abundances <- table(sce$spatial_metacommunity, sce$PID)
abundances <- unclass(abundances) 
head(abundances)

#relevant patient metadata (Relevel so that pT 1/2 is baseline)
meta <- colData(sce)[match(colnames(abundances), sce$PID),]
meta$spatial_CD8_pheno_merg <- relevel(x=factor(meta$spatial_CD8_pheno_merg), ref = "cold/excluded")

#filter
meta <- meta[!is.na(meta$spatial_CD8_pheno_merg),]
abundances <- abundances[,colnames(abundances) %in% meta$PID]

#create DGEList - based on edgeR package
y.ab <- DGEList(abundances, samples=meta, group = meta$spatial_CD8_pheno_merg)

#Design matrix
design <- model.matrix(~spatial_CD8_pheno_merg, data = y.ab$samples)

#Visualize
# logCPM of abundances per cluster
cur_mat <- cpm(abundances,prior.count = 1,log = TRUE)

Heatmap(cur_mat, 
        col = viridis(100),
        column_split = unfactor(meta$spatial_CD8_pheno_merg))%v%
  columnAnnotation(spatial_CD8_pheno_merg = anno_simple(unfactor(meta$spatial_CD8_pheno_merg)))


# Estimate NB and QL dispersion 
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)

fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
plotQLDisp(fit.ab, cex=1)

# Test for differential abundance of clusters between tumor stages
res <- glmQLFTest(fit.ab, coef=ncol(design))

res$coefficients
summary(decideTests(res))

DA <- res$table

DA <- topTags(res, n = nrow(DA), adjust.method = "BH")$table

DA <- DA %>% mutate(cluster = rownames(DA), sign = DA$FDR<0.1, result = ifelse(DA$logFC > 0 & DA$FDR < 0.1, "UP",ifelse(DA$logFC < 0 & DA$FDR < 0.1, "DOWN", "NOTSIG"))) %>% 
  arrange(desc(logFC))

DA$cluster <- factor(DA$cluster, levels = DA$cluster)

sig <- DA %>% filter(FDR<0.1) %>% pull(cluster) %>% unfactor

## Visualize
#Barplot
ggplot(DA, aes(cluster, y = logFC))+
  geom_col(aes(fill=result), col = "black")+
  scale_fill_manual(values = c("#377EB8","lightgrey","#E41A1C"))+
  ylab("logFC")+
  xlab("Cluster")+
  labs(fill = "FDR<0.1")+
  ggtitle("Spatial CD8 phenotype (cold/excluded vs inflamed)")+
  theme_classic()

#Volcano plot  
ggplot(DA, aes(x = logFC, y = -log10(FDR)))+
  geom_point(aes(col=cluster, size = -log10(FDR)))+
  #scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood)+
  xlab("logFC (cold/excluded vs inflamed)")+
  ylab("-log10(FDR)")+
  theme_classic()+
  geom_hline(yintercept = -log10(0.1), linetype = "dashed")+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")

#Abundance vs log fold change (best?)
ggplot(DA, aes(x = logFC, y = logCPM))+
  geom_point(aes(col= cluster, 
                 size = -log10(FDR)))+
  geom_label_repel(data = DA %>% filter(FDR<0.1), aes(label = cluster))+
  #scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood)+
  xlab("logFC (cold/excluded vs inflamed)")+
  ylab("Abundance (logCPM)")+
  theme_classic()+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")
```

### For cellular neighborhoods 

```{r}
### Differential abundance analysis based on edgeR
library(edgeR)

sce$spatial_CD8_pheno_merg <- colData(sce) %>% 
  as.data.frame %>% 
  select(spatial_CD8_pheno) %>% 
  mutate(spatial_CD8_pheno_merg = ifelse(spatial_CD8_pheno %in% c("cold","excluded"),"cold/excluded", spatial_CD8_pheno)) %>% pull(spatial_CD8_pheno_merg)

abundances <- table(sce$cellular_neighborhood, sce$PID)
abundances <- unclass(abundances) 
head(abundances)

#relevant patient metadata (Relevel so that pT 1/2 is baseline)
meta <- colData(sce)[match(colnames(abundances), sce$PID),]
meta$spatial_CD8_pheno_merg <- relevel(x=factor(meta$spatial_CD8_pheno_merg), ref = "cold/excluded")

#filter
meta <- meta[!is.na(meta$spatial_CD8_pheno_merg),]
abundances <- abundances[,colnames(abundances) %in% meta$PID]

#create DGEList - based on edgeR package
y.ab <- DGEList(abundances, samples=meta, group = meta$spatial_CD8_pheno_merg)

#Design matrix
design <- model.matrix(~spatial_CD8_pheno_merg, data = y.ab$samples)

#Visualize
# logCPM of abundances per cluster
cur_mat <- cpm(abundances,prior.count = 1,log = TRUE)

Heatmap(cur_mat, 
        col = viridis(100),
        column_split = unfactor(meta$spatial_CD8_pheno_merg))%v%
  columnAnnotation(spatial_CD8_pheno_merg = anno_simple(unfactor(meta$spatial_CD8_pheno_merg)))


# Estimate NB and QL dispersion 
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)

fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
plotQLDisp(fit.ab, cex=1)

# Test for differential abundance of clusters between tumor stages
res <- glmQLFTest(fit.ab, coef=ncol(design))

res$coefficients
summary(decideTests(res))

DA <- res$table

DA <- topTags(res, n = nrow(DA), adjust.method = "BH")$table

DA <- DA %>% mutate(cluster = rownames(DA), sign = DA$FDR<0.1, result = ifelse(DA$logFC > 0 & DA$FDR < 0.1, "UP",ifelse(DA$logFC < 0 & DA$FDR < 0.1, "DOWN", "NOTSIG"))) %>% 
  arrange(desc(logFC))

DA$cluster <- factor(DA$cluster, levels = DA$cluster)

sig <- DA %>% filter(FDR<0.1) %>% pull(cluster) %>% unfactor

## Visualize
#Barplot
ggplot(DA, aes(cluster, y = logFC))+
  geom_col(aes(fill=result), col = "black")+
  scale_fill_manual(values = c("#377EB8","lightgrey","#E41A1C"))+
  ylab("logFC")+
  xlab("Cluster")+
  labs(fill = "FDR<0.1")+
  ggtitle("Spatial CD8 phenotype (cold/excluded vs inflamed)")+
  theme_classic()

#Volcano plot  
ggplot(DA, aes(x = logFC, y = -log10(FDR)))+
  geom_point(aes(col=cluster, size = -log10(FDR)))+
  #scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood)+
  xlab("logFC (cold/excluded vs inflamed)")+
  ylab("-log10(FDR)")+
  theme_classic()+
  geom_hline(yintercept = -log10(0.1), linetype = "dashed")+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")

#Abundance vs log fold change (best?)
diffabun_plot_cd8_2 <- ggplot(DA, aes(x = logFC, y = logCPM))+
  geom_point(aes(col= cluster, 
                 size = -log10(FDR)))+
  geom_label_repel(data = DA %>% filter(FDR<0.1), aes(label = cluster))+
  #scale_color_manual(values = metadata(sce)$colors$cellular_neighborhood)+
  xlab("logFC (cold/excluded vs inflamed)")+
  ylab("Abundance (logCPM)")+
  theme_classic()+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")
```

### For spatial contexts

```{r}

### Differential abundance analysis based on edgeR
library(edgeR)

sce$spatial_CD8_pheno_merg <- colData(sce) %>% 
  as.data.frame %>% 
  select(spatial_CD8_pheno) %>% 
  mutate(spatial_CD8_pheno_merg = ifelse(spatial_CD8_pheno %in% c("cold","excluded"),"cold/excluded", spatial_CD8_pheno)) %>% pull(spatial_CD8_pheno_merg)

abundances <- table(sce$spatial_context_filtered, sce$PID)
abundances <- unclass(abundances) 
head(abundances)

#relevant patient metadata (Relevel so that pT 1/2 is baseline)
meta <- colData(sce)[match(colnames(abundances), sce$PID),]
meta$spatial_CD8_pheno_merg <- relevel(x=factor(meta$spatial_CD8_pheno_merg), ref = "cold/excluded")

#filter
meta <- meta[!is.na(meta$spatial_CD8_pheno_merg),]
abundances <- abundances[,colnames(abundances) %in% meta$PID]

#create DGEList - based on edgeR package
y.ab <- DGEList(abundances, samples=meta, group = meta$spatial_CD8_pheno_merg)

#Design matrix
design <- model.matrix(~spatial_CD8_pheno_merg, data = y.ab$samples)

#Visualize
# logCPM of abundances per cluster
cur_mat <- cpm(abundances,prior.count = 1,log = TRUE)

Heatmap(cur_mat, 
        col = viridis(100),
        column_split = unfactor(meta$spatial_CD8_pheno_merg))%v%
  columnAnnotation(spatial_CD8_pheno_merg = anno_simple(unfactor(meta$spatial_CD8_pheno_merg)))


# Estimate NB and QL dispersion 
y.ab <- estimateDisp(y.ab, design, trend="none")
summary(y.ab$common.dispersion)
plotBCV(y.ab, cex=1)

fit.ab <- glmQLFit(y.ab, design, robust=TRUE, abundance.trend=FALSE)
summary(fit.ab$var.prior)
plotQLDisp(fit.ab, cex=1)

# Test for differential abundance of clusters between tumor stages
res <- glmQLFTest(fit.ab, coef=ncol(design))

res$coefficients
summary(decideTests(res))

DA <- res$table

DA <- topTags(res, n = nrow(DA), adjust.method = "BH")$table

DA <- DA %>% mutate(cluster = rownames(DA), sign = DA$FDR<0.1, result = ifelse(DA$logFC > 0 & DA$FDR < 0.1, "UP",ifelse(DA$logFC < 0 & DA$FDR < 0.1, "DOWN", "NOTSIG"))) %>% 
  arrange(desc(logFC))

DA$cluster <- factor(DA$cluster, levels = DA$cluster)

sig <- DA %>% filter(FDR<0.1) %>% pull(cluster) %>% unfactor

## Visualize
#Barplot
ggplot(DA, aes(cluster, y = logFC))+
  geom_col(aes(fill=result), col = "black")+
  scale_fill_manual(values = c("#377EB8","lightgrey","#E41A1C"))+
  ylab("logFC")+
  xlab("Cluster")+
  labs(fill = "FDR<0.1")+
  ggtitle("Spatial CD8 phenotype (cold/excluded vs inflamed)")+
  theme_classic()

#Volcano plot  
ggplot(DA, aes(x = logFC, y = -log10(FDR)))+
  geom_point(aes(col=cluster, size = -log10(FDR)))+
  scale_color_manual(values = metadata(sce)$colors$col_SC)+
  xlab("logFC (cold/excluded vs inflamed)")+
  ylab("-log10(FDR)")+
  theme_classic()+
  geom_hline(yintercept = -log10(0.1), linetype = "dashed")+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")

#Abundance vs log fold change (best?)
diffabun_plot_cd8_3 <- ggplot(DA, aes(x = logFC, y = logCPM))+
  geom_point(aes(col= cluster, 
                 size = -log10(FDR)))+
  geom_label_repel(data = DA %>% filter(FDR<0.1), aes(label = cluster))+
  scale_color_manual(values = metadata(sce)$colors$col_SC)+
  xlab("logFC (cold/excluded vs inflamed)")+
  ylab("Abundance (logCPM)")+
  theme_classic()+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")
```

## 5. Image visualization 

## Extract representative images

```{r}
images <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/images_TNBC_new.rds")
masks <- readRDS("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/masks_segtest_4.rds")
```

```{r}
library(cytomapper)

#Select images of interest 

## Inflamed patients with B cell patches 
img_ids <- colData(sce) %>% as.data.frame() %>% select(PID, sample_id, B_cell_score, spatial_CD8_pheno) %>% unique() %>% filter(spatial_CD8_pheno == "inflamed" & B_cell_score == "Large_B_patch") %>% pull(sample_id) %>% unique()

#img_ids <- img_ids[1:5]

# Select images
cur_images <- images[img_ids]

#Subset mask and object
cur_mask <- masks[img_ids]
cur_sce <- sce[,sce$sample_id %in% names(cur_images)]
```

```{r}
##Visualize metaclusters on images - select 10 images for each category with highest number of cells
cur_PID <- colData(sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% filter(metacluster_combined == "tumor_8") %>% count(PID) %>% arrange(desc(n)) %>% slice(1:10) %>% pull(PID)

cur_sample <- colData(sce) %>% as.data.frame %>% filter(PID %in% cur_PID) %>% pull(sample_id) %>% unique()

#cur_sample <- "ZTMA249.1_ZTMA249_ID_134_BX6Y2_19"

# Images
cur_images <- images[cur_sample]
cur_masks <- masks[cur_sample]

#Subset sce
cur_sce <- sce[,sce$sample_id %in% names(cur_images)]
```

Interactive visualization with cytoviewer 

```{r}
library(cytoviewer)

app <- cytoviewer(image = cur_images, mask = cur_masks, object = cur_sce, cell_id = "ObjectNumber",img_id = "sample_id")

shiny::runApp(app, launch.browser = TRUE)
```



## Save plots as png 

```{r}
pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TSNE_metacluster_TME_combined.pdf", width = 6, height = 5)
plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "metacluster_TME_combined")+
  scale_color_manual(values = color_TME, limits = force)
dev.off()
```



## Save plots as pdf

```{r save_plots}
##IMPORTANT: change to chunk output in console for this last part 

##save plots as pdf (vector graphics)
pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_diffAbun_Metacluster_pT.pdf",width = 9,height = 6)
diffabun_plot
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_pT_dist.pdf",width = 6,height = 5)
ggplot(pT_simple_n, aes(x=pT_simple,y=n,fill=pT_simple))+
  geom_bar(stat = "identity", color = "black")+
  scale_fill_manual(values = metadata(sce)$colors$pT_simple)+
  theme_classic()
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_CellularNeighborhood_Heatmap.pdf",width = 10,height = 6)
h
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_SpatialComm_DFS.pdf",width = 8,height = 6)
hr_prop/
hr_mean
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_diffAbun_CN_pT.pdf",width = 8,height = 6)
diffabun_plot_1 
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_SC_graph.pdf",width = 12,height = 8)
plotSpatialContext(sce, entry = "spatial_context_filtered", 
                   group_by = "PID", node_color_by = "n_group", node_size_by = "n_cells")+
  scale_color_viridis()
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_SC_viz.pdf",width = 5,height = 8)
p1/p2
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_SC_lasso_OS.pdf",width = 6,height = 4)
lasso_plot
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_SC_lasso_DFS.pdf",width = 6,height = 4)
lasso_plot
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_diffAbun_SC_pT.pdf",width = 9,height = 6)
diff.abun_SC
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_CD8pheno_OS.pdf",width = 6,height = 6, onefile = FALSE)
CD8_OS
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_diffAbun_CD8pheno_CN.pdf",width = 9,height = 5)
diffabun_plot_cd8_2
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_diffAbun_CD8pheno_SC.pdf",width = 9,height = 5)
diffabun_plot_cd8_3
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_Mixing_DFS.pdf",width = 6,height = 6, onefile = FALSE)
mix_DFS
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TNBC_Mixing_DiffAbun.pdf",width = 6,height = 6, onefile = FALSE)
diffabun_plot_mixing_1
dev.off()


pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TSNE_PID.pdf",width = 6,height = 6, onefile = FALSE)
plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "PID")+#shape_by = "analysis_cat")+
  scale_color_manual(values = metadata(sce)$colors$PID)+
  guides(color = "none")
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TSNE_TMANr.pdf",width = 6,height = 6, onefile = FALSE)
plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "TMANr")+#shape_by = "analysis_cat")+
  scale_color_manual(values = metadata(sce)$colors$TMANr)
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TSNE_analysiscat.pdf",width = 6,height = 6, onefile = FALSE)
plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "analysis_cat")+#shape_by = "analysis_cat")+
  scale_color_manual(values = metadata(sce)$colors$analysis_cat)
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TSNE_TMEmetacluster.pdf",width = 5,height = 5, onefile = FALSE)
plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "metacluster_tumor_combined")+#shape_by = "analysis_cat")+
  scale_color_manual(values = color_TME, limits = force)+
  guides(color = "none")
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/TSNE_TUMORmetacluster.pdf",width = 6,height = 6, onefile = FALSE)
plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "metacluster_TME_combined")+#shape_by = "analysis_cat")+
  scale_color_manual(values = color_TME, limits = force)
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/MC8_OverallFreq_Barplot.pdf",width = 8,height = 2.5, onefile = FALSE)
ggplot(PID_MC8_overall_plot) +
  geom_tile(color = "black",aes(n, category, fill = PID_category), position = "stack")+
  scale_fill_brewer(palette = "Blues")+
  theme_classic(base_size = 15)+
  ylab("Density")+
  theme(axis.title.x = element_blank())
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/MC8_Patch_Abundant_Pheno_Barplot.pdf",width = 8,height = 2.5, onefile = FALSE)
ggplot(PID_patch_abundant) +
  geom_tile(color = "black",aes(n,category, fill = metacluster_combined), position = "stack")+
  scale_fill_manual(values=metadata(sce)$colors$metacluster_combined) + 
  theme_classic(base_size = 15)+
  ylab("Density")+
  xlab("PID")
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/MC8_InteractionTesting_Barplot.pdf",width = 8,height = 2.5, onefile = FALSE)
ggplot(interaction_tumor_plot) +
        geom_tile(aes(reorder(to_label,sum_sigval), from_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = "blue", mid = "white", high = "red")+
  theme_classic()
dev.off()




pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/MC8_Patches_KaplanMeier.pdf",width = 6,height = 5, onefile = FALSE)
ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("#377EB8", "#E41A1C"),
          #log.rank.weights = "n"
)
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/MC8_Patches_Cox_Uni.pdf",width = 4,height = 5, onefile = FALSE)
hr_prop
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/MC8_Patches_Cox_Multi.pdf",width = 8,height = 5, onefile = FALSE)
hr_prop
dev.off()


pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/CK57_OverallFreq_Barplot.pdf",width = 8,height = 2.5, onefile = FALSE)
ggplot(PID_CK57_overall_plot) +
  geom_tile(color = "black",aes(n, category, fill = PID_category), position = "stack")+
  scale_fill_brewer(palette = "Blues")+
  theme_classic(base_size = 15)+
  ylab("Density")+
  theme(axis.title.x = element_blank())
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/CK57_Patches_MostAbundant_Barplot.pdf",width = 8,height = 2.5, onefile = FALSE)
ggplot(PID_patch_abundant) +
  geom_tile(color = "black",aes(n, category, fill = CK5_7_score), position = "stack")+
  scale_fill_manual(values=metadata(sce)$colors$CK5_7_score) + 
  theme_classic(base_size = 15)+
  ylab("Density")+
  xlab("PID")
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/CK57_InteractionTesting_Barplot.pdf",width = 8,height = 2.5, onefile = FALSE)
interaction_tumor_CK57_total %>% as_tibble() %>% filter(from_label %in% c("CK5/7+")) %>% filter(to_label != "CK5/7+") %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
    ggplot() +
        geom_tile(aes(reorder(to_label,sum_sigval) ,from_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = "blue", mid = "white", high = "red") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  theme_classic()
dev.off()




pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_DFS_Kaplan.pdf",width = 5,height = 7, onefile = FALSE)
ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("steelblue1","navy","firebrick"),
          log.rank.weights = "n")
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_OS_Kaplan.pdf",width = 5,height = 7, onefile = FALSE)
ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("steelblue1","navy","firebrick"),
          log.rank.weights = "n")
dev.off()


pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_merg_OS_Kaplan.pdf",width = 5,height = 7, onefile = FALSE)
ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("steelblue1","firebrick"),
          log.rank.weights = "n")
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_merg_DFS_Kaplan.pdf",width = 5,height = 7, onefile = FALSE)
ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = c("steelblue1","firebrick"),
          log.rank.weights = "n")
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_merg_DFS_Cox_Multi.pdf",width = 7,height = 5, onefile = FALSE)
ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
#coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metaclusters")+
ylab("HR for con_prop")+
theme_classic()+
coord_cartesian(ylim=c(0,63))+
#scale_y_continuous(trans = "log10")
theme(axis.text.x = element_text(angle = 90))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_merg_DFS_Cox_Uni.pdf",width = 4,height = 5, onefile = FALSE)
hr_prop
dev.off()


pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_DiffAbun.pdf",width = 8,height = 7, onefile = FALSE)
ggplot(DA, aes(x = logFC, y = logCPM))+
  geom_point(aes(col= cluster, 
                 size = -log10(FDR), shape = category))+
  geom_label_repel(data = DA %>% filter(FDR<0.1), aes(label = cluster))+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined)+
  xlab("logFC (cold/excluded vs inflamed)")+
  ylab("Abundance (logCPM)")+
  theme_classic()+
  geom_vline(xintercept = 0, linetype = "dashed")+
  labs(color = "cluster")
dev.off()


pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_spiyR_tumor_CD8.pdf",width = 5,height = 4, onefile = FALSE)
signifPlot(spicyTest,
           type = "heatmapbliblablub",
           breaks=c(-3, 3, 0.5),
           fdr = TRUE,
           marksToPlot = c("tumor","CD8_T_cell"))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_spiyR_tumorpheno_CD8.pdf",width = 6,height = 5, onefile = FALSE)
signifPlot(spicyTest2,
           type = "heatmapbliblablub",
           breaks=c(-3, 3, 0.5),
           fdr = TRUE,
           marksToPlot = unfactor(unique(cur_sce$metacluster_combined)))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_spiyR_tumorpheno_TME_CD8.pdf",width = 9,height = 6, onefile = FALSE)
signifPlot(spicyTest3,
           type = "heatmapbliblablub",
           breaks=c(-3, 3, 0.5),
           fdr = TRUE,
           marksToPlot = unfactor(unique(sce$metacluster_combined)))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_Ki67_phenotype.pdf",width = 5,height = 4, onefile = FALSE)
ggplot(cur_plot) +
  geom_tile(color = "black",aes(CD8Tcell_type, fra, fill = Ki67_GMM), position = "stack")+
  scale_fill_brewer(palette = "Paired")+
  theme_classic(base_size = 15)+
  ylab("Density")+
  theme(axis.title.x = element_blank())+
  ggtitle(paste("p (Chi-Square) = ",cur_test_out$p.value))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_Tumor_expression.pdf",width = 7,height = 6, onefile = FALSE)
Heatmap(assay(spatialpheno_mean_sce, "exprs"), col = viridis(100), name = "exprs", cluster_columns = FALSE, row_names_side = "left", show_row_dend = FALSE)+
  Heatmap(mat_scaled, name = "scaled exprs", cluster_columns = FALSE)+
  rowAnnotation(test = anno_text(test_result$psignif.adj))
dev.off()


pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_NumberBpatches.pdf",width = 7,height = 4, onefile = FALSE)
ggplot(plot_df, aes(x = spatial_CD8_pheno, y = n_Bpatch))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = spatial_CD8_pheno), size = 3, position=position_jitter(w=0.1,h=0.1))+
  guides(color = "none")+
  scale_color_manual(values = metadata(sce)$colors$spatial_CD8_pheno)+
  theme_classic(base_size = 12)+
  coord_cartesian(ylim = c(0,15))+
  theme(axis.title.x = element_blank())+
  ylab("Number of B cell patches per PID")+
  stat_compare_means(method = "kruskal.test")
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Spatial_CD8_Bpatchsize.pdf",width = 7,height = 4, onefile = FALSE)
ggplot(plot) + 
  geom_col(aes(x=spatial_CD8_pheno, y=fraction, fill=B_cell_score), color = "black") +
  theme_classic() + 
  xlab("Fraction of PID") +
  ylab("")+
  scale_fill_brewer(palette = "Paired")+
  ggtitle(paste0("p (Fisher) = ", plot_test_out$p.value))
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Mixing_score_OS.pdf",width = 5,height = 6, onefile = FALSE)
mix_OS
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Mixing_score_DFS.pdf",width = 5,height = 6, onefile = FALSE)
mix_DFS
dev.off()

pdf("/mnt/central_nas/tnbc_volume/TNBC/data_analysis/01_figures/07_combined/Tumor_exprs_SpatialCD8.pdf",width = 6,height = 5, onefile = FALSE)
draw(h,annotation_legend_list = list(lgd_cat))
dev.off()

```

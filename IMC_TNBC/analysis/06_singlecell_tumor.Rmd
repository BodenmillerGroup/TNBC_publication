---
title: "06_singlecell_tumor"
author: "Lasse Meyer"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Software requirements

```{r lib, message=FALSE,warning=FALSE}
#Data containers
library(SpatialExperiment)
library(SingleCellExperiment)

#Data processing
library(scuttle)
library(scater)
library(scran)
library(imcRtools)

#Data visualization
library(cytomapper)
library(dittoSeq)
library(pheatmap)
library(cowplot)
library(ComplexHeatmap)

#Utilities
library(tidyverse)
library(openxlsx)
library(stringr)
library(patchwork)
library(parallel)
library(BiocParallel)
library(BiocNeighbors)
library(BiocSingular)
library(tiff)
library(ggrepel)
library(EBImage)
library(viridis)
library(mclust)
library(Rphenograph)
library(igraph)
library(RColorBrewer)
library(foreach)
library(clValid)
library(bluster)
library(psych)
library(corrplot)
library(psych)

#Batch correction
library(batchelor)
```

# Single-cell analysis - Pipeline 2 - TNBC tumor phenotypes

Here, we will perform the second single cell analysis steps, including phenotyping tumor cells.

## Read in data and filter for ZTMA249
First, we will read in the `SingleCellExperiment` object containing the cleaned, spillover- and (batch-corrected) single-cell data. 
**Important:** For now, We will filter the object for ZTMA249 samples, since we are sure that those are TNBC. 

```{r read-data-batch-correction, message=FALSE}
sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_Clus_249.rds")
```

## Define markers for clustering
```{r tumor_markers, message = FALSE, warning = FALSE}
cluster_channel = c("CK5","CK8_18","CD15","KRT14","cMYC","HER2","ER","PR","p53","AR","GATA3","EGFR","p_mTOR","CK7","Ki67","Vimentin")

cell_state_channel = c("pH3","H3K27me3","Bcl2", "c_Cas3_PARP","S6", "CD44")

other_immune_channel = c("panCK","Ecad","SMA","Fibronectin","CD68","CD3","CD68","CD20","HLA_DR","CD11c","CD45","CD20","CD8a","CD4","CD31_vWF")

#Add to sce
rowData(sce)$cluster_channel <- (rowData(sce)$clean_target %in% cluster_channel)
rowData(sce)$cell_state_channel <- (rowData(sce)$clean_target %in% cell_state_channel)
rowData(sce)$other_immune_channel <- (rowData(sce)$clean_target %in% other_immune_channel)
```

## Filter sce for tumor cells
Here, we will filter for tumor cells using identified epithelial and mixed clusters (cluster categories).

```{r filter sce, message=FALSE}
#based on cluster categories (n=327897)
sce <- sce[,colData(sce)$cluster_category %in% c("Epithelial","Mixed")]
sce
```

## Perform overclustering and hierarchical clustering
Next, we will run Rphenograph (Jaccard-based weights, Louvain clustering as community detection algorithm) clustering with different resolution parameters (k=30,50,75,100). 

```{r overcluster, message=FALSE}
#k=30
set.seed(22)
snn.sce <- buildSNNGraph(sce[rowData(sce)$cluster_channel==TRUE,], k=30, 
                         d = NA, 
                         type = "jaccard",
                         assay.type = "exprs",
                         BNPARAM=AnnoyParam(),
                         BPPARAM = MulticoreParam(workers = (detectCores()-2), progressbar = TRUE)
                         )

clusters_3 <- igraph::cluster_louvain(snn.sce)
sce$cluster_30 <- as.factor(clusters_3$membership)
unique(sce$cluster_30)

#Save SCEs after clustering
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_249_Tumor_CC_ClusterChannelClus_k.rds")


#k=50
set.seed(22)
snn.sce <- buildSNNGraph(sce[rowData(sce)$cluster_channel==TRUE,], k=50, 
                         d = NA, 
                         type = "jaccard",
                         assay.type = "exprs",
                         BNPARAM=AnnoyParam(),
                         BPPARAM = MulticoreParam(workers = (detectCores()-2), progressbar = TRUE)
                         )

clusters <- igraph::cluster_louvain(snn.sce)
sce$cluster_50 <- as.factor(clusters$membership)
unique(sce$cluster_50)

#Save SCEs after clustering
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_249_Tumor_CC_ClusterChannelClus_k.rds")

#k=75
set.seed(22)
snn.sce <- buildSNNGraph(sce[rowData(sce)$cluster_channel==TRUE,], k=75, 
                         d = NA, 
                         type = "jaccard",
                         assay.type = "exprs",
                         BNPARAM=AnnoyParam(),
                         BPPARAM = MulticoreParam(workers = (detectCores()-2), progressbar = TRUE)
                         )

clusters_1 <- igraph::cluster_louvain(snn.sce)
sce$cluster_75 <- as.factor(clusters_1$membership)
unique(sce$cluster_75)

#Save SCEs after clustering
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_249_Tumor_CC_ClusterChannelClus_k.rds")

#k=100
set.seed(22)
snn.sce <- buildSNNGraph(sce[rowData(sce)$cluster_channel==TRUE,], k=100, 
                         d = NA, 
                         type = "jaccard",
                         assay.type = "exprs",
                         BNPARAM=AnnoyParam(),
                         BPPARAM = MulticoreParam(workers = (detectCores()-2), progressbar = TRUE)
                         )

clusters_2 <- igraph::cluster_louvain(snn.sce)
sce$cluster_100 <- as.factor(clusters_2$membership)
unique(sce$cluster_100)

#Save SCEs after clustering
saveRDS(sce, "/mnt/rcc_volume/TNBC/data_analysis/sce_TNBC_249_Tumor_CC_ClusterChannelClus_k.rds")
```

### Cluster stability testing and comparison

```{r clustree, message = FALSE, warning=FALSE}
#Read sce after clustering and GMM
sce <- readRDS("/Volumes/rcc_volume/TNBC/data_analysis/sce_TNBC_249_Tumor_CC_ClusterChannelClus_k.rds")
sce

#Pairwise rand index 
#Agreement between two clustering approaches - ARI > 0.5 = "good" similarity
pairwiseRand(sce$cluster_30,sce$cluster_50, mode = "index")
pairwiseRand(sce$cluster_50,sce$cluster_75, mode = "index")
pairwiseRand(sce$cluster_75,sce$cluster_100, mode = "index")

#Over different resolution parameters - Silhouette width [-1,1,max], Purity[0,1,max], Root-mean-squared difference [min]
clusters <- colnames(colData(sce))[str_detect(colnames(colData(sce)),"cluster_[:digit:]")]
df <- foreach(i = seq_along(clusters),.combine = rbind) %do% {
num_clus <- length(unique(colData(sce)[,clusters[i]]))
sil <- approxSilhouette(t(assay(sce, "exprs")), clusters=colData(sce)[,clusters[i]])
#purity <- neighborPurity(t(assay(sce, "exprs")), clusters=colData(sce)[,clusters[i]]) #takes very long to compute - do once and then save figure
rmsd <- clusterRMSD(t(assay(sce, "exprs")), clusters=colData(sce)[,clusters[i]])
data.frame(num_clus = num_clus,
           k = as.numeric(str_split(clusters[i],"_",simplify = TRUE)[,2]), 
           sil = mean(sil$width), 
#           purity = mean(purity$purity),
           rmsd = sum(rmsd))
}


p1 <- ggplot(df, aes(x=k, y=num_clus))+ 
  geom_line(lwd = 2,color = "#377EB8")+
  theme_classic()
p2 <- ggplot(df, aes(x=k, y=sil))+ 
  geom_line(lwd = 2,color = "#377EB8")+
  theme_classic()
p3 <- ggplot(df, aes(x=k, y=rmsd))+ 
  geom_line(lwd = 2,color = "#377EB8")+
  theme_classic()

p1+p2+p3 

#Chosen method => k=100

#Cluster colors 
col_clus <- colorRampPalette(brewer.pal(9,"Paired"))(length(unique(sce$cluster_100)))

#By clusters for one method (here k=100)
#1. Silhouette width [-1,1]
#Clusters with large positive silhouette widths are well-separated from other clusters
sil.approx <- approxSilhouette(t(assay(sce, "exprs")), clusters=sce$cluster_100)
sil.data <- as.data.frame(sil.approx)
sil.data$closest <- factor(ifelse(sil.data$width > 0, sce$cluster_100, sil.data$other))
sil.data$cluster <- sce$cluster_100

p4 <- ggplot(sil.data, aes(x=cluster, y=width, colour=closest)) +
    ggbeeswarm::geom_quasirandom(method="smiley")+
  theme_classic()+
  scale_color_manual(values = col_clus)
p4

# #By neighborpurity (takes very long to be computed - optional)
# pure.approx <- neighborPurity(t(assay(sce, "exprs")), clusters=sce$cluster_100)
# pure.data <- as.data.frame(pure.approx)
# pure.data$maximum <- factor(pure.data$maximum)
# pure.data$cluster <- sce$cluster_100
# 
# p5 <- ggplot(pure.data, aes(x=cluster, y=purity, colour=maximum)) +
#     ggbeeswarm::geom_quasirandom(method="smiley")+
#   theme_classic()+
#   scale_color_manual(values = col_clus)
# p5 
```

Observation:  
- Highest Silhouette width for k=100 => selected
- Cluster 3,4,6,8,10 = low silhouette width - pay attention

## Add metadata to SCE object

```{r metadata addition, message=FALSE, warning=TRUE}
sample_meta <- read.csv("/Volumes/rcc_volume/TNBC/data_analysis/03_data/ZTMA249_metadata_processed.csv")
colData(sce)$ID <- str_split(colData(sce)$sample_id,"_",simplify = TRUE)[,4]

#Add PID and lehmann_subtype
colData(sce)$PID <- sample_meta$PID[match(colData(sce)$ID,sample_meta$ID_Number)]
colData(sce)$lehmann_subtype <- sample_meta$lehmann_subtype[match(colData(sce)$ID,sample_meta$ID_Number)]

patient_meta <- read.csv("/Volumes/rcc_volume/TNBC/data_analysis/03_data/ZTMA249_metadata_processed_byPID.csv")
#Add Grade
colData(sce)$grade <- patient_meta$grade[match(colData(sce)$PID,patient_meta$PID)]

#SaveSCEwithmetadata
#saveRDS(sce,"/Volumes/rcc_volume/TNBC/data_analysis/sce_TNBC_249_Tumor_CC_ClusterChannelClus_k.rds")
```

## Heatmap 

Heatmap of clusters with additional information (other channels, spatial, grade, subtype)

```{r heatmap sce_1, message=FALSE,warning=FALSE}
#Read sce after clustering and GMM
#sce <- readRDS("/Volumes/rcc_volume/TNBC/data_analysis/sce_TNBC_249_Tumor_CC_ClusterChannelClus_k.rds")

### 1. Marker Heatmaps (Cluster channels, other_immune channels)

#Min-Max [0,1] normalization of arcsinh-transformed counts
assay(sce, "min_max") <- assay(sce, "exprs") - rowMins(assay(sce, "exprs"))
assay(sce, "min_max") <- assay(sce, "min_max") / (rowMaxs(assay(sce, "exprs")) - rowMins(assay(sce, "exprs")))

#Aggregrate across cells with the mean (median is also possible)
cluster_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_100,
                                 statistics = "mean",
                                 use.assay.type = "min_max",
                                 subset.row = rowData(sce)$cluster_channel)

cellstate_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_100,
                                 statistics = "mean",
                                 use.assay.type = "min_max",
                                 subset.row = rowData(sce)$cell_state_channel)

other_mean_sce <- aggregateAcrossCells(sce, ids = sce$cluster_100,
                                 statistics = "mean",
                                 use.assay.type = "min_max",
                                 subset.row = rowData(sce)$other_immune_channel)

### 2. Spatial Heatmap
#Add number of neighbors to sce object (saved in ColPair)
n_neighbors <- colPair(sce) %>% as.data.frame() %>% group_by(from) %>% count() %>% arrange(desc(n))

sce$n_neighbors <- n_neighbors$n[match(seq_along(colnames(sce)),n_neighbors$from)]
sce$n_neighbors <- sce$n_neighbors %>% replace_na(0)

#Double-check 
plotSpatial(sce[,colData(sce)$sample_id == "ZTMA249.1_ZTMA249_ID_1_AX1Y1_93"],img_id = "sample_id",colPairName = "neighborhood",draw_edges = FALSE, node_color_by = "n_neighbors",node_size_fix = 2)+
  scale_color_continuous(type = "viridis")+
  theme_classic()
plotSpatial(sce[,colData(sce)$sample_id == "ZTMA249.1_ZTMA249_ID_1_AX1Y1_93"],img_id = "sample_id",colPairName = "neighborhood",draw_edges = TRUE, node_color_by = "GMM_CK")+
  scale_color_brewer(palette = "Set1")+
  theme_classic()

#Select spatial features and average over clusters 
spatial <- colData(sce) %>% as.data.frame %>% select(area,eccentricity,cluster_100,n_neighbors)
spatial <- spatial %>% select(-cluster_100) %>% aggregate(by = list(cluster_100 = spatial$cluster_100), FUN = mean) %>% column_to_rownames("cluster_100")
#define min_max fct
min_max_norm <- function(x) {(x - min(x)) / (max(x) - min(x))}
#normalize
spatial_norm <- as.data.frame(lapply(spatial, min_max_norm))


###3.  Define annotation dataframe with n cells, clusters, metaclusters
anno <- colData(cluster_mean_sce) %>% as.data.frame %>% select(cluster_100, ncells)

##Set Preliminary cluster names (after visual inspection)
cluster_names <- c("CK5/7+","p53/EGFR/Ki67+","KRT14/Vim+","CK5low","Vim+","Unclear","Unclear","Ki67/p53+","Vim/Ki67+","Unclear","KRT14/HER2+","CD15+","Vim/Ki67/p53+","CK7+","Vim/Her2/CK7+","Vim/Ki67+_2","Vim/p53/cMYC+","GATA3low","HER2+","CK7/8/18+","Vim/CK5+","ER/GATA3+","KRT14+","KRT14/Ki67+","p53/cMYC+")
anno$names <- cluster_names
sce$cluster_names <- anno$names[match(sce$cluster_100,anno$cluster_100)]


###4. Patient metadata - grade / lehmann subtype

# Proportion of grade per cluster
grade <- colData(sce) %>% as.data.frame() %>% select(cluster_100,grade) %>% group_by(cluster_100) %>% table() %>% as.data.frame
grade <- grade %>% group_by(cluster_100) %>% mutate(fra = Freq/sum(Freq)) 
grade <- grade %>% select(-Freq) %>% pivot_wider(id_cols = cluster_100,names_from = grade,values_from = fra) %>% column_to_rownames("cluster_100")

# Proportion of lehmann subtype per cluster (as bubble plot)
subtype <- colData(sce) %>% as.data.frame() %>% select(cluster_100,lehmann_subtype) %>% group_by(cluster_100) %>% table() %>% as.data.frame
subtype <- subtype %>% group_by(cluster_100) %>% mutate(fra = Freq/sum(Freq)) 
subtype <- subtype %>% select(-Freq) %>% pivot_wider(id_cols = cluster_100,names_from = lehmann_subtype,values_from = fra) %>% column_to_rownames("cluster_100")

col_lehmann = colorRampPalette(brewer.pal(9, "Set2"))(length(unique(colData(sce)$lehmann_subtype)))

# Number of contributing patients/samples per cluster
cluster_SID <- colData(sce) %>% as.data.frame() %>% select(cluster_100,sample_id) %>% group_by(cluster_100) %>% table() %>% as.data.frame
n_SID <- cluster_SID %>% filter(Freq>0) %>% group_by(cluster_100) %>% count(name = "n_SID") %>% column_to_rownames("cluster_100")

cluster_PID <- colData(sce) %>% as.data.frame() %>% select(cluster_100,PID) %>% group_by(cluster_100) %>% table() %>% as.data.frame
n_PID <- cluster_PID %>% filter(Freq>0) %>% group_by(cluster_100) %>% count(name = "n_PID") %>% column_to_rownames("cluster_100")


# Cluster categories contributing to clusters
cluster_CC <- colData(sce) %>% as.data.frame() %>% select(cluster_100,cluster_category) %>% group_by(cluster_100) %>% table() %>% as.data.frame
cluster_CC <- cluster_CC %>% group_by(cluster_100) %>% mutate(fra = Freq/sum(Freq)) 
cluster_CC <- cluster_CC %>% select(-Freq) %>% pivot_wider(id_cols = cluster_100,names_from = cluster_category,values_from = fra) %>% column_to_rownames("cluster_100")

nPID_SID <- cbind(n_SID,n_PID)

###5. General heatmap color schemes 
#Heatmap body color 
col_main = viridis(100)

#retrieve row_order for sequential color scheme 
row_order_clusters <- row_order(Heatmap(t(assay(cluster_mean_sce, "min_max")),
        column_title = "cluster_channels",
        col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2"))



#Color scheme for clusters
col <- list(cluster_100 = colorRampPalette(brewer.pal(9, "Paired"))(length(unique(anno$cluster_100))))
col_clusters <- col[[1]]
names(col_clusters) = row_order_clusters
col_clusters <- list(col_clusters)
names(col_clusters) <- "cluster_100"


###6. Plot combined Heatmap
h <-Heatmap(t(assay(cluster_mean_sce, "min_max")),
        column_title = "cluster_channels",
        col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  Heatmap(t(assay(cellstate_mean_sce, "min_max")),
        column_title = "cellstate_channels",
        col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T,
        show_column_names =  T,
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  Heatmap(t(assay(other_mean_sce, "min_max")),
        column_title = "other_channels",
        col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  Heatmap(spatial_norm,
          column_title = "spatial_features",
          col = col_main,
        name= "min-max",
        km = 1,
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")+
  rowAnnotation(cluster_100 = anno_simple(unfactor(anno$cluster_100), pch = unfactor(anno$cluster_100),border=TRUE,col=col_clusters$cluster_100))+
  rowAnnotation(foo = anno_text(anno$names))+
  rowAnnotation(cluster_cat = anno_barplot(cluster_CC, width = unit(10, "mm"),gp = gpar(fill = c("#1F78B4","#A6CEE3")), col = 1),annotation_name_rot = 90)+
  rowAnnotation(n_cells = anno_barplot(anno$ncells, width = unit(10, "mm"),gp = gpar(fill = "#440154FF"), col = 1),annotation_name_rot = 90)+
  rowAnnotation(n_PID = anno_barplot(n_PID, width = unit(10, "mm"),gp = gpar(fill = "#440154FF"), col = 1),annotation_name_rot = 90)+
  rowAnnotation(grade = anno_barplot(grade, width = unit(10, "mm"),gp = gpar(fill = c("#FFF5F0","#FB6A4A","#67000D")), col = 1),annotation_name_rot = 90)+
  rowAnnotation(lehmann_subtype = anno_barplot(subtype, width = unit(15, "mm"), gp = gpar(fill = col_lehmann),col = 1,show_legend = TRUE),annotation_name_rot = 90)

draw(h)

#Cluster annotation heatmap
h_cluster_anno <- rowAnnotation(cluster_100 = anno_simple((row_order_clusters), pch = as.character(row_order_clusters),border=TRUE,col=col_clusters$cluster_100))+
  rowAnnotation(foo = anno_text(anno$names[row_order_clusters]))

draw(h_cluster_anno)

#Save sce
#saveRDS(sce,"/Volumes/rcc_volume/TNBC/data_analysis/sce_TNBC_249_Tumor_CC_ClusterChannelClus_k.rds")
```

## Dimensionality reduction 

```{r dimred, message=FALSE,warning=FALSE}
## Subsample 10% of cells from each core 
#to save time and not get super crowded dimensionality reduction plots
set.seed(22)
sub <- colData(sce) %>% as.data.frame() %>% group_by("sample_id") %>% slice_sample(prop = 0.1) %>% arrange("sample_id") %>% mutate(sub_id = paste(sample_id,ObjectNumber,sep="_")) %>% pull(sub_id)
sce_sub = sce[,sub]

#Run UMAP/TSNE on cluster channels
sce_sub = runUMAP(sce_sub[rowData(sce_sub)$cluster_channel,], n_neighbors = 100, pca = 50, exprs_values = "exprs",external_neighbors=TRUE, BPPARAM = MulticoreParam((detectCores()-2)))
sce_sub = runTSNE(sce_sub[rowData(sce_sub)$cluster_channel,], exprs_values = "exprs", external_neighbors=TRUE, BPPARAM = MulticoreParam((detectCores()-2)))


## 1. Visualize UMAP and TSNE
#panCK and GMM_CK
UMAP_clus <- plotReducedDim(sce_sub, dimred = "UMAP", colour_by = "cluster_100")+
  scale_color_manual(values = col_list_1[[1]])

TSNE_clus <- plotReducedDim(sce_sub, dimred = "TSNE", colour_by = "cluster_100")+
  scale_color_manual(values = col_list_1[[1]])

(UMAP_clus+TSNE_clus)

#Visualize all marker expression
all_plots_UMAP <- lapply(c(rownames(sce_sub)[rowData(sce_sub)$cluster_channel]),
                    function(x){
                      p <- plotReducedDim(sce_sub, dimred = "UMAP", 
                                          colour_by = x, 
                                          by_exprs_values = "exprs",
                                          point_size = 0.5)
                      return(p)                    
                    })

library(cowplot)
exp_plots_UMAP <- plot_grid(plotlist = all_plots_UMAP)

all_plots_TSNE <- lapply(c(rownames(sce_sub)[rowData(sce_sub)$cluster_channel]),
                    function(x){
                      p <- plotReducedDim(sce_sub, dimred = "TSNE", 
                                          colour_by = x, 
                                          by_exprs_values = "exprs",
                                          point_size = 0.5)
                      return(p)                    
                    })

library(cowplot)
exp_plots_TSNE <- plot_grid(plotlist = all_plots_TSNE)
```

### Heatmap for subset of cells

```{r heatmap sub}
#Heatmap visualization (all cells)
dittoHeatmap(sce_sub, 
             genes = rownames(sce_sub)[rowData(sce_sub)$cluster_channel],
             assay = "min_max", 
             scale = "none", 
             order.by = "cluster_100", 
             heatmap.colors = viridis(100), 
             annot.by = c("cluster_100"),
             annot.colors=col_clusters$cluster_100[order(as.numeric(names(col_clusters$cluster_100)))])
```

## Stacked barplots / Correlation of cluster fractions

```{r cluster-pro, message = FALSE, warning = FALSE}
#Fraction of PID/SID per cluster
cluster_SID <- colData(sce) %>% as.data.frame() %>% select(cluster_100,sample_id) %>% group_by(cluster_100) %>% table() %>% as.data.frame
cluster_SID <- cluster_SID %>% group_by(cluster_100) %>% mutate(fra = Freq/sum(Freq))
cluster_PID <- colData(sce) %>% as.data.frame() %>% select(cluster_100,PID) %>% group_by(cluster_100) %>% table() %>% as.data.frame
cluster_PID <- cluster_PID %>% group_by(cluster_100) %>% mutate(fra = Freq/sum(Freq))

col_PID = colorRampPalette(brewer.pal(9, "Set1"))(length(unique(cluster_PID$PID))) 
col_SID = colorRampPalette(brewer.pal(9, "Set1"))(length(unique(cluster_SID$sample_id))) 

p_clusterPID <- ggplot(cluster_PID) +
  geom_tile(color = "black",aes(cluster_100, fra, fill = PID), position = "stack")+
  scale_fill_manual(values=col_PID) + 
  theme_classic(base_size = 15)+
  ylab("PID fraction per cluster")+
  theme(axis.title.x = element_blank())+
  guides(fill = "none")

p_clusterSID <- ggplot(cluster_SID) +
  geom_tile(color = "black",aes(cluster_100, fra, fill = sample_id), position = "stack")+
  scale_fill_manual(values=col_SID) + 
  theme_classic(base_size = 15)+
  ylab("SID fraction per cluster")+
  theme(axis.title.x = element_blank())+
  guides(fill = "none")

p_clusterPID

#Fraction of cluster per PID/SID
SID_cluster <- colData(sce) %>% as.data.frame() %>% select(cluster_100,sample_id) %>% group_by(sample_id) %>% table() %>% as.data.frame
SID_cluster <- SID_cluster %>% group_by(sample_id) %>% mutate(fra = Freq/sum(Freq))
PID_cluster <- colData(sce) %>% as.data.frame() %>% select(cluster_100,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_cluster <- PID_cluster %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

p_PID_cluster <- ggplot(PID_cluster) +
  geom_tile(color = "black",aes(PID, fra, fill = cluster_100), position = "stack")+
  scale_fill_manual(values=col_clusters$cluster_100) + 
  theme_classic(base_size = 12)+
  ylab("Fraction")+
  xlab("PID")+
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

p_SID_cluster <- ggplot(SID_cluster) +
  geom_tile(color = "black",aes(sample_id, fra, fill = cluster_100), position = "stack")+
    scale_fill_manual(values=col_clusters$cluster_100) + 
  theme_classic(base_size = 15)+
  ylab("Fraction")+
  xlab("Sample_ID")+
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

# Cluster fraction correlation for each PID (2 samples per PID)
SID_cluster_cor <- SID_cluster
SID_cluster_cor$PID <- sce$PID[match(SID_cluster$sample_id,sce$sample_id)]

SID_cluster_cor <- foreach(i = unique(colData(sce)$PID),.combine = "rbind")%do%{
SID <- SID_cluster_cor %>% filter(PID %in% i) %>% select(-Freq,-PID) %>% pivot_wider(id_cols = cluster_100,names_from = sample_id,values_from = fra) %>% column_to_rownames("cluster_100")
cor <- cor(SID,method = "spearman")
cor[2]
}

SID_cluster_cor <- as.data.frame(SID_cluster_cor) 
SID_cluster_cor$PID <- unique(colData(sce)$PID) 
SID_cluster_cor$category <- "PID"

SID_cluster_cor_plot <- ggplot(SID_cluster_cor, aes(x = category, y = V1))+
  geom_boxplot(outlier.colour = NA)+
  geom_jitter(aes(color = PID), size = 3, position=position_jitter(w=0.1,h=0.1))+
  guides(color = "none")+
  scale_color_manual(values = col_PID)+
  theme_classic(base_size = 12)+
  theme(axis.title.x = element_blank())+
  ylab("Correlation of cluster fractions per PID (n=2)")+
  ggtitle(paste("Spearman rho = ",round(median(SID_cluster_cor$V1, na.rm = TRUE), digits = 2)))
  

p_PID_cluster+SID_cluster_cor_plot
```

## Check correlation of markers

```{r marker correlations}
# Cluster channel marker correlation (all markers - does not show distribution which is usually recommended)
cor_sce <- as.data.frame(t(assay(sce,"exprs")[rowData(sce)$cluster_channel,]))

corrplot(cor(cor_sce,method = "spearman"), method="color", col=brewer.pal(n=8, name="RdBu"),  
         type="upper", order="hclust",hclust.method = "ward.D2", 
         addCoef.col = "black", addCoefasPercent = F,# Add coefficient of correlation
         tl.col="black", tl.srt=40, #Text label color and rotation
         # Combine with significance
         #p.mat = p.mat, sig.level = 0.01, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag=F
)

# For specific markers of interest (also shows the value distribution which is recommended)
pairs.panels(cor_sce[,c("Ki67","p53")],
             method = "spearman",
             hist.col = "royalblue1",
             digits = 2)
```

## Make patientgroups based on primary tumor cluster compositions

#Option 1: Based on cluster fractions per PID

```{r pgroups, eval = F}
#kick out unclear clustering with little information (here 6 clusters)
#Proportions are aligned again (Correct???? - ask Nils)
PID_cluster_1 <- PID_cluster %>% filter(!cluster_100 %in% c("10","6","7","4","18")) %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))
  PID_groups <- PID_cluster_1 %>% pivot_wider(id_cols = "PID",names_from = "cluster_100",values_from = "fra") %>% column_to_rownames("PID")

#double-check that rowsums are 1 
#TO DO: need to calculate new fractions per PID if I remove cluster
rowSums(PID_groups)

#Annotation dataframes
row_anno <- PID_groups %>% rownames_to_column(var = "PID")
col_anno <- anno %>% filter(!cluster_100 %in% c("10","6","7","4","18"))

### 1. Cluster-testing
library(clValid)
#Internal measures
testCL<- clValid(PID_groups,nClust = 3:20,clMethods = c("hierarchical","agnes","kmeans"),validation="internal",metric="euclidean", method = "ward")
summary(testCL)
plot(testCL, legend = FALSE)
#Selected method: kmeans, 14

#kmeans clustering
set.seed(22)
out_k <- kmeans(PID_groups,14,nstart = 10000,iter.max = 10000)

row_anno$PID_groups <- out_k$cluster

### 2. Row annotation
#Add grade / lehmann subtype (potentiually as bubble plot? - not yet performed)
row_anno$grade <- sce$grade[match(row_anno$PID,sce$PID)]
row_anno$lehmann_subtype <- sce$lehmann_subtype[match(row_anno$PID,sce$PID)]

row_anno[is.na(row_anno)]<- "Unknown"

# Proportion of grade per patient group
grade <- row_anno %>% select(PID_groups,grade) %>% group_by(PID_groups) %>% table() %>% as.data.frame
grade <- grade %>% group_by(PID_groups) %>% mutate(fra = Freq/sum(Freq)) 
grade <- grade %>% select(-Freq) %>% pivot_wider(id_cols = PID_groups,names_from = grade,values_from = fra) %>% column_to_rownames("PID_groups")

# Proportion of lehmann subtype per patient group
subtype <- row_anno  %>% select(PID_groups,lehmann_subtype) %>% group_by(PID_groups) %>% table() %>% as.data.frame
subtype <- subtype %>% group_by(PID_groups) %>% mutate(fra = Freq/sum(Freq)) 
subtype <- subtype %>% select(-Freq) %>% pivot_wider(id_cols = PID_groups,names_from = lehmann_subtype,values_from = fra) %>% column_to_rownames("PID_groups")

#Color scheme
col <- list(PID_groups = colorRampPalette(brewer.pal(9, "Set3"))(length(unique(row_anno$PID_groups))),
           lehmann_subtype = colorRampPalette(brewer.pal(9, "Set2"))(length(unique(row_anno$lehmann_subtype))),
           grade = colorRampPalette(brewer.pal(2, "Reds"))(length(unique(row_anno$grade)))
)

col_list_1 <- foreach(i=1:3) %do% {
  color= col[[i]]
  names(color)= sort(unique(row_anno[,names(col)[i]]))
  color
}
names(col_list_1) <- c(names(col))

ha_right  <-  rowAnnotation(PID_groups = as.factor(row_anno$PID_groups), col = col_list_1[1], border = TRUE)

#Coloring main heatmap and column anno
col_main = viridis(100)
col_cluster_groups <- col_clusters$cluster_100[names(col_clusters$cluster_100) %in% col_anno$cluster_100]

#Print heatmap
h_g <- Heatmap(PID_groups, name = "Cluster fraction", 
        col = col_main,split = row_anno$PID_groups,
        show_column_names = T, show_row_names =  F, 
        row_title_side = c("right"),
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        right_annotation = ha_right,
        row_title_rot = 0) %v%
  columnAnnotation(cluster_100 = anno_simple(unfactor(col_anno$cluster_100), pch = unfactor(col_anno$cluster_100),
                                             border=TRUE, col = col_cluster_groups),annotation_name_side = "left") %v%
  columnAnnotation(foo = anno_text(col_anno$names))

draw(h_g)

### 2. Graph-based clustering based on cluster fractions

# #k=5
# set.seed(22)
# out <- Rphenograph(PID_groups, k = 5)
# PID_groups_5 <- factor(membership(out[[2]]))
# PID_groups_5
# PID_groups_df <- data.frame(PID_groups = PID_groups_5, PID = rownames(PID_groups))
# sce$PID_groups_5 <- PID_groups_df$PID_groups[match(sce$PID,PID_groups_df$PID)]
# meta_PID_groups$PID_groups_5 <- PID_groups_df$PID_groups[match(meta_PID_groups$PID,PID_groups_df$PID)]
# 
# #k=10
# set.seed(22)
# out <- Rphenograph(PID_groups, k = 10)
# PID_groups_10 <- factor(membership(out[[2]]))
# PID_groups_10
# PID_groups_df <- data.frame(PID_groups = PID_groups_10, PID = rownames(PID_groups))
# sce$PID_groups_10 <- PID_groups_df$PID_groups[match(sce$PID,PID_groups_df$PID)]
# meta_PID_groups$PID_groups_10 <- PID_groups_df$PID_groups[match(meta_PID_groups$PID,PID_groups_df$PID)]
# 
# #k=30
# set.seed(22)
# out <- Rphenograph(PID_groups, k = 30)
# PID_groups_30 <- factor(membership(out[[2]]))
# PID_groups_30
# PID_groups_df <- data.frame(PID_groups = PID_groups_30, PID = rownames(PID_groups))
# sce$PID_groups_30 <- PID_groups_df$PID_groups[match(sce$PID,PID_groups_df$PID)]
# meta_PID_groups$PID_groups_30 <- PID_groups_df$PID_groups[match(meta_PID_groups$PID,PID_groups_df$PID)]
# 
# #k=50
# set.seed(22)
# out <- Rphenograph(PID_groups, k = 50)
# PID_groups_50 <- factor(membership(out[[2]]))
# PID_groups_50
# PID_groups_df <- data.frame(PID_groups = PID_groups_50, PID = rownames(PID_groups))
# sce$PID_groups_50 <- PID_groups_df$PID_groups[match(sce$PID,PID_groups_df$PID)]
# meta_PID_groups$PID_groups_50 <- PID_groups_df$PID_groups[match(meta_PID_groups$PID,PID_groups_df$PID)]
# 
# #Over different resolution parameters - Silhouette width [-1,1,max], Purity[0,1,max]
# clusters <- colnames(meta_PID_groups)[str_detect(colnames(meta_PID_groups),"PID_groups_[:digit:]")]
# 
# df <- foreach(i = seq_along(clusters),.combine = rbind) %do% {
# num_clus <- length(unique(meta_PID_groups[,clusters[i]]))
# sil <- approxSilhouette(PID_groups, clusters=meta_PID_groups[,clusters[i]])
# data.frame(num_clus = num_clus,
#            k = as.numeric(str_split(clusters[i],"_",simplify = TRUE)[,3]), 
#            sil = mean(sil$width))
# }
# 
# pg1 <- ggplot(df, aes(x=k, y=num_clus))+ 
#   geom_line(lwd = 2,color = "#377EB8")+
#   theme_classic()
# pg2 <- ggplot(df, aes(x=k, y=sil))+ 
#   geom_line(lwd = 2,color = "#377EB8")+
#   theme_classic()
# 
# pg1+pg2
```
#Option 2: Based on center-log-ratio of cluster counts per PID

```{r centerlog, message = FALSE, warning = FALSE}
#Centered log ratio transform of cluster counts per patient
PID_groups_clr <- PID_cluster_1 %>% pivot_wider(id_cols = "PID",names_from = "cluster_100",values_from = "Freq") %>% column_to_rownames("PID")
PID_clr <- clr(PID_groups_clr) ##Center log transformation
PID_clr <- as.data.frame(PID_clr)
rowSums(PID_clr) #approx 0

## is the same as computing the CLR from the proportions??
# PID_groups_clr_1 <- PID_cluster_1 %>% pivot_wider(id_cols = "PID",names_from = "cluster_100",values_from = "fra") %>% column_to_rownames("PID")
# PID_clr_1 <- clr(PID_groups_clr_1) ##Center log transformation
# PID_clr_1 <- as.data.frame(PID_clr_1)
# rowSums(PID_clr_1) #approx 0

#Annotation dataframes
row_anno <- PID_clr %>% rownames_to_column(var = "PID")
col_anno <- anno %>% filter(!cluster_100 %in% c("10","6","7","4","18"))

### 1. Cluster-testing
library(clValid)
#Internal measures
testCL_1<- clValid(PID_clr,nClust = 3:20,clMethods = c("hierarchical","agnes","kmeans"),validation="internal",metric="euclidean", method = "ward")
summary(testCL_1)
plot(testCL_1, legend = FALSE)
#Selected method: kmeans, 16

#kmeans clustering
set.seed(22)
out_k <- kmeans(PID_clr,16,nstart = 10000,iter.max = 10000)

row_anno$PID_groups <- out_k$cluster

### 2. Row annotation
#Add grade / lehmann subtype (potentiually as bubble plot? - not yet performed)
row_anno$grade <- sce$grade[match(row_anno$PID,sce$PID)]
row_anno$lehmann_subtype <- sce$lehmann_subtype[match(row_anno$PID,sce$PID)]

row_anno[is.na(row_anno)]<- "Unknown"

# # Proportion of grade per patient group
# grade <- row_anno %>% select(PID_groups,grade) %>% group_by(PID_groups) %>% table() %>% as.data.frame
# grade <- grade %>% group_by(PID_groups) %>% mutate(fra = Freq/sum(Freq)) 
# grade <- grade %>% select(-Freq) %>% pivot_wider(id_cols = PID_groups,names_from = grade,values_from = fra) %>% column_to_rownames("PID_groups")
# 
# # Proportion of lehmann subtype per patient group
# subtype <- row_anno  %>% select(PID_groups,lehmann_subtype) %>% group_by(PID_groups) %>% table() %>% as.data.frame
# subtype <- subtype %>% group_by(PID_groups) %>% mutate(fra = Freq/sum(Freq)) 
# subtype <- subtype %>% select(-Freq) %>% pivot_wider(id_cols = PID_groups,names_from = lehmann_subtype,values_from = fra) %>% column_to_rownames("PID_groups")

#Color scheme
col <- list(PID_groups = colorRampPalette(brewer.pal(9, "Set3"))(length(unique(row_anno$PID_groups))),
           lehmann_subtype = colorRampPalette(brewer.pal(9, "Set2"))(length(unique(row_anno$lehmann_subtype))),
           grade = colorRampPalette(brewer.pal(2, "Reds"))(length(unique(row_anno$grade)))
)

col_list_1 <- foreach(i=1:3) %do% {
  color= col[[i]]
  names(color)= sort(unique(row_anno[,names(col)[i]]))
  color
}
names(col_list_1) <- c(names(col))

ha_right  <-  rowAnnotation(PID_groups = as.factor(row_anno$PID_groups), col = col_list_1[1], border = TRUE)

#Coloring main heatmap and column anno
col_main = viridis(100)
col_cluster_groups <- col_clusters$cluster_100[names(col_clusters$cluster_100) %in% col_anno$cluster_100]

#Print heatmap
h_g_1 <- Heatmap(PID_clr, name = "CLR of cluster fraction", 
        col = col_main,split = row_anno$PID_groups,
        show_column_names = T, show_row_names =  F, 
        row_title_side = c("right"),
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        right_annotation = ha_right,
        row_title_rot = 0)%v%
  
columnAnnotation(cluster_100 = anno_simple(unfactor(col_anno$cluster_100), pch = unfactor(col_anno$cluster_100),
                                             border=TRUE, col = col_cluster_groups),annotation_name_side = "left") %v%
  columnAnnotation(foo = anno_text(col_anno$names))

draw(h_g_1)
```

## Save plots as pdf

```{r save_plots}
##IMPORTANT: change to chunk output in console for this last part 

##save plots as pdf (vector graphics)
pdf("/Volumes/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_ClusterTesting.pdf",width = 10,height = 5)
p1+p2+p3
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_Silhouette_Cluster100.pdf",width = 12,height = 10)
p4
dev.off()

pdf("/Volumes/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_HeatmapCluster.pdf",width = 13,height = 8)
h
dev.off()

pdf("/Volumes/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_ClusterAnno.pdf",width = 5,height = 8)
h_cluster_anno
dev.off()

pdf("/Volumes/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_HeatmapCluster_subcells.pdf",width = 10,height = 8)
dittoHeatmap(sce_sub, 
             genes = rownames(sce_sub)[rowData(sce_sub)$cluster_channel],
             assay = "min_max", 
             scale = "none", 
             order.by = "cluster_100", 
             heatmap.colors = viridis(100), 
             annot.by = c("cluster_100"),
             annot.colors=col_clusters$cluster_100[order(as.numeric(names(col_clusters$cluster_100)))])
dev.off()

pdf("/Volumes/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_ExpressionCor.pdf",width = 10,height = 8)
corrplot(cor(cor_sce,method = "spearman"), method="color", col=brewer.pal(n=8, name="RdBu"),  
         type="upper", order="hclust",hclust.method = "ward.D2", 
         addCoef.col = "black", addCoefasPercent = F,# Add coefficient of correlation
         tl.col="black", tl.srt=40, #Text label color and rotation
         # Combine with significance
         #p.mat = p.mat, sig.level = 0.01, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag=F
)
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_UMAPTSNECluster.pdf",width = 12,height = 6)
UMAP_clus+TSNE_clus
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_TSNEExpression.pdf",width = 12,height = 6)
exp_plots_TSNE
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_UMAPExpression.pdf",width = 12,height = 6)
exp_plots_UMAP
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_ClusterPIDSID.pdf",width = 12,height = 6)
p_clusterPID+p_clusterSID
dev.off()

pdf("/mnt/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_PIDCluster_ClusterCor.pdf",width = 14,height = 6)
p_PID_cluster+SID_cluster_cor_plot
dev.off()

pdf("/Volumes/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_HeatmapPIDgroups.pdf",width = 11,height = 7)
h_g
dev.off()

pdf("/Volumes/rcc_volume/TNBC/data_analysis/01_figures/TNBC_249_Tumor_CC_HeatmapPIDgroupsCLR.pdf",width = 11,height = 7)
h_g_1
dev.off()

##IMPORTANT: change back to chunk output inline
```



---
title: "09_validation_prediction"
author: "Lasse Meyer"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Software requirements

```{r lib, message=FALSE,warning=FALSE}
#Data containers
library(SpatialExperiment)
library(SingleCellExperiment)

#Data processing
library(scuttle)
library(scater)
library(scran)
library(imcRtools)

#Data visualization
library(cytomapper)
library(dittoSeq)
library(pheatmap)
library(cowplot)
library(ComplexHeatmap)
library(circlize)

#Utilities
library(tidyverse)
library(openxlsx)
library(stringr)
library(patchwork)
library(parallel)
library(BiocParallel)
library(BiocNeighbors)
library(BiocSingular)
library(tiff)
library(ggrepel)
library(EBImage)
library(viridis)
library(mclust)
library(Rphenograph)
library(igraph)
library(RColorBrewer)
library(foreach)
library(clValid)
library(bluster)
library(psych)
library(corrplot)
library(psych)

#Batch correction
library(batchelor)

#Machine learning
library(caret)
library(caretEnsemble)
```

# Classifier for metacluster prediction

Here, we will train a classifier to predict tumor metacluster in an independent validation dataset (Janas data). For this, we will use the `caret` package.

## 1. Read in data (train)

```{r}
##Load sce
sce <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/07_sce_combined.rds")
```

### Filter for tumor cells

```{r}
sce <- sce[,sce$analysis_cat == "tumor"]
sce$metacluster_combined <- factor(unfactor(sce$metacluster_combined))
sce

## Add more rowData 

rowData(sce)$tumor_metacluster_relevant <- rowData(sce)$clean_target %in% c("CK5","CK7","KRT14","CK8_18","CD15","HLADR","Vimentin","pH3","Ki67","EGFR")
```

## 2. Train the model

```{r}
library(caret)
library(doParallel)

set.seed(22)

# Register parallel backend 
cl <- makePSOCKcluster(5, setup_strategy = "sequential")
registerDoParallel(cl)

#Set seeds for each iteration for parallel processing
seeds <- vector(mode = "list", length = 6)
for (i in 1:5) {
  seeds[[i]] <- sample(5000, 5)
}
seeds[[6]] <- sample(5000, 1) # for the final model


# Randomly split into train and test data
set.seed(22)
trainIndex <- createDataPartition(sce$metacluster_combined, p = 0.75)
train_sce <- sce[,trainIndex$Resample1]
test_sce <- sce[,-trainIndex$Resample1]

colData(train_sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% count()
colData(test_sce) %>% as.data.frame %>% group_by(metacluster_combined) %>% count()

# Train data
train_data <- t(assay(train_sce, "exprs")[rowData(train_sce)$tumor_cluster_channel,])

# Set folds for CV steps based on PID
folds <- groupKFold(train_sce$PID, k=5) 
#lapply(folds, function(x, y) table(y[x]), y = groups)

# Specify train parameters for 5-fold cross validation
fitControl <- trainControl(method = "cv",
                           number = 5,
                           seeds = seeds, 
                           index = folds)

# Train a random forest model for predicting cell labels
# This call also performs parameter tuning
rffit <- train(x = train_data, 
               y = train_sce$metacluster_combined,
               method = "rf", 
               metric = 'Accuracy',
               tuneLength = 5,
               trControl = fitControl)

rffit
stopCluster(cl)

saveRDS(rffit, "/mnt/rcc_volume/TNBC/data_analysis/randomforest_metacluster_pred_folds_allmarkers.rds")
rffit_all <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/randomforest_metacluster_pred.rds")
rffit_sub <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/randomforest_metacluster_pred_submarker.rds")
#rffit_all_folds <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/randomforest_metacluster_pred_folds_allmarkers.rds")
#rffit <- readRDS("/mnt/rcc_volume/TNBC/data_analysis/randomforest_metacluster_pred_submarker.rds")
```


## Assess feature importance

```{r}
# Classification accuracy during parameter tuning
ggplot(rffit) + 
  geom_errorbar(data = rffit$results,
                aes(ymin = Accuracy - AccuracySD,
                    ymax = Accuracy + AccuracySD),
                width = 0.4) +
    theme_classic(base_size = 15)

# Feature importance
plot(varImp(rffit))
```

## 3. Predict on test data

```{r}
# Select test data
mat_test <- t(assay(test_sce, "exprs")[rowData(test_sce)$tumor_cluster_channel,])

# Predict cell phenotypes in test data
cur_pred <- predict(rffit, 
                    newdata = mat_test)
```

## Assess classifier performance

```{r}
cm <- confusionMatrix(data = cur_pred, 
                      reference = test_sce$metacluster_combined, 
                      mode = "everything")

cm
```


```{r}
library(tidyverse)

data.frame(cm$byClass) %>%
  mutate(class = sub("Class: ", "", rownames(cm$byClass))) %>%
  ggplot() + 
  geom_point(aes(1-Specificity, Sensitivity, 
                 size = Detection.Rate,
                 fill = class),
             shape = 21) + 
  scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
  theme_classic(base_size = 15) + 
  ylab("Sensitivity (TPR)") +
  xlab("1 - Specificity (FPR)")
```

```{r}
cur_pred <- predict(rffit, 
                    newdata = mat_test, 
                    type = "prob")
cur_pred$truth <- factor(test_sce$metacluster_combined)

cur_plot <- cur_pred %>%
  pivot_longer(cols = 1:11)

ggplot(cur_plot, aes(x = name, y = value, fill = name)) +
  geom_boxplot(outlier.size = 0.5) +
  facet_wrap(. ~ truth, ncol = 1) + 
  scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)+
  theme(panel.background = element_blank(), 
        axis.text.x = element_text(angle = 45, hjust = 1))
```


## 4. Read in validation dataset
First, we will read in the `SingleCellExperiment` object containing the cleaned, spillover-corrected single-cell data. 
**Note:** We pre-processed the main cohort together with the validation cohort (including segmentation) to avoid strong batch effects. 

```{r read-data-batch-correction, message=FALSE}
sce_val <- readRDS("/mnt/tnbc_volume/TNBC_all/data_analysis/04_sce_TNBC_Clus_com.rds")
```

Filter sce for validation cohort and tumor cells

```{r filter sce, message=FALSE}
sce_val <- sce_val[,sce_val$analysis_cat == "tumor" & sce_val$TMANr %in% c("TMA21", "TMA26")]
sce_val

# Add rowData 
rowData(sce_val)$tumor_cluster_channel <- rowData(sce)$tumor_cluster_channel
```

Correct survival information 

```{r}
sce_val$status_OS <- ifelse(is.na(sce_val$status_OS) & !is.na(sce_val$OS_months), 0,sce_val$status_OS)
```

## 5. Predict on validation dataset 

```{r}
# Select validation expression matrix
mat_valid <- t(assay(sce_val, "exprs")[rowData(sce_val)$tumor_cluster_channel,])

# Predict metacluster
cell_class <- as.character(predict.train(rffit, 
                                         newdata = mat_valid, 
                                         type = "raw"))

names(cell_class) <- rownames(mat_valid)

table(cell_class)
```

```{r}
cell_prob <- predict.train(rffit, 
                           newdata = mat_valid, 
                           type = "prob")
```


```{r}
library(ggridges)

# Distribution of maximum probabilities
tibble(max_prob = rowMax(as.matrix(cell_prob)),
       type = cell_class) %>%
    ggplot() +
        geom_density_ridges(aes(x = max_prob, y = cell_class, fill = cell_class)) +
        scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
        theme_classic(base_size = 15) +
        xlab("Maximum probability") +
        ylab("Metacluster") + 
        xlim(c(0,1.2))

# Distribution of probability margins (max - 2.max)

margin <- cell_prob %>% rownames_to_column(var = "cell_id") %>% pivot_longer(cols = 2:12, values_to = "prob", names_to = "MC") %>% group_by(cell_id) %>% arrange(desc(prob)) %>% summarise(max = max(prob), second = nth(prob,2), MC = MC) %>% mutate(margin = max - second)

margin$MC <- cell_class[match(margin$cell_id, names(cell_class))]

margin <- margin %>% unique()

ggplot(margin, aes(x=margin, y = MC, fill = MC)) +
        geom_density_ridges() +
        scale_fill_manual(values = metadata(sce)$colors$metacluster_combined, limits = force) +
        theme_classic(base_size = 15) +
        xlab("Probability margin") +
        ylab("Metacluster") + 
        xlim(c(0,1.2))



```

Add to sce 

```{r}
# Store labels in SpatialExperiment object

sce_val$metacluster_predict <- factor(cell_class[match(sce_val$cell_id, names(cell_class))])

cur_table <- table(sce_val$metacluster_predict, sce_val$PID)

colData(sce_val) %>% as.data.frame %>% filter(PID %in% c("2123","924","458","21","863")) %>% select(PID, pN_simple, pM_simple, status_OS, OS_months) %>% unique()

plotSpatial(sce_val[,sce_val$PID == "96"], 
            node_color_by = "metacluster_predict", 
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")

plotSpatial(sce_val[,sce_val$PID == "924"], 
            node_color_by = "CK5", 
            assay_type = "exprs",
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")

plotSpatial(sce_val[,sce_val$PID == "924"], 
            node_color_by = "CK7", 
            assay_type = "exprs",
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")

plotSpatial(sce_val[,sce_val$PID == "2123"], 
            node_color_by = "CK8_18", 
            assay_type = "exprs",
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")
```

## 6. Result analysis 

```{r}
# Focus on basoluminal cells
cur_scat <- t(assay(sce_val,"exprs")) %>% as.data.frame %>% select("CK5","CK7","CK8_18")

cur_scat$metacluster_predict <- sce_val$metacluster_predict[match(rownames(cur_scat),sce_val$cell_id)]
  
cur_scat <- cur_scat %>% filter(metacluster_predict == "tumor_8")

ggplot(cur_scat, aes(x=CK7, y=CK5, color = metacluster_predict)) +
  geom_point(alpha = 0.5)+
  #stat_density_2d(aes(fill = ..level..), geom="polygon", contour_var = "count")+
  theme_classic()

ggplot(cur_scat, aes(x=CK8_18, y=CK5, color = metacluster_predict)) +
  geom_point(alpha = 0.5)+
  #stat_density_2d(aes(fill = ..level..), geom="polygon", contour_var = "count")+
  theme_classic()
```
```{r}
# 2. Metacluster
library(tidyverse)
for_plot_MC <- colData(sce_val) %>% as_tibble() %>%
    group_by(PID, metacluster_predict) %>%
    summarize(count = n()) %>%
    mutate(log_count = log(count)) %>%
    pivot_wider(id_cols = PID, names_from = metacluster_predict, 
                values_from = log_count, values_fill = 0) %>%
    ungroup() %>%
    select(-PID)

Heatmap(for_plot_MC, 
        name = "log(cell_count)",
        col = viridis(100)
        )
```


## Heatmap visualization 

```{r}
#Aggregrate across cells with the mean (median is also possible)
cluster_mean_sce <- aggregateAcrossCells(sce_val, ids = sce_val$metacluster_predict,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce)$tumor_cluster_channel)

col_exprs <- colorRamp2(c(0,1,2,3), c("#440154FF", "#31688EFF", "#35B779FF", "#FDE725FF"))

anno <- colData(cluster_mean_sce) %>% as.data.frame %>% select(metacluster_predict,ncells)

# Proportion of grade per cluster
grade <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,grade) %>% group_by(metacluster_predict) %>% table() %>% as.data.frame
grade <- grade %>% group_by(metacluster_predict) %>% mutate(fra = Freq/sum(Freq)) 
grade <- grade %>% select(-Freq) %>% pivot_wider(id_cols = metacluster_predict,names_from = grade,values_from = fra) %>% column_to_rownames("metacluster_predict")

# Proportion of pT stage per cluster
pT <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,pT_simple) %>% group_by(metacluster_predict) %>% table() %>% as.data.frame
pT <- pT %>% group_by(metacluster_predict) %>% mutate(fra = Freq/sum(Freq)) 
pT <- pT %>% select(-Freq) %>% pivot_wider(id_cols = metacluster_predict,names_from = pT_simple,values_from = fra) %>% column_to_rownames("metacluster_predict")

# Proportion of pN stage per cluster
pN <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,pN_simple) %>% group_by(metacluster_predict) %>% table() %>% as.data.frame
pN <- pN %>% group_by(metacluster_predict) %>% mutate(fra = Freq/sum(Freq)) 
pN <- pN %>% select(-Freq) %>% pivot_wider(id_cols = metacluster_predict,names_from = pN_simple,values_from = fra) %>% column_to_rownames("metacluster_predict")

# Number of contributing patients
cluster_PID <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,PID) %>% group_by(metacluster_predict) %>% table() %>% as.data.frame
n_PID <- cluster_PID %>% filter(Freq>0) %>% group_by(metacluster_predict) %>% count(name = "n_PID") %>% column_to_rownames("metacluster_predict")

# Metadata annotation
ha_meta <- HeatmapAnnotation(metacluster_predict = anno_simple(unfactor(anno$metacluster_predict), pch = str_split(unfactor(anno$metacluster_predict),"_",simplify = TRUE)[,2],border=TRUE,col=metadata(sce)$colors$metacluster_combined),
                            n_cells = anno_barplot(anno$ncells, width = unit(10, "mm"),gp = gpar(fill = "#440154FF")),
                            n_PID = anno_barplot(n_PID, width = unit(10, "mm"),gp = gpar(fill = "#440154FF")),
                            grade = anno_barplot(grade, width = unit(10, "mm"),gp = gpar(fill = metadata(sce_val)$colors$grade)),
                            pT = anno_barplot(pT, width = unit(10, "mm"),gp = gpar(fill = metadata(sce_val)$colors$pT_simple)),
                            pN = anno_barplot(pN, width = unit(10, "mm"),gp = gpar(fill = metadata(sce_val)$colors$pN_simple)),
                            #cluster_cat = anno_barplot(cluster_CC, width = unit(10, "mm"),gp = gpar(fill = metadata(sce_val)$colors$cluster_category)),
                            border = TRUE, 
                            annotation_name_rot = 90,
                            gap = unit(1,"mm"),
                            which = "row")

Heatmap(t(assay(cluster_mean_sce, "exprs")),
        column_title = "pred_channels",
        col = col_exprs,
        name = "mean exprs",
        row_title = NULL, 
        show_column_names =  TRUE, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        row_split = anno$metacluster_predict,
        cluster_row_slices = FALSE)+
  ha_meta

Heatmap(mat_scaled,
        column_title = "pred_channels",
        #col = col_exprs,
        name = "mean exprs",
        row_title = NULL, 
        show_column_names =  TRUE, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2",
        #row_split = anno$metacluster_predict,
        cluster_row_slices = FALSE)+
  ha_meta


mat_scaled <- as.data.frame(scale(t(assay(cluster_mean_sce, "exprs"))))



t(scale(t(assay(cluster_mean_sce, "exprs"))))
   
```







```{r}
test <- Cox_df %>% filter(is.na(status_OS) & !is.na(OS_months)) %>% select(12:18)
```







```{r}
library(survival)
library(survminer)

PID_metacluster_predict <- colData(sce_val) %>% as.data.frame() %>% select(metacluster_predict,PID) %>% group_by(PID) %>% table() %>% as.data.frame
PID_metacluster_predict <- PID_metacluster_predict %>% group_by(PID) %>% mutate(fra = Freq/sum(Freq))

### Multivariate cox proportional hazard model on multiple covariates (here proportion of phenotypes)
PID_metagroups <- PID_metacluster_predict %>% pivot_wider(id_cols = "PID",names_from = "metacluster_predict",values_from = "fra") %>% column_to_rownames("PID")

## 1. Based on continuous cluster proportions
Cox_df <- PID_metagroups

#add covariates for correction
Cox_df$status_OS <- sce_val$status_OS[match(rownames(Cox_df),sce_val$PID)]
Cox_df$OS_months <- sce_val$OS_months[match(rownames(Cox_df),sce_val$PID)]

Cox_df$age <- sce_val$age[match(rownames(Cox_df),sce_val$PID)]
Cox_df$grade <- factor(sce_val$grade[match(rownames(Cox_df),sce_val$PID)], levels = c("3","2","1"))
Cox_df$pT_simple <- as.factor(sce_val$pT_simple[match(rownames(Cox_df),sce_val$PID)])
Cox_df$pN_simple <- as.factor(sce_val$pN_simple[match(rownames(Cox_df),sce_val$PID)])
Cox_df$pM_simple <- as.factor(sce_val$pM_simple[match(rownames(Cox_df),sce_val$PID)])

is.na(Cox_df$status_OS)

#Based on proportions
covariates <- Cox_df %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple, -tumor_10) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + "),"+ tumor_10"))

multi_model <- coxph(multi_formula, data = Cox_df)

multi_res <- summary(multi_model)

plot_df_prop <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))


#Plot hazard ratios
hr_prop <- ggplot(plot_df_prop, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metacluster_predicts")+
ylab("HR for con_prop")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop

## 2. Based on categories (mean division of cluster proportions)
Cox_df_mean <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
Cox_df %>% select(i) %>% mutate(mean = ifelse(Cox_df[,i] > mean(Cox_df[,i]),"B","A")) %>% pull(mean)
}

colnames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_mean) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_mean <- as.data.frame(Cox_df_mean)

identical(rownames(Cox_df), rownames(Cox_df_mean))

Cox_df_mean <- cbind(Cox_df_mean, Cox_df %>% select(status_OS,OS_months, status_OS, OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_mean %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_mean)

summary(multi_model)

multi_res <- summary(multi_model)

plot_df_mean <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_mean <- ggplot(plot_df_mean, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metacluster_predicts")+
ylab("HR for mean")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_mean

## 3. Based on categories (GMM division of cluster proportions)
Cox_df_GMM <- foreach(i = Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames,.combine = "cbind")%do%{
GMM_Cox <- Mclust(Cox_df[,i], G = 2)
as.character(GMM_Cox$classification)
}

colnames(Cox_df_GMM) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames
rownames(Cox_df_GMM) <- Cox_df %>% select(-status_OS,-OS_months, -status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% rownames
Cox_df_GMM <- as.data.frame(Cox_df_GMM,stringsAsFactors=TRUE)

identical(rownames(Cox_df), rownames(Cox_df_GMM))

Cox_df_GMM <- cbind(Cox_df_GMM, Cox_df %>% select(status_OS,OS_months, status_OS, OS_months, age, grade, pT_simple, pN_simple, pM_simple))

#Based on proportions
covariates <- Cox_df_GMM %>% select(-status_OS,-OS_months, -age, -grade, -pT_simple, -pN_simple, -pM_simple) %>% colnames

multi_formula <- as.formula(paste("Surv(OS_months, status_OS) ~ age + grade + pT_simple + pN_simple + pM_simple +", paste(covariates, collapse = " + ")))

multi_model <- coxph(multi_formula, data = Cox_df_GMM)

summary(multi_model)

summary(Cox_df_GMM)

multi_res <- summary(multi_model)

plot_df_GMM <- data.frame(group = rownames(multi_res$coefficients),
                      p_value = signif(multi_res$coefficients[,"Pr(>|z|)"],2),
                      HR = signif(multi_res$coefficients[,"exp(coef)"],2),
                      CI_low = signif(multi_res$conf.int[,"lower .95"],2),
                      CI_high = signif(multi_res$conf.int[,"upper .95"],2),
                      wald_test = signif(multi_res$waldtest["pvalue"],2))

#Plot hazard ratios
hr_GMM <- ggplot(plot_df_GMM, aes(x = reorder(group,desc(HR)), y = HR, color = p_value < 0.05))+
geom_point(size = 4)+
geom_errorbar(aes(ymax = CI_high, ymin = CI_low))+
coord_cartesian(ylim=c(0,50))+
geom_hline(yintercept = 1,color = "black",linetype = "dashed")+
scale_color_brewer(palette = "Set1")+
xlab("Tumor metacluster_predicts")+
ylab("HR for GMM")+
theme_classic()+
theme(axis.text.x = element_text(angle = 90))

hr_prop/
hr_mean/
hr_GMM
```

```{r}
#Plot survival curves
fit <- survfit(Surv(OS_months, status_OS) ~ tumor_8, data = Cox_df_mean)
print(fit)

p1 <- ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = "Set1",
          log.rank.weights = "n")+
  ggtitle("Mean proportion")

fit <- survfit(Surv(OS_months, status_OS) ~ tumor_6, data = Cox_df_mean)
print(fit)

p2 <- ggsurvplot(fit,
          pval = TRUE,
          risk.table = TRUE, # Add risk table
          risk.table.col = "strata", # Change risk table color by groups
          linetype = "strata", # Change line type by groups
          surv.median.line = "hv", # Specify median survival
          ggtheme = theme_classic(), # Change ggplot2 theme
          palette = "Set1",
          log.rank.weights = "n")+
  ggtitle("Mean proportion")

arrange_ggsurvplots(list(p1,p2))
```


## 7. Independent clustering 

```{r}
## Run clustering
library(Rphenoannoy)
set.seed(22)

mat <- t(assay(sce_val, "exprs")[rowData(sce_val)$tumor_cluster_channel,])

#k=30
out <- Rphenoannoy(mat, k = 30)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_30 <- clusters

unique(sce_val$cluster_30)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/rcc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=50
out <- Rphenoannoy(mat, k = 50)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_50 <- clusters

unique(sce_val$cluster_50)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/rcc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=70
out <- Rphenoannoy(mat, k = 70)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_70 <- clusters

unique(sce_val$cluster_70)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/rcc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=90
out <- Rphenoannoy(mat, k = 90)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_90 <- clusters

unique(sce_val$cluster_90)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/rcc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=110
out <- Rphenoannoy(mat, k = 110)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_110 <- clusters

unique(sce_val$cluster_110)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/rcc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()

#k=130
out <- Rphenoannoy(mat, k = 130)

clusters <- factor(membership(out[[2]]))

sce_val$cluster_130 <- clusters

unique(sce_val$cluster_130)

#Save sce_vals after clustering
saveRDS(sce_val, "/mnt/rcc_volume/TNBC/data_analysis/09_sce_val_TNBC_tumor.rds")

gc()
```

## Cluster stability testing and comparison

```{r clustree, message = FALSE, warning=FALSE}
#Pairwise rand index 
#Agreement between two clustering approaches - ARI > 0.5 = "good" similarity
pairwiseRand(sce_val$cluster_30,sce_val$cluster_50, mode = "index")
pairwiseRand(sce_val$cluster_50,sce_val$cluster_70, mode = "index")
pairwiseRand(sce_val$cluster_70,sce_val$cluster_90, mode = "index")
pairwiseRand(sce_val$cluster_90,sce_val$cluster_110, mode = "index")
pairwiseRand(sce_val$cluster_110,sce_val$cluster_130, mode = "index")

#Over different resolution parameters - Silhouette width [-1,1,max], Purity[0,1,max], Root-mean-squared difference [min]
clusters <- colnames(colData(sce_val))[str_detect(colnames(colData(sce_val)),"cluster_[:digit:]")]
df <- foreach(i = seq_along(clusters),.combine = rbind) %do% {
num_clus <- length(unique(colData(sce_val)[,clusters[i]]))
sil <- approxSilhouette(t(assay(sce_val, "min_max")), clusters=colData(sce_val)[,clusters[i]])
#purity <- neighborPurity(t(assay(sce_val, "exprs")), clusters=colData(sce_val)[,clusters[i]]) #takes very long to compute - do once and then save figure
rmsd <- clusterRMSD(t(assay(sce_val, "min_max")), clusters=colData(sce_val)[,clusters[i]])
data.frame(num_clus = num_clus,
           k = as.numeric(str_split(clusters[i],"_",simplify = TRUE)[,2]), 
           sil = mean(sil$width), 
#           purity = mean(purity$purity),
           rmsd = sum(rmsd))
}

p1 <- ggplot(df, aes(x=k, y=num_clus))+
  geom_point(aes(k, num_clus, col = num_clus))+
  geom_line(aes(k, num_clus,col=num_clus))+
  theme_classic()+
  scale_color_continuous(type = "viridis")

p2 <- ggplot(df, aes(x=k, y=rmsd))+
  geom_point(aes(k, rmsd, col = rmsd))+
  geom_line(aes(k, rmsd,col=rmsd))+
  theme_classic()+
  scale_color_continuous(type = "viridis")

p3 <- ggplot(df, aes(x=k, y=sil))+
  geom_point(aes(k, sil, col = sil))+
  geom_line(aes(k, sil,col=sil))+
  theme_classic()+
  scale_color_continuous(type = "viridis")
  
p1+p2+p3 
```
```{r}
#Heatmap body colors
col_exprs <- colorRamp2(c(0,1,2,3), c("#440154FF", "#31688EFF", "#35B779FF", "#FDE725FF"))

### 1. Mean exprs counts
#Aggregrate across cells with the mean

cluster_mean_sce_val <- aggregateAcrossCells(sce_val, ids = sce_val$cluster_110,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce_val)$tumor_cluster_channel)

cluster_mean_sce_val_1 <- aggregateAcrossCells(sce_val, ids = sce_val$cluster_130,
                                 statistics = "mean",
                                 use.assay.type = "exprs",
                                 subset.row = rowData(sce_val)$tumor_cluster_channel)

h_110 <- Heatmap(t(assay(cluster_mean_sce_val, "exprs")),
        column_title = "1. mean exprs",
        col = col_exprs,
        name= "mean exprs",
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")
  
h_130 <- Heatmap(t(assay(cluster_mean_sce_val_1, "exprs")),
        column_title = "1. mean exprs",
        col = col_exprs,
        name= "mean exprs",
        show_row_names = T, 
        show_column_names =  T, 
        clustering_method_rows = "ward.D2",
        clustering_method_columns = "ward.D2")

h_110 
h_130

scale(table(sce_val$cluster_130,sce_val$metacluster_predict))

Heatmap(table(sce_val$cluster_130,sce_val$metacluster_predict), 
        col = viridis(100))+

Heatmap(scale(table(sce_val$cluster_130,sce_val$metacluster_predict)))
```

```{r}
cur_sample <- colData(sce_val) %>% as.data.frame %>% group_by(cluster_110) %>% filter(cluster_110 == "21") %>% count(sample_id) %>% arrange(desc(n)) %>% slice(1:10) %>% pull(sample_id)

cur_sample <- colData(sce_val) %>% as.data.frame %>% group_by(metacluster_predict) %>% filter(metacluster_predict == "tumor_8") %>% count(sample_id) %>% arrange(desc(n)) %>% slice(1:10) %>% pull(sample_id)

plotSpatial(sce_val[,sce_val$sample_id %in% cur_sample & sce_val$metacluster_predict == "tumor_8"], 
            node_color_by = "cluster_110", 
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")

plotSpatial(sce_val[,sce_val$sample_id %in% cur_sample & sce_val$metacluster_predict == "tumor_8"], 
            node_color_by = "metacluster_predict", 
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")+
  scale_color_manual(values = metadata(sce)$colors$metacluster_combined, limits = force)

plotSpatial(sce_val[,sce_val$sample_id %in% cur_sample & sce_val$metacluster_predict == "tumor_8"], 
            node_color_by = "CK5", 
            assay_type = "exprs",
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")

plotSpatial(sce_val[,sce_val$sample_id %in% cur_sample & sce_val$metacluster_predict == "tumor_8"], 
            node_color_by = "CK7", 
            assay_type = "exprs",
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")

plotSpatial(sce_val[,sce_val$sample_id %in% cur_sample & sce_val$metacluster_predict == "tumor_8"], 
            node_color_by = "CK8_18", 
            assay_type = "exprs",
            img_id = "sample_id", 
            node_size_fix = 2,
            node_shape_by = "analysis_cat")
```

